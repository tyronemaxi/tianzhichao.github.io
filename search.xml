<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RESTful API 最佳实践</title>
    <url>/posts/ea12054a/</url>
    <content><![CDATA[<h1 id="RESTful-API-最佳实践"><a href="#RESTful-API-最佳实践" class="headerlink" title="RESTful API 最佳实践"></a>RESTful API 最佳实践</h1><img src="https://betimdrenica.files.wordpress.com/2015/03/api2.png?w=300&h=176" alt="api2" style="zoom:100%;" />

<h2 id="API-的关键要求"><a href="#API-的关键要求" class="headerlink" title="API 的关键要求"></a>API 的关键要求</h2><ul>
<li>网络标准的使用</li>
<li>对开发人员友好，并能通过浏览器地址栏进行探索</li>
<li>简单、直观和一致，使用简单且愉快</li>
<li>足够的灵活性</li>
<li>高效的使用</li>
</ul>
<h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><h3 id="Media-Type"><a href="#Media-Type" class="headerlink" title="Media Type"></a>Media Type</h3><p><strong>默认媒体类型为 JSON</strong></p>
<blockquote>
<p>由于 HTTP 的最新势头和遵循标准，JSON 是最受欢迎的，因此应该明确成为默认的媒体类型</p>
<p>XML 的有点是复杂的场景和历史（SOAP），XML 不是 API  的最佳选择。它冗长，难以解析，难以阅读，其数据模型与大多数编程语言的数据模型不兼容。</p>
</blockquote>
<h2 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h2><p>RESTful 关键原则是将一系列 API 资源通过 <strong>域名+资源名称 + HTTP methods</strong></p>
<p>逻辑资源应该<strong>从 API 消费者的角度</strong>来进行考虑：<strong>使用有意义的名词s, 而不是动词</strong>，需要明确的是：名词是事物，动词是你对它所做的。</p>
<p>定义资源后，对于每种的资源的不同操作映射为对应的 HTTP 请求方法：</p>
<ul>
<li>GET —— 获取资源信息(SELECT)</li>
<li>POST —— 创建新的资源(CREATE)</li>
<li>PUT —— 更新资源(UPDATE)</li>
<li>PATCH —— 更新部分资源(UPDATE)</li>
<li>DELETE —— 删除部分资源(DELETE)</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /tickets - 检索票证列表</span><br><span class="line">GET /tickets/12 - 检索特定票证</span><br><span class="line">POST /tickets - 创建一个新票</span><br><span class="line">PUT /tickets/12 - 更新票 #12</span><br><span class="line">PATCH /tickets/12 - 部分更新票 #12</span><br><span class="line">DELETE /tickets/12 - 删除票 #12</span><br></pre></td></tr></table></figure>

<p>不适合 CRUD 操作的世界应该怎么办？</p>
<ul>
<li><strong>组合操作使其看起来像资源的字段。</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /template/apply # 应用一个模版</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>将其视为符合 RESTful 原则的子资源。</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /zoos/id/animals # 获取某一个 动物园的 动物</span><br></pre></td></tr></table></figure>

<ul>
<li>无法确定正确的 RESTful 结构的，区别记录即可，无需强制使用。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /search?text=&quot;搜索&quot;</span><br></pre></td></tr></table></figure>

<h2 id="无处不在的-SSL"><a href="#无处不在的-SSL" class="headerlink" title="无处不在的 SSL"></a>无处不在的 SSL</h2><blockquote>
<p>SSL 证书是一个数字证书，用于认证网站的身份并启用加密连接。SSL 代表安全套接字层，这是一个安全协议，可在 Web 服务器和 Web 浏览器之间创建加密链接。</p>
</blockquote>
<p><strong>始终使用 SSL —— 出于安全考虑。</strong></p>
<p>始终使用 SSL 的另外一个优势是有保证的加密通信简化了身份验证工作——您可以使用简单的访问令牌，而不必签署每个 API 请求。</p>
<h2 id="API-接口文档"><a href="#API-接口文档" class="headerlink" title="API 接口文档"></a>API 接口文档</h2><p><strong>API 的好坏取决于它的文档</strong>。这些文档应该很容易找到并且可以公开访问。大多数开发人员在尝试任何集成工作之前都会查看文档。</p>
<p><strong>文档应显示完整请求/响应周期的示例。</strong></p>
<p>一旦你发布了一个公共 API，就应该发布通知信息，告知关注者变更消息。</p>
<p>例如 Apifox、yapi 等接口文档软件</p>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p><strong>始终对您的 API 进行版本控制。</strong>版本控制可帮助您更快地迭代并防止无效请求到达更新的端点。它还有助于平滑任何主要的 API 版本转换。</p>
<p>关于 API 版本应包含在 URL 中还是 header 中？有广泛的争论。</p>
<p>本人比较喜欢将版本控制置于 URL 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /api/v1/zoos</span><br></pre></td></tr></table></figure>



<h2 id="结果过滤、排序和搜索"><a href="#结果过滤、排序和搜索" class="headerlink" title="结果过滤、排序和搜索"></a>结果过滤、排序和搜索</h2><p><strong>最好使基本资源 URL 尽可能精简。</strong></p>
<p><strong>复杂的结果过滤器、排序要求和高级搜索（当仅限于单一类型的资源时）都可以作为基本 URL</strong>  </p>
<p><strong>之上的查询参数轻松实现。</strong></p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /tickets?state=open</span><br><span class="line">GET /tickets?order_by=create_time:desc,apply_time:desc</span><br></pre></td></tr></table></figure>

<h2 id="JSON-采用-request-body-输入"><a href="#JSON-采用-request-body-输入" class="headerlink" title="JSON  采用 request body 输入"></a>JSON  采用 request body 输入</h2><ul>
<li>POST</li>
<li>PUT</li>
<li>PATCH</li>
</ul>
<p>上述方法采用 request body 传输数据</p>
<h3 id="字段名称的-snake-case-与-camelCase"><a href="#字段名称的-snake-case-与-camelCase" class="headerlink" title="字段名称的 snake_case 与 camelCase"></a>字段名称的 snake_case 与 camelCase</h3><p>根据 2010 年对 camelCase 和 snake_case （PDF）的眼动追踪研究，**snake_case 比 camelCase 更容易阅读 20%**这种对可读性的影响会影响 API 的可探索性和文档中的示例。</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>json 返回数据中，会包含一些分页数据；</p>
<blockquote>
<p>The right way to include pagination details today is using the <a href="https://tools.ietf.org/html/rfc8288">Link header introduced by RFC 8288</a>.</p>
</blockquote>
<p>以下是正确使用 Link 标头的示例，来自 GitHub:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Link: &lt;https://api.github.com/user/repos?page=3&amp;per_page=100&gt;; rel=&quot;next&quot;, &lt;https://api.github.com/user/repos?page=50&amp;per_page=100&gt;; rel=&quot;last&quot;</span><br></pre></td></tr></table></figure>

<p>许多 API 确实需要额外的分页信息，例如可用结果总数的计数。需要发送计数的 API 可以使用自定义 HTTP 标头，如 <code>X-Total-Count</code>。</p>
<h2 id="更新和限制资源应该返回资源表示"><a href="#更新和限制资源应该返回资源表示" class="headerlink" title="更新和限制资源应该返回资源表示"></a>更新和限制资源应该返回资源表示</h2><p>PUT、POST 或 PATCH 调用可能会修改不属于所提供参数的基础资源字段（例如：created_at 或 updated_at 时间戳）。为防止 API 使用者必须再次点击 API 以获得更新的表示，让 API 返回更新（或创建）的表示作为响应的一部分。</p>
<p>如果 POST 导致创建，请使用 HTTP 201 状态码并包含指向新资源 URL 的 Location 标头。</p>
<p>除了将新创建的资源表示作为响应主体之外，还应该包含这两个内容。</p>
<h2 id="默认情况下，不使用-envelope-特殊情况下使用"><a href="#默认情况下，不使用-envelope-特殊情况下使用" class="headerlink" title="默认情况下，不使用 envelope, 特殊情况下使用"></a>默认情况下，不使用 envelope, 特殊情况下使用</h2><p>许多情况下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>：&#123;</span><br><span class="line">  	<span class="attr">&quot;id&quot;</span>: <span class="number">123</span>,</span><br><span class="line">  	<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>包含额外的元数据或分页信息，一些 REST 客户端不允许轻松访问 HTTP 标头，而 JSONP 请求无法访问 HTTP 标头。然而，随着 CORS 和 RFC 5988 等 Link 标头等标准被迅速采用，封装开始变得不必要了。</li>
</ul>
<h2 id="速率限制"><a href="#速率限制" class="headerlink" title="速率限制"></a>速率限制</h2><p>为防止滥用，标准做法是向 API 添加某种速率限制。</p>
<blockquote>
<p>To prevent abuse, it is standard practice to add some sort of rate limiting to an API. <a href="http://tools.ietf.org/html/rfc6585">RFC 6585</a> introduced a HTTP status code <a href="http://tools.ietf.org/html/rfc6585#section-4">429 Too Many Requests</a> to accommodate this.</p>
<p>However, it can be very useful to notify the consumer of their limits before they actually hit it. This is an area that currently lacks standards but has a number of <a href="http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers">popular conventions using HTTP response headers</a>.</p>
<p>At a minimum, include the following headers:</p>
<ul>
<li>X-Rate-Limit-Limit - The number of allowed requests in the current period</li>
<li>X-Rate-Limit-Remaining - The number of remaining requests in the current period</li>
<li>X-Rate-Limit-Reset - The number of seconds left in the current period</li>
</ul>
</blockquote>
<h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>RESTful API 应该是无状态的。</p>
<p>基于 SSL 身份验证凭据可以简化为随机生成的访问令牌，该令牌在 HTTP 基本身份验证的用户名字段中传送。</p>
<ul>
<li>session</li>
<li>jwt</li>
<li>access_token</li>
<li>OAuth 2</li>
</ul>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>HTTP 内置缓存框架</p>
<ul>
<li>ETag</li>
<li>Last-Modified</li>
</ul>
<h2 id="Error-Handler"><a href="#Error-Handler" class="headerlink" title="Error Handler"></a>Error Handler</h2><p>类似 HTML 错误页面向访问者显示有用的错误信息一样，API 应该以已知的可使用格式提供有用的错误信息。错误的表示应该与任何资源的表示没有区别，只是具有自己的一组字段。</p>
<ul>
<li>API 应返回合理的 HTTP 状态代码。</li>
</ul>
<p>API 错误通常分为两种类型：</p>
<ul>
<li>客户端问题的 400 系列状态代码</li>
<li>服务器问题的 500 系列状态代码</li>
</ul>
<p>对于具体的 400 系列和 500 系列状态代码，应带有可使用的 JSON 错误表示。</p>
<p>JSON 错误正文应具有：</p>
<ul>
<li>错误信息</li>
<li>唯一的错误代码</li>
<li>以及可能的详细描述</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;code&quot;</span> : <span class="number">1234</span>,</span><br><span class="line">  <span class="attr">&quot;message&quot;</span> : <span class="string">&quot;Something bad happened :(&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span> : <span class="string">&quot;More details about the error here&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="HTTP-status-codes"><a href="#HTTP-status-codes" class="headerlink" title="HTTP status codes"></a>HTTP status codes</h2><blockquote>
<ul>
<li>200 OK - Response to a successful GET, PUT, PATCH or DELETE. Can also be used for a POST that doesn’t result in a creation.</li>
<li>201 Created - Response to a POST that results in a creation. Should be combined with a <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.30">Location header</a> pointing to the location of the new resource</li>
<li>204 No Content - Response to a successful request that won’t be returning a body (like a DELETE request)</li>
<li>304 Not Modified - Used when HTTP caching headers are in play</li>
<li>400 Bad Request - The request is malformed, such as if the body does not parse</li>
<li>401 Unauthorized - When no or invalid authentication details are provided. Also useful to trigger an auth popup if the API is used from a browser</li>
<li>403 Forbidden - When authentication succeeded but authenticated user doesn’t have access to the resource</li>
<li>404 Not Found - When a non-existent resource is requested</li>
<li>405 Method Not Allowed - When an HTTP method is being requested that isn’t allowed for the authenticated user</li>
<li>410 Gone - Indicates that the resource at this end point is no longer available. Useful as a blanket response for old API versions</li>
<li>415 Unsupported Media Type - If incorrect content type was provided as part of the request</li>
<li>422 Unprocessable Entity - Used for validation errors</li>
<li>429 Too Many Requests - When a request is rejected due to rate limiting</li>
</ul>
</blockquote>
<ul>
<li>200 OK - 对成功的 GET、PUT、PATCH 或 DELETE 的响应。也可用于不会导致创建的 POST。</li>
<li>201 已创建- 对导致创建的 POST 的响应。应与指向新资源位置的<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.30">Location 标头结合</a></li>
<li>204 No Content - 对不会返回正文的成功请求的响应（如 DELETE 请求）</li>
<li>304 Not Modified - 在使用 HTTP 缓存标头时使用</li>
<li>400 Bad Request - 请求格式错误，比如请求体没有解析</li>
<li>401 Unauthorized - 当没有提供或提供无效的身份验证详细信息时。如果从浏览器使用 API，也可用于触发身份验证弹出窗口</li>
<li>403 Forbidden - 当身份验证成功但经过身份验证的用户无权访问资源时</li>
<li>404 Not Found - 当请求不存在的资源时</li>
<li>405 Method Not Allowed - 当请求的 HTTP 方法不允许经过身份验证的用户使用时</li>
<li>410 Gone - 表示此端点的资源不再可用。作为对旧 API 版本的全面响应很有用</li>
<li>415 Unsupported Media Type - 如果作为请求的一部分提供了不正确的内容类型</li>
<li>422 Unprocessable Entity - 用于验证错误</li>
<li>429 Too Many Requests - 当请求由于速率限制而被拒绝时</li>
</ul>
<h2 id="In-Summary"><a href="#In-Summary" class="headerlink" title="In Summary"></a>In Summary</h2><p>API 是开发人员的用户界面。努力确保它不仅功能齐全而且使用起来愉快。</p>
<p>由于开发语言有异，只有最适合的 API 规范，没有最好的 API 规范</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Best Practices for Designing a Pragmatic RESTful API:<a href="https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api</a></p>
<p>Idel restful api : <a href="https://betimdrenica.wordpress.com/2015/03/09/ideal-rest-api-design/">https://betimdrenica.wordpress.com/2015/03/09/ideal-rest-api-design/</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2014/05/restful_api.html">https://www.ruanyifeng.com/blog/2014/05/restful_api.html</a></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 内存管理，垃圾回收，缓存重用机制</title>
    <url>/posts/ec5b3295/</url>
    <content><![CDATA[<h1 id="一文搞定Python-的-内存管理-垃圾回收-缓存重用机制"><a href="#一文搞定Python-的-内存管理-垃圾回收-缓存重用机制" class="headerlink" title="一文搞定Python 的 内存管理, 垃圾回收, 缓存重用机制"></a>一文搞定Python 的 <code>内存管理</code>, <code>垃圾回收</code>, <code>缓存重用机制</code></h1><blockquote>
<p>鉴于 Python 的语言特性，详细的梳理记录下这三方面的知识</p>
</blockquote>
<span id="more"></span>
<h2 id="详谈-python-的内存管理"><a href="#详谈-python-的内存管理" class="headerlink" title="详谈 python 的内存管理"></a>详谈 python 的内存管理</h2><blockquote>
<p>python 作为一门高级语言，调用相关变量时，无需实现声明，变量无需指定类型，python 解释器会自动帮你回收，这一切都由<br><code>python 内存管理器</code>承担了复杂的内存管理工作。<br>这里主要介绍基于 Cpython 实现的内存管理</p>
</blockquote>
<blockquote>
<p>python 内存管理机制 —— Pymalloc</p>
</blockquote>
<h3 id="主要实现方式"><a href="#主要实现方式" class="headerlink" title="主要实现方式"></a>主要实现方式</h3><ul>
<li>针对<code>小对象</code>, 就是对象大小小于<code>256kb</code>时，pymalloc 会在<code>内存池中申请内存空间</code></li>
<li>针对<code>大对象</code>, 对象大小<code>大于 256kb</code>时，会执行<code>new/malloc 行为</code>来申请新的内存空间</li>
</ul>
<h3 id="python-内存池（memory-pool）"><a href="#python-内存池（memory-pool）" class="headerlink" title="python 内存池（memory pool）"></a>python 内存池（memory pool）</h3><blockquote>
<p>为什么要引入内存池？<br>当创建大量消耗小内存的对象时，频繁调用<code>new/malloc</code>会导致大量的内存碎片，导致效率降低</p>
</blockquote>
<ul>
<li><code>内存池的作用就是预先在内存中申请一定数量的，大小相等的内存块（256kb）留作备用</code>，当有新的内存需求时，就优先从内存池中分配给这个需求。</li>
<li>减少内存碎片化，提升效率</li>
</ul>
<img src="/images/python 内存池.png" width = "600" height = "700" alt="" align=center />

<ul>
<li><p>python 的对象管理主要位于 Level + 1 ~ Level +3 层</p>
</li>
<li><p>Level 3: 该层特定对象内存分配器，主要是 <code>python 内置的对象（int, dict, arr）</code>都有独立的私有内存池，对象<br>之间的内存池不共享，例如 <code>int</code> 释放的内存，不会被分配给 <code>float</code>使用。</p>
</li>
<li><p>Level 2: python 对象分配器：当申请的<code>内存大小小于256KB</code>时，内存对象的分配主要由<code>Python 对象</code> 分配器（python’s object allocator）实施</p>
</li>
<li><p>Level 1: python 内存分配器：当申请的<code>内存大小大于256KB</code>时，由 Python 原生的内存分配器进行分配，本质上是调用 C 标准库中的 malloc/readlloc 等函数</p>
</li>
</ul>
<h3 id="内存池的内存释放"><a href="#内存池的内存释放" class="headerlink" title="内存池的内存释放"></a>内存池的内存释放</h3><blockquote>
<p>内存释放，当一个对象的引用计算变为 0 时，Python 就会调用它的析构函数（__del__）。调用析构函数并不意味着最终一定会调用<br>free 来释放内存空间，会导致频繁申请、释放内存空间使得 Python 的执行效率大打折扣。因此在析构时也采用了内存池机制，内存池申请到的内存会被归还到内存池中，<br>以免频繁地申请和释放动作</p>
</blockquote>
<p>接下来就会讲到 Python 的垃圾回收机制。</p>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><blockquote>
<p>如果别人问你，什么是 Python 的垃圾回收机制，你可以用一句话概括<br><strong>Python 的垃圾回收机制采用`引用计数为主，标记-清除和分代回收为辅的策略</strong></p>
</blockquote>
<p>Python 一切皆为对象，包括 int、str 等等基本的对象。Cpython 的实现中，有一个结构体为 PyObject, Cpython 中的每个其他对象都在使用它</p>
<p>PyObject 是 Python 中所有对象的祖父，它只包含两件事：</p>
<ul>
<li>ob_refcnt: 引用计数器</li>
<li>ob_type: 指向另一种类型的指针</li>
</ul>
<p>对于对象来说，无非是对象的创建和删除</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><blockquote>
<p>每个对象都会维护一个 <code>ob_refcnt</code> 来记录当前对象被引用的次数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">a = [<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(a))</span><br><span class="line"><span class="comment"># OUTPUT getrefcount 会增加一次引用</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>对象引用计数 +1</p>
<ul>
<li><ol>
<li>对象被创建 <code>a=1</code></li>
</ol>
</li>
<li><ol start="2">
<li>对象被引用 <code>a=b</code></li>
</ol>
</li>
<li><ol start="3">
<li>对象被作为参数，传入函数中 def count(a, b)</li>
</ol>
</li>
<li><ol start="4">
<li>对象作为一个元素被存储 <code>li = [1,2, a]</code></li>
</ol>
</li>
</ul>
</li>
<li><p>对象的引用计数 -1</p>
<ul>
<li><ol>
<li>对象的引用被显示销毁时，<code>del a</code></li>
</ol>
</li>
<li><ol start="2">
<li>对象的引用别名被赋予新的对象, <code>a=26</code></li>
</ol>
</li>
<li><ol start="3">
<li>一个对象离开它的作用域, 例如一个函数执行完成后，内部的<code>局部变量的引用计数器就会减一</code>(全局变量不变)</li>
</ol>
</li>
<li><ol start="4">
<li>将该元素从容器中删除时，或者容器被销毁</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>当指向对象的内存的引用计数为 0 时，该内存就会被 Python 虚拟机销毁</strong></p>
<p>特性：</p>
<blockquote>
<p>优点：1. 高效。2。 实时性，一旦没有引用，内存就直接释放了。3. 对象有确定的生命周期 4. 易于实现<br>缺点：1. 维护引用计数消耗资源。2. 无法解决循环引用问题</p>
</blockquote>
<h2 id="为什么要使用标记清除"><a href="#为什么要使用标记清除" class="headerlink" title="为什么要使用标记清除"></a>为什么要使用标记清除</h2><blockquote>
<p>对于一个对象来说，当出现循环引用的时候，例如<code>a=1, b=a, a=b</code>的时候，就出现了循环引用的情况，这样该对象的引用计数<br>的值都会是 1 而不是 0，那么垃圾回收的机制就会失效，针对这种情况，又出现了标记清除的功能来解决循环引用的问题。</p>
</blockquote>
<h3 id="什么是标记清除？"><a href="#什么是标记清除？" class="headerlink" title="什么是标记清除？"></a>什么是标记清除？</h3><blockquote>
<p>[标记清除（Mark-Sweep）] 算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。主要针对一些容器对象，例如<code>list</code>、<code>dict</code>、<code>tuple</code><br>对于字符串和数值对象是不可能造成循环引用的问题的（不可变对象，当出现引用时，会另外开辟空间存储，这个在缓存机制中会详细解释）。</p>
</blockquote>
<p>那么<code>标记清除</code>算法是如何运行的？<br>分为两个阶段：</p>
<ul>
<li><ol>
<li>第一阶段是标记阶段，GC 会把所有的[活动对象]打上标记。</li>
</ol>
</li>
<li><ol start="2">
<li>第二阶段是把那些没有标记的[非活动对象]进行回收。</li>
</ol>
</li>
</ul>
<p>活动对象和非活动对象的标记：<br>对象之间通过引用（指针）连在一起，构成一个有相图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。<br>从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。<br>根对象就是全局变量、调用栈、寄存器。</p>
<img src="/images/有向图.png" width = "400" height = "200" alt="" align=center />

<p>从以上的有向图中：</p>
<ul>
<li>活动对象：A, B, C</li>
<li>非活动对象：D, E</li>
</ul>
<h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><blockquote>
<p>在标记清除对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过<strong>分代回收（Generational Conlletion）</strong>以空间换时间的方法提高垃圾回收效率</p>
</blockquote>
<p>Python 将所有对象分为：</p>
<ul>
<li>年轻代（第 0 代）</li>
<li>中年代（第 1 代）</li>
<li>老年代（第 2 代）</li>
</ul>
<p>所有新建的对象默认是第 0 代对象，经过 GC 扫描存活下来的对象将被移至第一代，在第一代的 GC 扫描中存活下来的对象将被移至第二代。</p>
<blockquote>
<p>GC 扫描次数 (第 0 代 &gt; 第 1 代 &gt; 第 2 代)</p>
</blockquote>
<h3 id="GC-分代回收是如何触发的？"><a href="#GC-分代回收是如何触发的？" class="headerlink" title="GC 分代回收是如何触发的？"></a>GC 分代回收是如何触发的？</h3><blockquote>
<p>当某个世代中被分配的对象与被释放的对象数量之差到达某一个阈值时，就会触发当前一代的 GC 扫描。<br>当某一世代被扫描时，比它年轻的一代也会被扫描<br>当第 2 代的 GC 扫描发生时，第 0，1 代的 GC 扫描也会发生，即为全代扫描。</p>
</blockquote>
<p>那么这个阈值是如何确定的?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc </span><br><span class="line">gc.get_threshold() <span class="comment">## 分代回收机制的参数阈值设置</span></span><br><span class="line"><span class="comment"># (700, 10, 10)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>700=新分配的对象数量-释放的对象数量，第 0 代 gc 扫描被触发</li>
<li>第一个10：第 0 代 gc 扫描发生 10 次，则第 1 代的 gc 扫描被触发</li>
<li>第二个10：第 1 代的 gc 扫描发生 10 次，则第 2 代的 gc 扫描被触发</li>
</ul>
<h1 id="Python-的缓存重用机制"><a href="#Python-的缓存重用机制" class="headerlink" title="Python 的缓存重用机制"></a>Python 的缓存重用机制</h1><blockquote>
<p>Python 缓存重用机制是为了提高程序执行的效率。Python 解释器启动时从内存空间中开辟出一小部分，用来存储高频使用的数据，这样可以大大减少高频使用的<br>数据创建时申请内存和销毁的开销</p>
</blockquote>
<img src="/images/缓存重用机制.png" width = "600" height = "300" alt="" align=center />

<p>这里基本演示，更加详细的演示，读者可以自行尝试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#范围在 [-5, 256] 之间的小整数</span></span><br><span class="line">int1 = -<span class="number">5</span></span><br><span class="line">int2 = -<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[-5, 256] 情况下的两个变量：&quot;</span>, <span class="built_in">id</span>(int1), <span class="built_in">id</span>(int2))</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#bool类型</span></span><br><span class="line">bool1 = <span class="literal">True</span></span><br><span class="line">bool2 = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bool类型情况下的两个变量：&quot;</span>,<span class="built_in">id</span>(bool1),<span class="built_in">id</span>(bool2))</span><br><span class="line"><span class="comment">#对于字符串</span></span><br><span class="line">s1 = <span class="string">&quot;3344&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;3344&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串情况下的两个交量&quot;</span>, <span class="built_in">id</span>(s1), <span class="built_in">id</span>(s2))</span><br><span class="line"><span class="comment">#大于 256 的整数</span></span><br><span class="line">int3 = <span class="number">257</span></span><br><span class="line">int4 = <span class="number">257</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;大于 256 的整数情况下的两个变量&quot;</span>, <span class="built_in">id</span>(int3), <span class="built_in">id</span>(int4))</span><br><span class="line"><span class="comment">#大于 0 的浮点数</span></span><br><span class="line">f1 = <span class="number">256.4</span></span><br><span class="line">f2 = <span class="number">256.4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;大于 0 的浮点数情况下的两个变量&quot;</span>, <span class="built_in">id</span>(f1), <span class="built_in">id</span>(f2))</span><br><span class="line"><span class="comment">#小于 0 的浮点数</span></span><br><span class="line">f3 = -<span class="number">2.45</span></span><br><span class="line">f4 = -<span class="number">2.45</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;小于 0 的浮点数情况下的两个变量&quot;</span>, <span class="built_in">id</span>(f3), <span class="built_in">id</span>(f4))</span><br><span class="line"><span class="comment">#小于 -5 的整数</span></span><br><span class="line">n1 = -<span class="number">6</span></span><br><span class="line">n2 = -<span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;小于 -5 的整数情况下的两个变量&quot;</span>, <span class="built_in">id</span>(n1), <span class="built_in">id</span>(n2))</span><br></pre></td></tr></table></figure>
<p>OUTPUT:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[-5, 256] 情况下的两个变量： 4479762592 4479762592</span><br><span class="line">bool类型情况下的两个变量： 4479360112 4479360112</span><br><span class="line">字符串情况下的两个交量 140680232254768 140680232254768</span><br><span class="line">大于 256 的整数情况下的两个变量 140680231657872 140680231657872</span><br><span class="line">大于 0 的浮点数情况下的两个变量 140680231658256 140680231658256</span><br><span class="line">小于 0 的浮点数情况下的两个变量 140680191914768 140680191914768</span><br><span class="line">小于 -5 的整数情况下的两个变量 140680232617328 140680232617328</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>对于<code>int</code>, <code>str</code>,<code>bool</code> 类型而言：<ol>
<li>对于同一个对象，都是缓存同一个内容来使用</li>
</ol>
</li>
<li>对于<code>大于 256 的整数</code>, 浮点数<ol>
<li>如果位于同一代码块，则使用相同的缓存内容；反之，则不使用</li>
</ol>
</li>
<li>对于 <code>小于 0 的整数</code><ol>
<li>Python 没有对其进行缓存操作</li>
</ol>
</li>
</ul>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在 Python 中，主要通过 <code>引用计数</code>来进行垃圾回收；通过<code>标记-清除</code>来解决一些容器对象的循环引用问题；<br>通过<code>分代回收</code>以空间换时间的方式提高垃圾回收效率。</p>
<p>缓存重用机制，作用类似于内存池，提高 Python 的执行效率</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>「 python 垃圾回收机制 」- <a href="https://andrewpqc.github.io/2018/10/08/python-memory-management/">https://andrewpqc.github.io/2018/10/08/python-memory-management/</a><br>「 python GC 源代码 」- <a href="https://docs.python.org/2/library/gc.html">https://docs.python.org/2/library/gc.html</a><br>「 python 垃圾回收需要知道事 」- <a href="https://rushter.com/blog/python-garbage-collector/">https://rushter.com/blog/python-garbage-collector/</a> </p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法——冒泡、插入、选择排序</title>
    <url>/posts/7b385955/</url>
    <content><![CDATA[<h1 id="常用的排序算法"><a href="#常用的排序算法" class="headerlink" title="常用的排序算法"></a>常用的排序算法</h1><p>参考：<a href="https://blog.csdn.net/weixin_42702038/article/details/106744386">https://blog.csdn.net/weixin_42702038/article/details/106744386</a></p>
<p><img src="../../images/algorithm/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt="direct"></p>
<p><strong>问题带入：在实际的软件开发中，为什么我们更倾向于使用插入排序而不是冒泡排序算法？</strong></p>
<h1 id="排序算法分析"><a href="#排序算法分析" class="headerlink" title="排序算法分析"></a>排序算法分析</h1><ul>
<li>最好情况、最坏情况、平均情况时间复杂度</li>
<li>时间复杂度的系数、常数、低阶<br>时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系统、常数、低阶。</li>
<li>比较次数和交换（或移动）次数</li>
<li>排序算法的内存消耗<br>冒泡、选择、插入 排序算法都是<strong>原地排序算法</strong></li>
<li>排序算法的稳定性<br>若待排序的序列中存在值相等的元素，经过排序之后相等元素之间原有的先后顺序不变，就是稳定的排序算法</li>
</ul>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><img src="../../images/algorithm/bubble_sort_flow.png" alt="direct"></p>
<ul>
<li>空间复杂度为 O(1), 是一个<strong>原地排序算法</strong></li>
<li>相邻的两个元素相等时，不会交换顺序，是<strong>稳定的排序算法</strong></li>
<li>最好时间复杂度为 O(n),最坏时间复杂度为 O(n^2)<br><img src="../../images/algorithm/bubble_sort_%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="direct"></li>
</ul>
<h2 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> li:</span><br><span class="line">        <span class="keyword">return</span> li</span><br><span class="line">    length = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    li = [<span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">10</span>]</span><br><span class="line">    <span class="built_in">print</span>(bubble_sort(li))</span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序思想：插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序序列，在已排序的序列中从后向前扫描，找当相应的位置并插入。</p>
<p><img src="../../images/algorithm/insert_sort_flow.png" alt="direct"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">arr: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        key = arr[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> key &lt; arr[j]:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        arr[j + <span class="number">1</span>] = key</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序类似于插入排序，区分已排序区间和未排序区间。但是选择排序每次都会从未排序区间找到最小的元素，将其放到队首</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">arr: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">                arr[i], arr[min_index] = arr[min_index], arr[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="../../images/algorithm/%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83.png" alt="direct"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是队列&amp;&amp;队列的使用场景</title>
    <url>/posts/d18c7429/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>对于一台机器来说，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能的下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置。<br>当我们向一个固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池会如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么事先的呢？</p>
</blockquote>
<h1 id="什么是队列？"><a href="#什么是队列？" class="headerlink" title="什么是队列？"></a>什么是队列？</h1><blockquote>
<p><code>队列</code>这个概念非常好理解。当你在食堂排队买饭时，先来的先买，后来的排队等待。<strong>先进先出</strong>，这就是<strong>队列</strong>。</p>
</blockquote>
<p>与栈一样，队列最基本的操作也是两个：<code>入队 enqueue()</code>和<code>出队 dequeue</code></p>
<p>队列和栈一样，也是一种<strong>操作受限的线性表数据结构</strong>。</p>
<p>队列作为一种非常基础的数据结构，队列的应用也非常广泛：</p>
<ul>
<li>循环队列</li>
<li>阻塞队列</li>
<li>并发队列</li>
</ul>
<h1 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h1><h2 id="数组实现顺序队列"><a href="#数组实现顺序队列" class="headerlink" title="数组实现顺序队列"></a>数组实现顺序队列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.queue = []</span><br><span class="line">        self.capacity = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.size() &gt; self.capacity:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;queue is full&quot;</span>)</span><br><span class="line">        self.queue.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.size() &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = Queue(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">        queue.enqueue(i)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(queue.first(), queue.end())</span><br><span class="line">    queue.enqueue(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h2><p><img src="../../images/algorithm/%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97.png" alt="direct"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pointer</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pointer = Pointer()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = ListNode(data)</span><br><span class="line">        _p = self.pointer</span><br><span class="line">        <span class="keyword">if</span> _p.head:</span><br><span class="line">            <span class="comment"># 队列中有元素</span></span><br><span class="line">            tmp = _p.tail</span><br><span class="line">            _p.tail = node</span><br><span class="line">            tmp.<span class="built_in">next</span> = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 队列中没有元素, 插入第一个元素</span></span><br><span class="line">            _p.head, _p.tail = node, node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        _p = self.pointer</span><br><span class="line">        <span class="keyword">if</span> _p.head <span class="keyword">and</span> (_p.head == _p.tail):</span><br><span class="line">            <span class="comment"># 队列中有一个元素</span></span><br><span class="line">            tmp = _p.head</span><br><span class="line">            _p.head = _p.tail = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> tmp.data</span><br><span class="line">        <span class="keyword">elif</span> _p.head <span class="keyword">and</span> (_p.head != _p.tail):</span><br><span class="line">            <span class="comment"># 队列中不止一个元素</span></span><br><span class="line">            tmp = _p.head</span><br><span class="line">            _p.head = tmp.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> tmp.data</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 队列中没有元素</span></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;queue is empty&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.pointer.head == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.pointer.head:</span><br><span class="line">            <span class="keyword">return</span> self.pointer.head.data</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">&quot;queue is empty&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        _p = self.pointer</span><br><span class="line">        tmp = _p.head</span><br><span class="line">        <span class="keyword">while</span> tmp != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;--&gt;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(tmp.data), sep=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            tmp = tmp.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    q.enqueue(<span class="number">1</span>)</span><br><span class="line">    q.enqueue(<span class="number">2</span>)</span><br><span class="line">    q.enqueue(<span class="number">3</span>)</span><br><span class="line">    q.enqueue(<span class="number">4</span>)</span><br><span class="line">    q.enqueue(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    q.travel()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---------&quot;</span>)</span><br><span class="line">    q.dequeue()</span><br><span class="line">    q.dequeue()</span><br><span class="line">    q.dequeue()</span><br><span class="line"></span><br><span class="line">    q.travel()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(q.top())</span><br></pre></td></tr></table></figure>
<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><p><img src="../../images/algorithm/img_2.png" alt="direct"></p>
<p>循环队列，顾名思义，它像一个环，在实现过程中，最关键的是<strong>确定好队空和队满的判定条件</strong></p>
<p><img src="../../images/algorithm/img_2.png" alt="direct"></p>
<p>总结如下：</p>
<ul>
<li><strong>队列为空的判断条件：</strong></li>
</ul>
<p><strong>head == tail</strong></p>
<ul>
<li><p><strong>队列为满的情况</strong><br><code>(tail + 1) % cap == head</code></p>
</li>
<li><p><strong>队列长度的计算公式：</strong><br><code>(tail - head + cap)%cap == length</code></p>
</li>
<li><p><strong>尾指针计算</strong><br><code>tail = (tail + 1) % cap</code></p>
</li>
<li><p><strong>头指针计算</strong><br><code>head = (head + 1) % cap</code></p>
</li>
<li><p><strong>队列为满时，图中的 tail 指向的位置实际上没有存储数据。</strong></p>
</li>
</ul>
<h2 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self._queue = [<span class="literal">None</span>] * (k+<span class="number">1</span>)</span><br><span class="line">        self.cap = k+<span class="number">1</span></span><br><span class="line">        self.front = <span class="number">0</span></span><br><span class="line">        self.rear = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enQueue</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self._queue[self.rear] = value</span><br><span class="line">        self.rear = (self.rear + <span class="number">1</span>) % self.cap</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deQueue</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        data = self._queue[self.front]</span><br><span class="line">        self._queue[self.front] = <span class="literal">None</span></span><br><span class="line">        self.front = (self.front + <span class="number">1</span>) % self.cap</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Front</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        data = self._queue[self.front]</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Rear</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        data = self._queue[self.rear - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.front == self.rear</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.front == (self.rear + <span class="number">1</span>) % self.cap</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>阻塞队列实则就是在队列的基础上增加了阻塞操作。</p>
<ul>
<li>队列为空的时候，从队头取数据就会被阻塞</li>
<li>队列满的时候，插入数据就会被阻塞</li>
</ul>
<p><img src="../../images/algorithm/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="img_2.png"></p>
<h2 id="python-阻塞队列实现的生产者-消费者模型"><a href="#python-阻塞队列实现的生产者-消费者模型" class="headerlink" title="python 阻塞队列实现的生产者-消费者模型"></a>python 阻塞队列实现的生产者-消费者模型</h2><p>在 python 中，queue 模块中实现了一个线程安全的队列，<strong>并发队列</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">q = queue.Queue(<span class="number">5</span>)  <span class="comment"># 生成一个队列，用来保存“包子”，最大数量为10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productor</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="comment"># 厨师不停地每2秒做一个包子</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        q.put(<span class="string">&quot;厨师 %s 做的包子！&quot;</span> % i)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">j</span>):</span></span><br><span class="line">    <span class="comment"># 顾客不停地每秒吃一个包子</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;顾客 %s 吃了一个 %s&quot;</span> % (j, q.get()))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例化了3个生产者（厨师）</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        t = threading.Thread(target=productor, args=(i,))</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="comment"># 实例化了10个消费者（顾客）</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        v = threading.Thread(target=consumer, args=(j,))</span><br><span class="line">        v.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="线程池没有空闲线程时，新任务请求线程资源时，线程池该如何处理？"><a href="#线程池没有空闲线程时，新任务请求线程资源时，线程池该如何处理？" class="headerlink" title="线程池没有空闲线程时，新任务请求线程资源时，线程池该如何处理？"></a>线程池没有空闲线程时，新任务请求线程资源时，线程池该如何处理？</h2><p>一般有两种处理策略：</p>
<ul>
<li>非阻塞的处理方式<br>直接拒绝任务请求</li>
<li>阻塞方式<br>将请求排队，等到有空闲线程时，取出排队的请求继续处理</li>
</ul>
<p><strong>实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过</strong>队列<strong>这种资源来实现请求排队。</strong></p>
<h2 id="队列总结"><a href="#队列总结" class="headerlink" title="队列总结"></a>队列总结</h2><p>队列的最大特点就是：<strong>先进先出</strong>，主要的两个操作是<strong>入队和出队</strong>。</p>
<ul>
<li>利用数组实现的叫顺序队列</li>
<li>利用链表实现叫链式队列</li>
</ul>
<h2 id="CAS-实现无锁队列"><a href="#CAS-实现无锁队列" class="headerlink" title="CAS 实现无锁队列"></a>CAS 实现无锁队列</h2><p>参考：<a href="https://coolshell.cn/articles/8239.html">https://coolshell.cn/articles/8239.html</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 索引总结 -</title>
    <url>/posts/6e16c56e/</url>
    <content><![CDATA[<h1 id="什么是-索引？"><a href="#什么是-索引？" class="headerlink" title="什么是 索引？"></a>什么是 <strong>索引</strong>？</h1><p><strong>索引（ MySQL 中也叫做<code>键(key)</code>）</strong> 是<strong>存储引擎</strong>用于<strong>快速找到记录</strong>的一种<strong>数据结构</strong>。本文主要学习的是基于 InnoDB 存储引擎。<br>索引对于良好的性能非常关键，对于较大的数据量来说，索引的创建愈发重要。</p>
<h1 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h1><blockquote>
<p>索引有很多种类型，可以为不同的场景提供更好的性能。</p>
</blockquote>
<h2 id="从存储结构上分"><a href="#从存储结构上分" class="headerlink" title="从存储结构上分"></a>从存储结构上分</h2><ul>
<li>Btree 索引 （B+tree、B-tree）</li>
<li>哈希索引</li>
<li>full-index 全文索引</li>
<li>RTree</li>
</ul>
<h2 id="从应用层次上划分"><a href="#从应用层次上划分" class="headerlink" title="从应用层次上划分"></a>从应用层次上划分</h2><ul>
<li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值</li>
<li>复合索引：一个索引包含多个列</li>
</ul>
<h2 id="从表记录的存储形式上来划分"><a href="#从表记录的存储形式上来划分" class="headerlink" title="从表记录的存储形式上来划分"></a>从表记录的存储形式上来划分</h2><ul>
<li>聚簇索引：表记录的排列顺序和索引的排列顺序一致</li>
<li>非聚簇索引：表记录的排列顺序和索引的排列顺序不一致</li>
</ul>
<h1 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h1><blockquote>
<p>在 InnoDB 中，表数据文件本身就是按照 B+Tree 组织的一个索引结构。<br>聚簇索引就是按照每张表的主键构造一颗 B+ 树，同时叶子节点中存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据页。<br>一般建表会用一个自增主键做聚簇索引，没有的话 MySQL 会默认创建<br>在日常的开发任务中，根据实际情况自行添加的索引都是辅助索引，辅助索引就是一个为了需要找主键索引的二级索引，先找到主键索引再通过主键索引找到数据。</p>
</blockquote>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><blockquote>
<p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。</p>
</blockquote>
<p>聚簇索引就是按照每张表的主键构建一颗 B+ 树，同时叶子节点存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据页。这个特性决定了索引组织表中的数据也是索引的一部分，每张表只能拥有一个聚簇索引。<br><img src="../../images/mysql/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="direct"></p>
<h2 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h2><ul>
<li>数据访问更快，因为**聚簇索引是将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快。</li>
<li>聚簇索引对于主键的排序查找和范围查找速度更快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</li>
</ul>
<h2 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h2><ul>
<li></li>
<li>插入速度严重依赖插入顺序，按照主键的顺序插入是最快的方式。一般定义一个自增的 ID 列作为主键，但是如果不是按照主键顺序加载数据，那么在jia</li>
<li>更新主键的代价很高，因为将会导致被更新的行移动，一般对于 InnoDB 表，定义主键不可更新</li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li>
</ul>
<h1 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h1><p>在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存放的不再是行的物理位置，而是主键值。<br>通过辅助索引找到主键值，再通过主键值找到数据行的数据页，再通过数据页中的 Page Directory 找到数据行。</p>
<p>InnoDB 辅助索引的叶子节点并不包含行记录的全部数据，叶子节点包含键值外，还包含了相应行数据的聚簇索引键。</p>
<h2 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B-Tree 索引"></a>B-Tree 索引</h2><blockquote>
<p>特点：<strong>每一个叶子节点都包含指向下一个叶子节点的指针</strong>，从而方便叶子节点的范围遍历</p>
</blockquote>
<p>B-Tree 通常意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。<br><img src="../../images/mysql/B+Tree%E7%B4%A2%E5%BC%95.png" alt="img.png"></p>
<h2 id="B-Tree-索引检索数据的原理"><a href="#B-Tree-索引检索数据的原理" class="headerlink" title="B-Tree 索引检索数据的原理"></a>B-Tree 索引检索数据的原理</h2><p>存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是<strong>从索引的根节点开始进行搜索</strong>。<br>根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。这些指针<strong>实际上定义了子节点页中值的上限和下限</strong>，通过比较<strong>节点页中的值和要查找的值</strong>可以找到合适的指针进入下层子节点。<br>最终存储引擎的查找只会有两种情况：<strong>1. 找到对应的值。2. 记录不存在。</strong></p>
<p><strong>叶子节点指针指向的是被索引的数据，而不是其他节点页。</strong></p>
<p>树的深度和表的大小直接相关</p>
<p>B-Tree 对索引列是顺序组织存储的，所以很适合查找范围数据。</p>
<p>B-Tree 索引适用于<strong>全值键、键值范围或键前缀</strong>查找。键前缀查找只适用于最左前缀查找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE People (</span><br><span class="line">    last_name varchar(50) not null DEFAULT &#x27;&#x27; comment &#x27;姓&#x27;,</span><br><span class="line">    first_name varchar(50) not null DEFAULT &#x27;&#x27; comment &#x27;名&#x27;,</span><br><span class="line">    dob date not null DEFAULT &#x27;&#x27; comment &#x27;出生日期&#x27;,</span><br><span class="line">    gender enum(0, 1) not null comment &#x27;&#x27;,</span><br><span class="line">    key(last_name, first_name, dob)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO People values (&#x27;Cuba&#x27;, &#x27;Allen&#x27;, &#x27;1960-01-01&#x27;),</span><br><span class="line">(&#x27;Angelina&#x27;, &#x27;Astaire&#x27;, &#x27;1980-03-04&#x27;),</span><br><span class="line">(&#x27;Julla&#x27;, &#x27;Barrymore&#x27;, &#x27;2000-05-16&#x27;),</span><br><span class="line">(&#x27;Christian&#x27;, &#x27;Akroyd&#x27;, &#x27;1958-12-07&#x27;),</span><br><span class="line">(&#x27;Akroyd&#x27;, &#x27;Klrsten&#x27;, &#x27;1978-11-02&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="../../images/mysql/BTree%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9.png" alt="direct"></p>
<h2 id="B-Tree-索引的查询类型"><a href="#B-Tree-索引的查询类型" class="headerlink" title="B-Tree 索引的查询类型"></a>B-Tree 索引的查询类型</h2><blockquote>
<p>explain 分析 SQL 的执行计划<br>需要重点关注 type、rows、filtered、extra。<br>type 由上至下，效率越来越高</p>
<ul>
<li>ALL 全表扫描</li>
<li>index 索引全扫描</li>
<li>range 索引范围扫描，常用语&lt;,&lt;=,&gt;,=&gt;,between, in like 等操作</li>
<li>ref 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中</li>
<li>eq_ref 类似 ref,区别在于使用的是唯一索引，使用主键的关联查询</li>
<li>const/system 单条记录，系统会把匹配行中的其它列作为常数处理，如主键或唯一索引查询</li>
<li>null MySQL 不访问任何表或索引，直接返回结果</li>
</ul>
</blockquote>
<blockquote>
<p>虽然上至下，效率越来越高，但是根据cost模型，假设有两个索引<code>idx1(a, b, c)</code>,<code>idx2(a, c)</code>，SQL为<code>select * from t where a = 1 and b in (1, 2) order by c;</code>如果走idx1，那么是type为range，如果走idx2，那么type是ref；当需要扫描的行数，使用idx2大约是idx1的5倍以上时，会用idx1，否则会用idx2</p>
</blockquote>
<blockquote>
<p><strong>Extra</strong></p>
</blockquote>
<blockquote>
<ul>
<li>Using filesort：MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行。</li>
<li><strong>Using temporary：使用了临时表保存中间结果，性能特别差，需要重点优化</strong></li>
<li>Using index：表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，意味着无法直接通过索引查找来查询到符合条件的数据。</li>
<li>Using index condition：MySQL5.6之后新增的ICP，using index condtion就是使用了ICP（索引下推），在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。</li>
</ul>
</blockquote>
<ul>
<li><strong>全值匹配</strong><pre><code>**全值匹配指的是和索引中所有列进行匹配**
</code></pre>
例如:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from People</span><br><span class="line">where last_name=&#x27;Cuba&#x27; and first_name=&#x27;Allen&#x27; and dob=&#x27;1960-01-01&#x27;\G;</span><br><span class="line">```  </span><br><span class="line">output:</span><br><span class="line">```markdown</span><br><span class="line">id            | 1</span><br><span class="line">select_type   | SIMPLE</span><br><span class="line">table         | People</span><br><span class="line">partitions    | &lt;null&gt;</span><br><span class="line">type          | ref</span><br><span class="line">possible_keys | last_name</span><br><span class="line">key           | last_name</span><br><span class="line">key_len       | 107</span><br><span class="line">ref           | const,const,const</span><br><span class="line">rows          | 1</span><br><span class="line">filtered      | 100.0</span><br><span class="line">Extra         | &lt;null&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这里的 type 为 ref, <strong>ref 表示使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录</strong>，常出现在关联查询中</p>
<ul>
<li><p><strong>匹配索引最左前缀</strong><br>  查找所有姓为 <code>Allen</code> 的人，例如 <code>explain select * from People where last_name=&#39;Cuba&#39;\G;</code><br>output:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | ref</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | last<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">key           | last_</span>name</span><br><span class="line">key<span class="emphasis">_len       | 52</span></span><br><span class="line"><span class="emphasis">ref           | const</span></span><br><span class="line"><span class="emphasis">rows          | 2</span></span><br><span class="line"><span class="emphasis">filtered      | 100.0</span></span><br><span class="line"><span class="emphasis">Extra         | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>匹配列前缀</strong><br>  查找只<strong>匹配某一列的值的开头部分</strong>，只使用到了索引的第一列。<br>例如 <code>explain select * from People where last_name like &#39;C%&#39;\G;</code></p>
</li>
</ul>
<p>output:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | range</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | last<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">key           | last_</span>name</span><br><span class="line">key<span class="emphasis">_len       | 52</span></span><br><span class="line"><span class="emphasis">ref           | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">rows          | 2</span></span><br><span class="line"><span class="emphasis">filtered      | 100.0</span></span><br><span class="line"><span class="emphasis">Extra         | Using index condition</span></span><br></pre></td></tr></table></figure>

<p>这里的 type 为 range, key 为 last_name, <strong>range 表示索引范围扫描，常用语&lt;,&lt;=,&gt;,=&gt;,between, in like 等操作</strong></p>
<ul>
<li><p>匹配范围值<br>  可用于查找姓在 <code>Angelina</code> 和 <code>Julla</code> 之间的人<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select last_name from People</span><br><span class="line">where last_name between &#x27;Angelina&#x27; and &#x27;Julla&#x27;;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | range</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | last<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">key           | last_</span>name</span><br><span class="line">key<span class="emphasis">_len       | 52</span></span><br><span class="line"><span class="emphasis">ref           | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">rows          | 3</span></span><br><span class="line"><span class="emphasis">filtered      | 100.0</span></span><br><span class="line"><span class="emphasis">Extra         | Using where; Using index</span></span><br></pre></td></tr></table></figure>
<p>这里 key 使用为 last_name, type 为 range 范围查询。</p>
</li>
<li><p><strong>精确匹配某一列并范围匹配另一列, 即第一列全匹配，第二列 first_name 范围匹配</strong><br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from People</span><br><span class="line">where last_name=&#x27;Cuba&#x27; and first_name between &#x27;Allen&#x27; and &#x27;zxxx&#x27;;</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | range</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | last<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">key           | last_</span>name</span><br><span class="line">key<span class="emphasis">_len       | 104</span></span><br><span class="line"><span class="emphasis">ref           | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">rows          | 2</span></span><br><span class="line"><span class="emphasis">filtered      | 100.0</span></span><br><span class="line"><span class="emphasis">Extra         | Using index condition</span></span><br></pre></td></tr></table></figure>
<p>这里索引用到了 last_name, type 为 range 范围查询。</p>
</li>
<li><p><strong>只访问索引的查询</strong><br>B-Tree 通常可以支持 “只访问索引的查询”，即查询只需要访问索引，无需访问数据行。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select last_name from People</span><br><span class="line">where last_name=&#x27;Allen&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>索引也可以用到 order by 排序操作，order by 子句满足前面列出的几种查询类型。</p>
</li>
</ul>
<h2 id="B-Tree-索引的限制"><a href="#B-Tree-索引的限制" class="headerlink" title="B-Tree 索引的限制"></a>B-Tree 索引的限制</h2><ul>
<li><strong>需要满足最左原则</strong>，即若不是按照索引的最左列开始查找的话，无法使用索引；<br>例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from People</span><br><span class="line">where first_name=&#x27;Allen&#x27;\G;</span><br><span class="line"></span><br><span class="line">explain select * from People</span><br><span class="line">where dob=&#x27;1960-01-01&#x27;\G;</span><br></pre></td></tr></table></figure>
output:<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | ALL</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span><br><span class="line">key           | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span><br><span class="line">key<span class="emphasis">_len       | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">ref           | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">rows          | 7</span></span><br><span class="line"><span class="emphasis">filtered      | 14.29</span></span><br><span class="line"><span class="emphasis">Extra         | Using where</span></span><br></pre></td></tr></table></figure></li>
<li>不能跳过索引中的列。例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from People</span><br><span class="line">where last_name=&#x27;Cuba&#x27; and dob=&#x27;1960-01-01&#x27;\G;</span><br></pre></td></tr></table></figure>
output:<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | ref</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | last<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">key           | last_</span>name</span><br><span class="line">key<span class="emphasis">_len       | 52</span></span><br><span class="line"><span class="emphasis">ref           | const</span></span><br><span class="line"><span class="emphasis">rows          | 2</span></span><br><span class="line"><span class="emphasis">filtered      | 14.29</span></span><br><span class="line"><span class="emphasis">Extra         | Using index condition</span></span><br></pre></td></tr></table></figure>
这样只是使用到了索引 <code>last_name</code>，<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from People</span><br><span class="line">where last_name=&#x27;Cuba&#x27; and first_name=&#x27;Allen&#x27; and dob=&#x27;1960-01-01&#x27;\G;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | ref</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | last<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">key           | last_</span>name</span><br><span class="line">key<span class="emphasis">_len       | 107</span></span><br><span class="line"><span class="emphasis">ref           | const,const,const</span></span><br><span class="line"><span class="emphasis">rows          | 1</span></span><br><span class="line"><span class="emphasis">filtered      | 100.0</span></span><br><span class="line"><span class="emphasis">Extra         | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure>
<p>通过 ref 的 <code>const, const, const</code> 可以知道，前者只用到了 <code>last_name</code> index，而后者都用到了<br>这里可以看到 type 类型为 ALL 表示全表扫描；</p>
<ul>
<li>若查询中有<strong>某个列的范围查询，则右边所有列都无法使用索引优化查找</strong>。<br>例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from People</span><br><span class="line">where last_name=&#x27;Cuba&#x27; and first_name like &#x27;A%&#x27; and dob=&#x27;1960-01-01&#x27;\G;</span><br></pre></td></tr></table></figure>
output:<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select<span class="emphasis">_type   | SIMPLE</span></span><br><span class="line"><span class="emphasis">table         | People</span></span><br><span class="line"><span class="emphasis">partitions    | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">type          | range</span></span><br><span class="line"><span class="emphasis">possible_</span>keys | last<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">key           | last_</span>name</span><br><span class="line">key<span class="emphasis">_len       | 107</span></span><br><span class="line"><span class="emphasis">ref           | <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">rows          | 1</span></span><br><span class="line"><span class="emphasis">filtered      | 14.29</span></span><br><span class="line"><span class="emphasis">Extra         | Using index condition</span></span><br></pre></td></tr></table></figure>
<h1 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h1></li>
<li><strong>索引大大减少了服务器需要扫描的数据量</strong></li>
<li><strong>索引可以帮助服务器避免排序和临时表</strong></li>
<li>索引可以将随机 I/O 变为顺序 I/O</li>
<li>索引对于 InnoDB (对索引支持行级锁) 非常重要，因为它可以让查询锁更少的元祖。<br>在 MySQL 5.1 和更新的版本中，InnoDB 可以在服务器端过滤掉行后就释放锁，但在早期的 MySQL 版本中，InnoDB 直到事务提交时才会解锁。对不需要的元组的加锁，会增加锁的开销，降低并发性。<br>InnoDB 仅对需要访问的元组加锁，而<strong>索引能够减少 InnoDB 访问的元组数</strong>。但是只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。</li>
<li>关于 InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但是访问主键索引需要排他锁（写锁）</li>
</ul>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul>
<li><strong>由于索引的存在，在进行`INSERT、UPDATE、DELETE 时，需要进行数据的更新修改，会降低更新表的速度</strong>。MySQL 不仅要保存数据，还要保存索引文件。</li>
<li><strong>建立索引会占用磁盘空间的索引文件。当数据量比较大的表及组合索引较多时，索引文件会膨胀的很快</strong></li>
<li>如果某个数据列包含许多重复的内容，建立索引就没有实际效果。</li>
<li>对于数据量非常小的表，全表扫描更高效。</li>
</ul>
<p>综上：建立一个<code>好</code>的索引是非常考究的，需要根据业务和实际场景不断的优化。</p>
<h1 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h1><h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><p>这类索引是最基本的索引，普通索引的唯一任务就是加快对数据的访问速度。<br>这类索引应该只为最经常出现在查询条件（where column = ）或 排序条件（order by column）中的数据列创建索引。</p>
<ul>
<li>创建<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name (column)</span><br></pre></td></tr></table></figure>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2>普通索引允许被索引的数据列包含重复的值，而唯一索引列的值必须唯一，但允许有空值如果是组合索引，则列值的组合必须唯一</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX idx_xxx ON my_table (column)</span><br></pre></td></tr></table></figure>

<h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p>它是一种特殊的唯一索引，不允许有空值。一个表只能有一个主键。</p>
<p>一般在创建主键的时候，会同时创建。</p>
<h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>组合索引也可称为联合索引，为表的多个列创建索引；<br>为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE my_table ADD INDEX idx_name_city_age (name, city, age)</span><br></pre></td></tr></table></figure>
<p>建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：<br><code>username, city, age</code><br><code>username, city</code><br><code>username</code></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>「 高性能的索引 」</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊 MySQL 事务</title>
    <url>/posts/26a608fc/</url>
    <content><![CDATA[<h1 id="InnoDB-Architecture"><a href="#InnoDB-Architecture" class="headerlink" title="InnoDB Architecture"></a>InnoDB Architecture</h1><blockquote>
<p>InnoDB 架构</p>
</blockquote>
<img src="/images/InnoDB-Architecture.png" width = "550" height = "500" alt="" align=center />

<h1 id="什么是事务（Transaction）"><a href="#什么是事务（Transaction）" class="headerlink" title="什么是事务（Transaction）"></a>什么是事务（Transaction）</h1><blockquote>
<p><strong>事务（Transaction）是访问和更新数据库的程序执行单元</strong>；是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位。<br>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
</blockquote>
<p>MySQL 中服务器层是不管理事务的，事务是由存储引擎实现的，下文中统一表示为 InnoDB</p>
<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><blockquote>
<p>理论上来说，事务有着极其严格的定义，它必须同时满足四个特性：</p>
</blockquote>
<ul>
<li><strong>原子性（Atomicity)</strong></li>
<li><strong>一致性（consistency）</strong></li>
<li><strong>隔离型（isolation）</strong></li>
<li><strong>持久性（durability）</strong></li>
</ul>
<p>接下来将逐一解释这四个特性：</p>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><blockquote>
<p>事务是如何实现 ACID 的</p>
</blockquote>
<img src="/images/事务的实现.png" width = "500" height = "300" alt="" align=center />

<p>事务的实现是通过<code>redo log</code> &amp;&amp; <code>undo log</code>, 以及锁 来实现的。</p>
<p>redo log 实现持久化和原子性，undo log 实现一致性，锁实现事务的隔离性。<br>redo log 是恢复提交事务修改的页操作，undo log 是回滚行记录到特定的版本。二者记录的内容也不同，redo log 是物理日志，记录页的物理修改操作，undo log<br>是逻辑日志，根据每行记录进行记录。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><blockquote>
<p>原子性表示一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；<br>如果事务中一个 sql 语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p>
</blockquote>
<h4 id="原子性的实现-undo-log"><a href="#原子性的实现-undo-log" class="headerlink" title="原子性的实现 - undo log"></a>原子性的实现 - undo log</h4><blockquote>
<p>首先，介绍一下各种日志，MySQL 的日志类型有很多种，例如二进制日志、错误日志、查询日志、慢查询日志等<br>在 InnoDB 存储引擎还提供了两种事务日志:</p>
<ul>
<li>redo log (重做日志)</li>
<li>undo log（回滚日志）<br>其中 <strong>redo log 用于保证事务持久性</strong>；<strong>undo log 则是事务原子性和隔离型实现的基础</strong>。</li>
</ul>
</blockquote>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><blockquote>
<p>一致性是指事务将数据库从一种一致性状态转变为下一种一致性状态。在事务开始之前和之后，数据库的完整性约束没有被破坏。</p>
</blockquote>
<h4 id="一致性事务的状态"><a href="#一致性事务的状态" class="headerlink" title="一致性事务的状态"></a>一致性事务的状态</h4><blockquote>
<p>因为事务是原子性的，所以从整体上来看的话，事务是密不可分的一个整体那么就可以将事务分状态看：</p>
<ul>
<li>Active(执行中)</li>
<li>Commited（执行成功，已提交）</li>
<li>Failed（执行失败）</li>
</ul>
</blockquote>
<img src="/images/trasaction.png" width = "300" height = "150" alt="" align=center />


<p>但是如果放大来看的话，事务也分为多个中间态。</p>
<img src="/images/trasaction-midware.png" width = "400" height = "250" alt="" align=center />

<ul>
<li>Active: 事务的初始状态，表示事务正在执行；</li>
<li>Partially Commited:  在最后一条语句执行之后；</li>
<li>Failed: 发现事务无法正常执行之后；</li>
<li>Aborted: 事务被回滚并且数据库恢复到了事务进行之前的状态之后；</li>
<li>Commited: 成功执行整个事务；</li>
</ul>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><blockquote>
<p>通过以上的介绍，我们知道 redo log 是实现事务的<code>原子性</code>和<code>持久性</code>。redo log 由两部分组成：</p>
<ul>
<li>内存中的日志缓存(redo log buffer)</li>
<li>重做日志文件(redo log file)</li>
</ul>
</blockquote>
<h4 id="redo-log-的更新流程"><a href="#redo-log-的更新流程" class="headerlink" title="redo log 的更新流程"></a>redo log 的更新流程</h4><p>以一次 update 例子：<br><img src="/images/redo-log.png" width = "600" height = "450" alt="" align=center /></p>
<ul>
<li>update 操作</li>
<li>先将原始数据从磁盘中读取到内存，修改内存中的数据</li>
<li>生成一条重做日志写入 redo log buffer, 记录数据被修改后的值</li>
<li>当事务提交时，需要将 redo log buffer 中的内容刷新到 redo log file</li>
<li>事务提交后，将内存中修改的数据写入磁盘中</li>
</ul>
<p>为了确保每次日志都写入重做日志文件，InnoDB 存储引擎会调用一次 fsync 操作</p>
<h4 id="redo-log-存储格式内容"><a href="#redo-log-存储格式内容" class="headerlink" title="redo log 存储格式内容"></a>redo log 存储格式内容</h4><p>首先比较一下 binlog 二进制日志，binlog 主要是主从复制和进行 POINT-IN-TIME 的恢复</p>
<p>binlog 只有在<strong>事务提交的时候</strong>才会写入，且是<strong>数据库的上层中</strong>产生的。redo log 是 Innodb 引擎层产生的。</p>
<img src="/images/redo log 日志格式.png" width = "300" height = "200" alt="" align=center />

<p>binlog 日志是每次事务才会写入，所以每个事务只会有一条日志，记录的是 SQL 语句</p>
<p>redo log 是事务开始就会写入，*T1 表示事务提交。记录的是物理格式日志，即每个页的修改</p>
<p>redo log 默认是以 block(块)的方式为单位进行存储，每个块是 512 个字节。不同的数据库引擎有对应的重做日志格式，Innodb 的存储管理是基于页的，所以其重做日志也是基于页的</p>
<img src="/images/redo-log-structure.png" width = "300" height = "70" alt="" align=center />

<ul>
<li>redo_log_type 重做日志类型</li>
<li>space 表空间的 ID</li>
<li>page_no 页的偏移量</li>
<li>redo_log_body 存储内容</li>
</ul>
<p>当我们执行插入语句时，日志内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO user values (1,2,3,43);</span><br><span class="line"></span><br><span class="line">page(2,3), offset 32, value 1,2,3,43 # 主键索引</span><br><span class="line">page(2,4), offset 64, value 2 # 辅助索引</span><br></pre></td></tr></table></figure>

<p>那么 redo log 为什么可以实现事务的原子性和持久性呢？</p>
<ul>
<li>原子性，<strong>redo log 记录了事务期间操作的物理日志</strong>，事务提交之前，并没有写入磁盘，保存在内存中，如果事务失败，数据库磁盘将不会发生改变，回滚掉内存部分的数据即可</li>
<li>持久性，<strong>redo log 会在事务提交时将日志存储到磁盘 redo log file, 保证日志的持久性</strong>。</li>
</ul>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><h4 id="什么是-undo-log"><a href="#什么是-undo-log" class="headerlink" title="什么是 undo log"></a>什么是 <code>undo log</code></h4><blockquote>
<p>undo log 则是事务<code>原子性</code>和<code>隔离性</code>实现的基础。<br>重做日志记录了事务的行为，可以友好地通过其对页进行<strong>重做</strong>操作。<br>当发生事务性操作的时候，InnoDB 就会产生一定量的 undo log。当<strong>回滚</strong>或者<strong>事务执行失败</strong>的情况发生的时候，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。<br>undo log 是采用段（segment）的记录方式来记录的，每个 undo 操作在记录的时候占用一个 undo log segment</p>
</blockquote>
<p><strong>由于 undo log 属于逻辑日志，不能物理地将数据库恢复成执行语句或者事务之前的样子。</strong><br>所有的修改操作都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</p>
<p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的任务就是协调对数据记录的并发访问。<br><strong>对于表空间而言，并不会修改成之前的样子。</strong></p>
<h4 id="undo-log-是如何恢复数据的？"><a href="#undo-log-是如何恢复数据的？" class="headerlink" title="undo log 是如何恢复数据的？"></a>undo log 是如何恢复数据的？</h4><p>undo log 属于<strong>逻辑日志</strong>，它记录的是 sql 执行相关的信息, 当用户执行 ROLLBACK 时</p>
<ul>
<li><strong>对于每个<code>insert</code>,记录<code>delete</code>;</strong></li>
<li><strong>对于每个<code>delete</code>,记录<code>insert</code>;</strong></li>
<li><strong>对于每个<code>update</code>,记录之前的<code>update</code>;</strong></li>
</ul>
<p>通过以上的操作便可实现<strong>回滚</strong>。</p>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><blockquote>
<p>事务的隔离级别是通过锁来实现</p>
</blockquote>
<p>四种隔离级别分别是, 从低到高：</p>
<ul>
<li>READ-UNCOMMITTED（读取未提交）</li>
<li>READ-COMMITTED（读取已提交）</li>
<li>REPEATABLE-READ（可重复读）</li>
<li>SERIALIZABLE（可串行化）</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>Mysql 默认采用的 <strong>REPEATABLE_READ</strong> 隔离级别</p>
<h4 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h4><ul>
<li>脏读（Dirty Read）:<br>读取到了错误的数据，A 事务执行 update 操作，B 事务执行查询获取结果，此时 A 事务 RollBack 导致读取数据不正确。</li>
<li>不可重复读（Non-repeatable read）:<br>在一个事务的两次查询之中数据不一致，这可能是<strong>两次查询过程中间插入了一个事务更新的原有的数据</strong>。</li>
<li>幻读（Phantom Read）:<br><strong>一个事务的两次查询中夹杂着插入事务的操作，数据量不一致</strong></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>理解事务的特性，原子性，一致性，持久性，隔离性，可以在使用中，更好的定位到问题，更好的设计业务系统。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 docker 镜像</title>
    <url>/posts/c5abce98/</url>
    <content><![CDATA[<h1 id="docker-image-是什么？"><a href="#docker-image-是什么？" class="headerlink" title="docker image 是什么？"></a>docker image 是什么？</h1><blockquote>
<p>镜像（Image）就是一堆只读层（read-only layer）的统一视角。</p>
</blockquote>
<h2 id="容器和镜像的关系"><a href="#容器和镜像的关系" class="headerlink" title="容器和镜像的关系"></a>容器和镜像的关系</h2><p>一张图可以带你理解:<br><img src="/images/image_and_container.png" width = "350" height = "200" alt="" align=center /></p>
<p>container = image + 读写层</p>
<h2 id="Docker-项目的核心原理"><a href="#Docker-项目的核心原理" class="headerlink" title="Docker 项目的核心原理"></a>Docker 项目的核心原理</h2><blockquote>
<p>对于 Dcoker 项目来说，它最核心的原理实际上就是为待创建的用户进程：</p>
</blockquote>
<ul>
<li><ol>
<li>启动 Linux Namespace 配置</li>
</ol>
</li>
<li><ol start="2">
<li>设置指定的 Cgroups 参数</li>
</ol>
</li>
<li><ol start="3">
<li>切换进程的根目录（Change Root）</li>
</ol>
</li>
</ul>
<p>对于该进程的根目录而言，对应的技术就是<code>rootfs</code></p>
<p><strong>rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动才会加载指定版本的内核镜像</strong></p>
<p>这就意味着，如果你的应用程序需要配置内核参数、加载额外的内核模块，以及跟内核进行直接的交互，你就需要注意了：这些操作和依赖的对象，都是宿主机操作系统的内核。</p>
<h2 id="image-一致性"><a href="#image-一致性" class="headerlink" title="image 一致性"></a>image 一致性</h2><p>所谓 镜像的一致性指的就是 <strong>rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，服务所需要的所有依赖，都被封装在了一起</strong>。</p>
<h2 id="image-设计"><a href="#image-设计" class="headerlink" title="image 设计"></a>image 设计</h2><blockquote>
<p>Docker 在镜像的设计中，引入了层（layer）的概念。用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。</p>
</blockquote>
<p>这个设计的技术主要是用到了一种叫做<code>联合文件系统(Union File System)</code> 的能力<br>主要的功能就是将多个不同位置的目录联合挂载（union mount）到同一目录下。</p>
<h2 id="docker-image-中的-layer"><a href="#docker-image-中的-layer" class="headerlink" title="docker image 中的 layer"></a>docker image 中的 layer</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image inspect ubuntu:latest</span></span><br><span class="line">...</span><br><span class="line">     &quot;RootFS&quot;: &#123;</span><br><span class="line">      &quot;Type&quot;: &quot;layers&quot;,</span><br><span class="line">      &quot;Layers&quot;: [</span><br><span class="line">        &quot;sha256:f49017d4d5ce9c0f544c...&quot;,</span><br><span class="line">        &quot;sha256:8f2b771487e9d6354080...&quot;,</span><br><span class="line">        &quot;sha256:ccd4d61916aaa2159429...&quot;,</span><br><span class="line">        &quot;sha256:c01d74f99de40e097c73...&quot;,</span><br><span class="line">        &quot;sha256:268a067217b5fe78e000...&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<img src="/images/image_layer.png" width = "600" height = "400" alt="" align=center />

<ul>
<li><p>只读层<br>它是容器的 rootfs 最下面的五层，对应正是 image 镜像的 5 层。他们的挂载方式只能是只读的（ro+wh, 即 readonly+whiteout）</p>
</li>
<li><p>Init 层<br>它是一个以”-init”结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息</p>
</li>
</ul>
<p>这部分主要是 docker run 命令启动时，用户自定义的一些参数</p>
<ul>
<li>可读写层<br>这一层是容器的 rootfs 最上面的一层，它的挂载方式为：rw, 在没有写入文件之前，这个目录是空的。而一旦在容器中进行了写操作，你修改产生的内容就会以增量的方式出现在这个层中。</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 面向对象设计模式</title>
    <url>/posts/70c3aece/</url>
    <content><![CDATA[<h1 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p><strong>工厂模式属于创建者模式</strong></p>
<p>工厂模式：目的时提供方便快捷的对象创建方式，当对象的创建类型多样时，可以使用工厂方法；</p>
<p>当对象与对象关系较复杂时，且存在关联时，可构建抽象工厂方法；</p>
</blockquote>
<p>工厂模式属于创建型模式，<strong>目的是提供更好的创建对象的方式</strong></p>
<p>工厂模式通常有两种：</p>
<ul>
<li>工厂方法（Factory Method）—— 它是一个方法，对于<strong>不同的参数返回不同的对象</strong></li>
<li>抽象工厂，它是一组用于<strong>创建一系列相关事物对象</strong>的工厂方法，例如一辆车的各个部件</li>
</ul>
<p><strong>两种模式都可以用于以下场景：</strong></p>
<ul>
<li> <strong>想要追踪对象的创建时</strong></li>
<li><strong>想要将对象的创建与使用解耦时</strong></li>
<li><strong>想要优化性能和资源占用时</strong></li>
</ul>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>Django 框架中使用工厂方法模式来创建表单字段。Django 的 forms 模块支持不同类型的字段（CharField、EmailField）</p>
<blockquote>
<p><a href="https://github.com/django/django/blob/main/django/forms/fields.py">https://github.com/django/django/blob/main/django/forms/fields.py</a></p>
</blockquote>
<p>创建多个工厂方法也完全没有问题，实践中通常也这么做，对相似的对象创建进行逻辑分组，每个工厂负责一个组。</p>
<p>工厂犯法可以在必要时创建新的对象，从而提高性能和内存使用率。若直接实例化类来创建对象，那么需要分配额外的内存</p>
<p>例如：XML、Atom、YAML、JSON 解析器</p>
<p><strong>DEMO</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> etree</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonParser</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filepath: <span class="built_in">str</span></span>):</span></span><br><span class="line">        self._data = &#123;&#125;</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filepath, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            self._data = json.load(f)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XMLParser</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filepath: <span class="built_in">str</span></span>):</span></span><br><span class="line">        self._tree = etree.parse(filepath)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parser_factory</span>(<span class="params">filepath: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> filepath.endswith(<span class="string">&#x27;json&#x27;</span>):</span><br><span class="line">        parser = JsonParser</span><br><span class="line">    <span class="keyword">elif</span> filepath.endswith(<span class="string">&#x27;xml&#x27;</span>):</span><br><span class="line">        parser = XMLParser</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;cannot found the parser of <span class="subst">&#123;filepath&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser(filepath)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    json_factory = parser_factory(<span class="string">&quot;./test.json&quot;</span>)</span><br><span class="line">    j_data = json_factory.data</span><br><span class="line">    <span class="built_in">print</span>(j_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>一个抽象工厂是（逻辑上的）一组工厂方法，其中的每个工厂方法负责产生不同种类的对象</p>
<p>抽象工厂模式是工厂方法的一种泛化，所以它能提供相同的好处。</p>
<p><strong>我们怎么知道何时该使用工厂方法，何时又该使用抽象工厂？答案是，通常一开始时使用工厂方法，因为它更简单。如果后续发现应用需要许多工厂方法，那么将创建一系列对象的过程合并在一起更合理，从而最终引入抽象工厂。</strong></p>
<p><strong>DEMO</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类别：男巫</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wizard</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interact_with</span>(<span class="params">self, obstacle</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; the Wizard battles against &#123;&#125; and &#123;&#125;!&#x27;</span>.<span class="built_in">format</span>(self, obstacle, obstacle.action()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类别二、兽人</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ork</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;an evil ork&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;kills it&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类别二、工厂方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WizardWorld</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        self.player_name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\n\n\t------ Wizard World ———&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_character</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Wizard(self.player_name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_obstacle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Ork()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象工厂方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameEnvironment</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, factory</span>):</span></span><br><span class="line">        self.hero = factory.make_character()</span><br><span class="line">        self.obstacle = factory.make_obstacle()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.hero.interact_with(self.obstacle)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 一堆参数设置</span></span><br><span class="line">    environment = GameEnvironment(game(name))</span><br><span class="line">    environment.play()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式允许我们将一个提供核心功能的对象和其他可以改变这个功能的对象”包裹”在一起。</p>
<p>装饰器模式主要有两种用途：</p>
<ul>
<li>增强一个组件向另一个组件发送数据时的响应能力</li>
<li>支持多种可选行为</li>
</ul>
<p><strong>闭包方式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_call</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;func.__name__&#125;</span> running...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@log_call</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_example</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;running...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run_example()</span><br></pre></td></tr></table></figure>

<p><strong>对象方式</strong></p>
<p><code>__call__</code> 方法是实现对象方式的关键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self, params</span>):</span></span><br><span class="line">        self.params = params</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="comment"># do something</span></span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>主要用<strong>处理一个系统中不同实体（比如类和对象）之间的关系，关注的是提供一种简单的对象组合方式来创造新的功能</strong></p>
<p><strong>适配器模式（Adapter pattern）的主要作用就是把原本不兼容的接口，通过适配修改做到统一。</strong></p>
<blockquote>
<p>如果我们希望把一个老组件用于一个新系统中，或者反过来，在一个新系统中兼容老的组件，这时就需要编写一个额外的代码层，该代码层包含让两个接口之间能够通信需要进行所有修改。</p>
</blockquote>
<p>例如：每个类都实现自己语言，使用适配器进行适配，使得每个实例发出声音</p>
<p><strong>DEMO</strong></p>
<p><code>__dict__</code> &amp;&amp; <code>__getattr__</code>是实现适配器的关键</p>
<blockquote>
<p><code>__getattr__</code>()是仅当属性不能在实例的<code>__dict__</code>或它的类(类的<code>__dict__</code>),或父类的<code>__dict__</code>中找到时，才被调用。一般在代码中包含一个对getattr()內建函数的调用</p>
<p>每一个类都会用一个字典，把它包含的属性放到自己的字典里。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Dog&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;woof!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Cat&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">meow</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;meow!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Human&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#x27;hello&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Car&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_noise</span>(<span class="params">self, octane_level</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;vroom%s&quot;</span> % (<span class="string">&quot;!&quot;</span> * octane_level)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, obj, adapted_methods</span>):</span></span><br><span class="line">        self.obj = obj</span><br><span class="line">        self.__dict__.update(adapted_methods)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, attr</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.obj, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    objects = []</span><br><span class="line">    dog = Dog()</span><br><span class="line">    objects.append(Adapter(dog, <span class="built_in">dict</span>(make_noise=dog.bark)))</span><br><span class="line">    cat = Cat()</span><br><span class="line">    objects.append(Adapter(cat, <span class="built_in">dict</span>(make_noise=cat.meow)))</span><br><span class="line">    human = Human()</span><br><span class="line">    objects.append(Adapter(human, <span class="built_in">dict</span>(make_noise=human.speak)))</span><br><span class="line">    car = Car()</span><br><span class="line">    car_noise = <span class="keyword">lambda</span>: car.make_noise(<span class="number">3</span>)</span><br><span class="line">    objects.append(Adapter(car, <span class="built_in">dict</span>(make_noise=car_noise)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> objects:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>, obj.name, <span class="string">&quot;goes&quot;</span>, obj.make_noise())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote>
<p>外观模式在很多方面与适配器模式相同。主要的区别在于，外观模式试图从一个复杂的系统中抽象出一个简单的接口；而适配器只不过是将一个现有的接口匹配到另一个。</p>
</blockquote>
<p><strong>外观模式的目的是为拥有多个组件的复杂系统提供简单的接口。</strong>这个系统内的对象为了完成复杂的任务和交互需求会进行各种直接的交互。该系统通常存在某些典型的用途</p>
<blockquote>
<p>这里用一个<strong>自己泡茶</strong>和<strong>去茶馆喝茶</strong>的例子，自己泡茶的话，需要自行准备茶叶、茶具和开水，而自己去茶馆喝茶，最简单的方式就是和茶馆服务员说想要一杯什么茶，是铁观音、碧螺春还是西湖龙井。</p>
</blockquote>
<p>这里典型的茶的种类就是典型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Copyright DataGrand Tech Inc. All Rights Reserved.</span></span><br><span class="line"><span class="string">Author: tianzhichao</span></span><br><span class="line"><span class="string">File: facade.py</span></span><br><span class="line"><span class="string">Time: 2023/2/20 10:27 PM</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Water</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_water</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hot water&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeaPot</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_teapot</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;get teapot&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">red_tea</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;red tea&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.water = Water()</span><br><span class="line">        self.teapot = TeaPot()</span><br><span class="line">        self.tea = Tea()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_red_tea</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.water.get_water()</span><br><span class="line">        self.teapot.get_teapot()</span><br><span class="line">        self.tea.red_tea()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tea_client</span>():</span></span><br><span class="line">    facade = Facade()</span><br><span class="line">    facade.get_red_tea()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tea_client()</span><br></pre></td></tr></table></figure>



<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式在撞见检测和事件处理等场景中时非常有用的。</p>
<p>这种模式确保一个 核心 对象可以由一组未知并可能正在扩展的 观察者 对象来监控。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inventory</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._product = <span class="literal">None</span></span><br><span class="line">        self._quality = <span class="number">0</span></span><br><span class="line">        self.observers = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span>(<span class="params">self, observer</span>):</span></span><br><span class="line">        self.observers.append(observer)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._product</span><br><span class="line"></span><br><span class="line"><span class="meta">    @product.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._product = value</span><br><span class="line">        self._update_observer()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_observer</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> self.observers:</span><br><span class="line">            observer()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleObserver</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inventory</span>):</span></span><br><span class="line">        self._inventory = inventory</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;the name of product: <span class="subst">&#123;self._inventory.product&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    i = Inventory()</span><br><span class="line">    c = ConsoleObserver(i)</span><br><span class="line">    i.attach(c)</span><br><span class="line"></span><br><span class="line">    i.product = <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式是一种内存优化模式。由于对象创建的开销，面向对象的系统可能会面临性能问题。</p>
<p>当我们创建一个新对象时，需要分配额外内存</p>
<p>享元设计模式通过为相似对象引入数据共享来最小化内存使用，提升性能。</p>
<p>一个享元（Flyweight）就是一个包含状态独立的不可变（又称固有的）数据的共享对象。依赖状态的可变（又称非固有的）数据不应是享元的一部分，因为每个对象的这种信息都不同，无法共享。若享元需要非固有的数据，应该由客户端代码显式地提供。</p>
<p>享元模式使用的几个条件</p>
<ul>
<li>应用需要大量的对象</li>
<li>对象太多，存储/渲染它们的代价太大。一旦移除对象中的可变状态（因为在需要之时，应该由客户端代码显式地传递给享元），多组不同的对象可被相对更少的共享对象所替代。</li>
<li>对象 ID 对于应用不重要。对象共享会造成 ID 比较的失败，所以不能依赖对象 ID </li>
</ul>
<p><strong>DEMO</strong></p>
<p>例如在一个游戏中，需要很多树对象，不变的是树对象的样子，变化的地方是树的年纪和坐标。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line">TreeType = Enum(<span class="string">&#x27;TreeType&#x27;</span>, <span class="string">&#x27;apple_tree cherry_tree peach_tree&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tree</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    tree_pool = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, tree_type</span>):</span></span><br><span class="line">        <span class="comment"># 判断树的类型</span></span><br><span class="line">        obj = cls.tree_pool.get(tree_type, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obj:</span><br><span class="line">            obj = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">            cls.tree_pool[tree_type] = obj</span><br><span class="line">            obj.tree_type = tree_type</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 位置坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span>(<span class="params">self, age, x, y</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;render a tree of type <span class="subst">&#123;self.tree_type&#125;</span> and age <span class="subst">&#123;age&#125;</span> at (<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 以下仅分配了 3 课树的内存</span></span><br><span class="line">    age_min, age_max = <span class="number">1</span>, <span class="number">30</span></span><br><span class="line">    min_point, max_point = <span class="number">0</span>, <span class="number">100</span></span><br><span class="line">    tree_counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        t1 = Tree(TreeType.apple_tree)</span><br><span class="line">        t1.render(random.randint(age_min, age_max),</span><br><span class="line">                  random.randint(min_point, max_point),</span><br><span class="line">                  random.randint(min_point, max_point)</span><br><span class="line">                  )</span><br><span class="line"></span><br><span class="line">        tree_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        t2 = Tree(TreeType.cherry_tree)</span><br><span class="line">        t2.render(random.randint(age_min, age_max),</span><br><span class="line">                  random.randint(min_point, max_point),</span><br><span class="line">                  random.randint(min_point, max_point)</span><br><span class="line">                  )</span><br><span class="line"></span><br><span class="line">        tree_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t3 = Tree(TreeType.peach_tree)</span><br><span class="line">        t3.render(random.randint(age_min, age_max),</span><br><span class="line">                  random.randint(min_point, max_point),</span><br><span class="line">                  random.randint(min_point, max_point)</span><br><span class="line">                  )</span><br><span class="line"></span><br><span class="line">        tree_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;trees rendered: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(tree_counter))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;trees actually created: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(Tree.tree_pool)))</span><br><span class="line"></span><br><span class="line">    t4 = Tree(TreeType.cherry_tree)</span><br><span class="line">    t5 = Tree(TreeType.cherry_tree)</span><br><span class="line">    t6 = Tree(TreeType.apple_tree)</span><br><span class="line">    t7 = Tree(TreeType.peach_tree)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(Tree.tree_pool)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; == &#123;&#125;? &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>(t4), <span class="built_in">id</span>(t5), <span class="built_in">id</span>(t4) == <span class="built_in">id</span>(t5)))    <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; == &#123;&#125;? &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>(t5), <span class="built_in">id</span>(t6), <span class="built_in">id</span>(t5) == <span class="built_in">id</span>(t6)))    <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令设计模式帮助我们将一个操作（撤销、重做、复制、粘贴）封装成一个对象。</p>
<p>这意味着创建一个类，包含实现该操作所需要的所有逻辑和方法。这样做的优势如下：</p>
<ul>
<li>我们并不需要直接执行一个命令。命令可以按照希望执行</li>
<li>调用命令的对象与指导如何执行命令的对象解耦。调用者无需知道命令的实现细节。</li>
<li>如果有意义，可以将多个命令组织起来，这样调用者能够按顺序执行它们，例如，在实现一个多层撤销命令时，这是很有用的。</li>
</ul>
<h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><ul>
<li>GUI 按钮和菜单项：PyQt 例子使用命令模式来实现按钮和菜单项上的的动作</li>
<li>其他操作：除了撤销，命令模式可以实现任何操作。其中一些例子包括剪切、复制、粘贴、重做，文本大写</li>
<li>事务性行为和日志记录：事务型行为和日志记录对于为变更记录一份持久化日志是很重要的。操作系统用他来从系统奔溃中恢复，关系型数据库用它来实现事务，文件系统用它来实现 snapshot，而安装程序（向导程序）用它来恢复取消的安装</li>
<li>宏：在这里，宏是指一个动作序列，可在任意时间点按要求进行录制和执行。流行的编辑器（比如 Emacs 和 Vim）都支持宏。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现最基本的文件操作工具</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Copyright DataGrand Tech Inc. All Rights Reserved.</span></span><br><span class="line"><span class="string">Author: tianzhichao</span></span><br><span class="line"><span class="string">File: command.py</span></span><br><span class="line"><span class="string">Time: 2023/2/21 11:20 PM</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line">verbose = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">undo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenameFile</span>(<span class="params">Command</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    重命名文件，包含撤销操作</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">undo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateFile</span>(<span class="params">Command</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建文件，包含撤销操作</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, path, txt=<span class="string">&quot;hello world\n&quot;</span></span>):</span></span><br><span class="line">        self.path = path</span><br><span class="line">        self.txt = txt</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">undo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadFile</span>(<span class="params">Command</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self, path</span>):</span></span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">undo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeleteFile</span>(<span class="params">Command</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self, path</span>):</span></span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">undo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h1><p>领域驱动设计：<a href="https://book.douban.com/subject/26819666/">https://book.douban.com/subject/26819666/</a></p>
<p>软件设计：<a href="https://l1nwatch.gitbook.io/python-design-mode/">https://l1nwatch.gitbook.io/python-design-mode/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 垃圾回收机制</title>
    <url>/posts/88f7796/</url>
    <content><![CDATA[<h1 id="Golang-垃圾回收"><a href="#Golang-垃圾回收" class="headerlink" title="Golang 垃圾回收"></a>Golang 垃圾回收</h1><blockquote>
<p><strong>垃圾回收 (Garbage Collection, 简称 GC)是编程语言中自动的内存管理机制，清除不再使用的对象，释放对应内存</strong>。</p>
</blockquote>
<h2 id="Golang-GC-各版本变化"><a href="#Golang-GC-各版本变化" class="headerlink" title="Golang GC 各版本变化"></a>Golang GC 各版本变化</h2><table>
<thead>
<tr>
<th>版本</th>
<th>GC 算法</th>
</tr>
</thead>
<tbody><tr>
<td>v1.1</td>
<td>STW(stop the world)</td>
</tr>
<tr>
<td>v1.3</td>
<td>Mark STW,Sweep（标记清除）</td>
</tr>
<tr>
<td>v1.5</td>
<td>三色标记</td>
</tr>
<tr>
<td>v1.8</td>
<td>Hybrid wire barrier (三色标记基础加入写屏障)</td>
</tr>
</tbody></table>
<h3 id="标记清除算法（mark-and-sweep-v1-3"><a href="#标记清除算法（mark-and-sweep-v1-3" class="headerlink" title="标记清除算法（mark and sweep, v1.3)"></a>标记清除算法（mark and sweep, v1.3)</h3><ul>
<li><ol>
<li>找出不可达对象，mark</li>
</ol>
</li>
<li><ol start="2">
<li>回收标记好的对象</li>
</ol>
</li>
</ul>
<p>mark and sweep 算法在执行的时候，需要程序暂停，即 stop the world</p>
<p>标记清除算法存在的问题</p>
<ul>
<li>stop the world 程序会暂停，即程序会出现卡顿</li>
<li>标记需要扫描整个堆（heap）</li>
<li>清除数据会产生 heap 碎片</li>
</ul>
<h2 id="三色并发标记法-v-1-5"><a href="#三色并发标记法-v-1-5" class="headerlink" title="三色并发标记法(v 1.5)"></a>三色并发标记法(v 1.5)</h2><p>该算法是在 v1.5 版本开始使用，这里的三色，对应垃圾回收过程中对象的三种状态：</p>
<ul>
<li><strong>灰色：对象还在标记队列中等待</strong></li>
<li><strong>黑色：对象已被标记，该对象不会在本次 GC 中被清理</strong></li>
<li><strong>白色：对象未被标记，该对象将会在本次 GC 中被清理</strong></li>
</ul>
<h2 id="三色标记法的过程-v1-5"><a href="#三色标记法的过程-v1-5" class="headerlink" title="三色标记法的过程(v1.5)"></a>三色标记法的过程(v1.5)</h2><ol>
<li><p>初始阶段，<strong>所有对象都是白色：</strong></p>
<img src="/images/go/GC_1.png" width = "500" height = "350" alt="" align=center /></li>
<li><p>GC 开始扫描，<strong>从根节点开始遍历</strong>，A 和 F 是根节点，将其标记为灰色对象, <strong>即根节点先置灰。</strong></p>
<img src="/images/go/GC_2.png" width = "500" height = "350" alt="" align=center /></li>
<li><p>GC 继续扫描灰色对象，<strong>将根节点的子节点标记为灰色对象</strong>。A 的子节点 B C D 被标记为灰色对象，A 被标记为黑色对象。F 没有子节点，也被标记为黑色对象，<strong>即根节点置黑，子节点置灰</strong></p>
<img src="/images/go/GC_3.png" width = "500" height = "350" alt="" align=center /></li>
<li><p>GC 会<strong>循环遍历灰色对象，直到灰色对象之中没有节点结束</strong>。B、C、D没有子节点，会变为黑色对象，<strong>即循环遍历所有节点，将所有父节点置黑。</strong></p>
<img src="/images/go/GC_4.png" width = "500" height = "350" alt="" align=center /></li>
<li><p>未被标记的 E、G、H 为白色对象，GC 便会回收这些白色对象，<strong>即回收未被标记的白色对象</strong>。</p>
<img src="/images/go/GC_5.png" width = "500" height = "350" alt="" align=center /></li>
<li><p>这一轮垃圾回收结束后，<strong>GC 会进行进一步操作，将黑色对象重新变为白色对象，供下一次垃圾回收使用</strong>。</p>
<img src="/images/go/GC_6.png" width = "500" height = "350" alt="" align=center /></li>
</ol>
<h2 id="垃圾回收优化-写屏障"><a href="#垃圾回收优化-写屏障" class="headerlink" title="垃圾回收优化-写屏障"></a>垃圾回收优化-写屏障</h2><p>STW (stop the world) 的目的是防止 GC 扫描时内存变化而停掉 goroutine, 而<strong>写屏障就是让 goroutine 与 GC 同时运行的手段</strong>。<br>虽然写屏障不能完全消除 STW，但是可以大大减少 STW 的时间。写屏障类似一种开关，在 GC 的特定时间开启，开启后指针传递时会把指针标记，即本轮不回收，下次GC时再确定。<br>GC 过程中新分配的内存会被立即标记，用的并不是写屏障技术，也即 GC 过程中分配的内存不会在本轮 GC 中回收。</p>
<h2 id="垃圾回收优化-Mutator-Assist"><a href="#垃圾回收优化-Mutator-Assist" class="headerlink" title="垃圾回收优化-Mutator-Assist"></a>垃圾回收优化-Mutator-Assist</h2><p>为防止内存分配过快、在 GC 执行过程中，如果 goroutine 需要分配内存，那么这个 goroutine 会参与一部分 GC 的工作，这个机制叫做 Mutator Assist。</p>
<h2 id="垃圾回收触发机制"><a href="#垃圾回收触发机制" class="headerlink" title="垃圾回收触发机制"></a>垃圾回收触发机制</h2><ol>
<li><p>每次内存分配时都会检查当前内存分配量是否 已经到达阈值，如果达到就立即启动 GC。内存增长率由环境变量<code>GOGC</code> 控制，默认是 100，即每当内存扩大一倍时启动 GC。<br>之后堆内存达到上一次垃圾手机的 2 倍才会触发 GC.</p>
</li>
<li><p>默认情况下，最长 2 分钟触发一次 GC。</p>
</li>
<li><p>程序代码中也可以使用 runtime.GC() 来手动触发 GC。这主要用于 GC 性能测试和统计。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache &amp;&amp; DB 数据一致性</title>
    <url>/posts/c4a988da/</url>
    <content><![CDATA[<h1 id="Redis、MySQL-如何保证数据一致性？"><a href="#Redis、MySQL-如何保证数据一致性？" class="headerlink" title="Redis、MySQL 如何保证数据一致性？"></a>Redis、MySQL 如何保证数据一致性？</h1><blockquote>
<p>一般情况下，Redis 是用来实现应用和数据库之间的一个读操作的缓存层。主要目的是去减少数据库的 IO ,还可以提升数据库的 IO 性能。</p>
</blockquote>
<p>整体架构：<br><img src="/images/Redis-MySQL架构.png" width = "500" height = "300" alt="" align=center /></p>
<p>当应用程序需要去读取某个数据的时候，首先会尝试 Redis 里面去加载，如果命中了就直接去加载，直接返回数据，如果没有命中，就查询数据库，然后再将查询到的数据写入到 redis 缓存中。</p>
<p>在这个架构里面呢，会出现<code>数据一致性的问题</code>。</p>
<p>一份数据同时被保存在 redis 和 mysql 里面，当某个数据需要被更新的时候，由于更新数据是具有前后顺序的，它并不像 mysql 中的多表事务操作，可以满足 ACID 的特性。</p>
<p>常规解决办法只有两种：</p>
<ol>
<li><p>先更新数据库，再更新缓存。</p>
<p>该种方案，若出现缓存失败的话，会出现数据不一致的问题。</p>
</li>
<li><p>先删除缓存，再更新数据库。</p>
<p>该种方案，是借助再次访问该数据的时候，发现 redis 里的数据为空，然后查询数据库再次加载。但是这两个操作并不是原子操作，所以在这个过程中，如果出现其他线程来访问，还是会存在数据不一致的问题。</p>
</li>
</ol>
<p>那么，需要在极端情况下仍要保证 redis 和 mysql 数据一致性，就需要采用 <code>最终一致性</code>的方案。</p>
<p>例如 <code>基于 MQ 的可靠性消息通信</code>来实现数据最终的一致性。</p>
<p>或者，直接通过 Canel 组件，监控 mysql 中的 bingo 的日志，将更新后的数据同步到 Redis 里面。</p>
<p>接下来，就聊一下各种缓存方案…</p>
<h2 id="一致性-consistency"><a href="#一致性-consistency" class="headerlink" title="一致性(consistency)"></a>一致性(consistency)</h2><blockquote>
<p>一致性就是缓存和数据库存储数据的两份数据保持一致性</p>
</blockquote>
<ul>
<li>强一致性要求：<blockquote>
<p>所谓强一致性，就是对于 app 来说，缓存和数据库存储的数据读写是符合原子性的，要求读写的一致性，实现起来时对系统的影响大。</p>
</blockquote>
</li>
<li>弱一致性：<blockquote>
<p>这部分对于缓存层和数据库层数据一致性要求较低，不要求在更新数据时，缓存和数据库立即同步更新的情况，也不会要求缓存和数据库多久达到一致性，但是会尽可能保证<br>到某个时间级别后，数据能够达到一致性状态。</p>
</blockquote>
</li>
<li>最终一致性：<blockquote>
<p>最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。</p>
</blockquote>
</li>
</ul>
<h1 id="三种经典的缓存模式"><a href="#三种经典的缓存模式" class="headerlink" title="三种经典的缓存模式"></a>三种经典的缓存模式</h1><ul>
<li>Cache-Aside Pattern</li>
<li>Read-Through/Write through</li>
<li> Write behind</li>
</ul>
<h2 id="Cache-Aside-读流程"><a href="#Cache-Aside-读流程" class="headerlink" title="Cache-Aside 读流程"></a>Cache-Aside 读流程</h2><blockquote>
<p>旁路缓存模式，它的提出是为了尽可能地解决缓存与数据库的数据不一致问题</p>
</blockquote>
<p>Cache-Aside 读流程</p>
<img src="/images/Cache-Aside.png" width = "300" height = "400" alt="" align=center />


<ol>
<li>读取数据的时候，先读缓存，缓存命中时，直接返回数据。</li>
<li>缓存未命中时，读取数据库，取数据的时候同时更新数据到缓存中，返回响应</li>
</ol>
<h2 id="Cache-Aside-写流程"><a href="#Cache-Aside-写流程" class="headerlink" title="Cache-Aside 写流程"></a>Cache-Aside 写流程</h2><blockquote>
<p>更新的时候，先更新数据库，然后再删除缓存</p>
</blockquote>
<img src="/images/Cache-Aside-write.png" width = "200" height = "300" alt="" align=center />

<h2 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read-Through"></a>Read-Through</h2><blockquote>
<p>Read/Write Through 模式中，服务端把<code>缓存</code>作为<code>主要数据存储</code>。应用程序跟数据库缓存交互，都是通过<code>抽象缓存层</code>完成的</p>
</blockquote>
<img src="/images/Cache-Aside-whole-process.png" width = "600" height = "400" alt="" align=center />

<p>Read-Through 的思想是采用的将缓存作为主要的存储结构，是从性能的角度出发。</p>
<h2 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write-Through"></a>Write-Through</h2><blockquote>
<p>这种模式下，当发生请求时，是由缓存抽象层完成数据源和缓存数据的更新<br><img src="/images/Cache-Aside-write-process.png" width = "600" height = "400" alt="" align=center /></p>
</blockquote>
<h2 id="Write-behind-（异步缓存写入）"><a href="#Write-behind-（异步缓存写入）" class="headerlink" title="Write behind （异步缓存写入）"></a>Write behind （异步缓存写入）</h2><blockquote>
<p>Write behind 和 Read-Through/Write-Through 相似，都是由 <code>Cache Provider</code>来负责缓存和数据库看的读写。<br>但是 前者是同步更新缓存和数据的，Write Behind 则只是更新缓存，不直接更新数据库，通过<code>批量异步</code>的方式来更新数据库。<br><img src="/images/Cache-Aside-write-behind-process.png" width = "600" height = "400" alt="" align=center /></p>
</blockquote>
<h2 id="三种模式的比较"><a href="#三种模式的比较" class="headerlink" title="三种模式的比较"></a>三种模式的比较</h2><p>Cache Aside 更新模式实现起来比较简单，但是需要维护两个数据存储:</p>
<ul>
<li>缓存（Cache）</li>
<li>一个是数据库（Repository）</li>
</ul>
<p>Read/Write Through 的写模式需要维护一个数据存储（Cache Provider），实现起来较为复杂一些。</p>
<p>Write Behind Caching 更新模式和 Read/Write Through 更新模式类似，区别是 Write Behind Caching 更新模式的数据持久化操作是<code>异步</code>的，但是`Read/Write Through 更新模式的数据持久化操作是<strong>同步的</strong></p>
<p>Write Behind Caching 的优点是直接<code>操作内存速度快</code>,多次操作可以合并持久化到数据库。缺点是数据可能会丢失，例如系统断电等等。</p>
<h2 id="Cache-Aside-问题"><a href="#Cache-Aside-问题" class="headerlink" title="Cache-Aside 问题"></a>Cache-Aside 问题</h2><p><strong>我们在更新数据的时候，Cache-Aside 是删除缓存呢，还是应该更新缓存？</strong></p>
<img src="/images/Cache-Aside-write.png" width = "200" height = "300" alt="" align=center />

<p>我们在操作缓存的时候，到底是应该删除缓存还是说更新缓存呢？我们先来看个例子：<br>多线程情况：<br><img src="/images/多线程-Cache-DB.png" width = "600" height = "400" alt="" align=center /></p>
<p>以上情况就可以看出来问题：</p>
<blockquote>
<p>线程 A 先发起一个写操作，先更新数据库。<br>线程 B 再发起写操作，更新数据库。</p>
</blockquote>
<p>现在由于网络原因，线程 B 的更新缓存的操作却在 A 之后发生。<br>此时缓存中的数据就是与数据库中不一致了。</p>
<p><strong>更新缓存相对于删除缓存还有两点劣势</strong>：</p>
<blockquote>
<ol>
<li>若写入缓存的值，是经过复杂计算才得到，更新频率较高的情况下，十分浪费性能。</li>
<li>在写多读少的情况下，也会十分浪费性能。</li>
</ol>
</blockquote>
<h2 id="双写的情况下，先操作数据库还是先操作缓存？"><a href="#双写的情况下，先操作数据库还是先操作缓存？" class="headerlink" title="双写的情况下，先操作数据库还是先操作缓存？"></a>双写的情况下，先操作数据库还是先操作缓存？</h2><p>如果遇到多线程情况，也会有类似情况，出现缓存中存储的是脏数据。因此 Cache-Aside 缓存模式，选择了先操作数据库而不是先操作缓存</p>
<h1 id="两种方案保证数据库与缓存的一致性"><a href="#两种方案保证数据库与缓存的一致性" class="headerlink" title="两种方案保证数据库与缓存的一致性"></a>两种方案保证数据库与缓存的一致性</h1><ul>
<li>删除缓存重试机制</li>
<li>读取 binlog 异步删除缓存</li>
</ul>
<h2 id="删除缓存重试机制"><a href="#删除缓存重试机制" class="headerlink" title="删除缓存重试机制"></a>删除缓存重试机制</h2><p>多次删除确保 cache 中存储的是正确的数据<br><img src="/images/del_cache_retry.png" width = "600" height = "400" alt="" align=center /></p>
<p>删除缓存重试机制的大致步骤：</p>
<ul>
<li>写请求更新数据库</li>
<li>缓存因为某些原因，删除失败</li>
<li>把删除失败的 key 放到消息队列</li>
<li>消费消息队列的消息，获取要删除的 key</li>
<li>重试删除缓存操作</li>
</ul>
<h2 id="同步-binlog-异步删除缓存"><a href="#同步-binlog-异步删除缓存" class="headerlink" title="同步 binlog 异步删除缓存"></a>同步 binlog 异步删除缓存</h2><p>重试删除缓存机制还可以，就是会造成好多业务代码入侵。<br>其实，还可以通过数据库的 binlog 来异步淘汰 key</p>
<img src="/images/binlog.png" width = "600" height = "400" alt="" align=center />

<p>以 mysql 为例，可以使用阿里的 canal 将 binlog 日志采集发送到 MQ 队列里面，然后编写一个简单的缓存删除<br>消息者订阅 binlog 日志，根据更新 log 删除缓存，并且通过 ACK 机制确认处理这条更新 log,保证数据缓存一致性。</p>
<p>总结：<br>综上所述，在分布式系统中，缓存和数据库同时存在时，如果有写操作的时候，「 先操作数据库，再操作缓存 」</p>
<p>参考：「 <a href="https://www.cnblogs.com/crazymakercircle/p/14853622.html">https://www.cnblogs.com/crazymakercircle/p/14853622.html</a> 」</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>基本的数据结构和算法</title>
    <url>/posts/d92d1b7b/</url>
    <content><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h1 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.queue = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.queue.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.stack.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;出栈&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = Stack()</span><br><span class="line">    s.push(<span class="number">1</span>)</span><br><span class="line">    s.push(<span class="number">2</span>)</span><br><span class="line">    s.push(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.stack)</span><br><span class="line"></span><br><span class="line">    s.pull()</span><br><span class="line">    <span class="built_in">print</span>(s.stack)</span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">chain</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        node.<span class="built_in">next</span> = self.head</span><br><span class="line">        self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(cur.data, end=<span class="string">&#x27;-***-&#x27;</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self,index,data</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            self.add(data)</span><br><span class="line">        <span class="keyword">elif</span> index &gt; self.length() -<span class="number">1</span>:</span><br><span class="line">            self.append(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index - <span class="number">1</span>):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            node = Node(data)</span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.data == data:</span><br><span class="line">                <span class="keyword">if</span> cur == self.head:</span><br><span class="line">                    self.head = self.head.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span> <span class="comment">#前节点等于后节点</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.data == data:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;数据%f存在于链表中&quot;</span> % cur.data)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;数据不存在于链表中&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote>
<p>递归就是不断调用函数本身</p>
</blockquote>
<h3 id="阶乘-1-2-3-N"><a href="#阶乘-1-2-3-N" class="headerlink" title="阶乘 1 * 2 * 3....*N"></a>阶乘 <code>1 * 2 * 3....*N</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rescuvie</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * rescuvie(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>递归使用了运算符，每次重复的调用都使得运算的链条不断加长，系统不得不使用栈进行数据保存和恢复<br>如果每次递归都要对越来越长的链条进行运算，那速度极慢，并且可能栈溢出，导致程序崩溃</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><blockquote>
<p>尾部递归是指递归函数在调用自身后直接传回其值，而不对其再加运算，效率将会极大的提高。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rescurieTail</span>(<span class="params">n, a</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">return</span> rescurieTail(n-<span class="number">1</span>, a*n)</span><br></pre></td></tr></table></figure>


<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><a href="https://blog.csdn.net/weixin_42702038/article/details/106744386">https://blog.csdn.net/weixin_42702038/article/details/106744386</a></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote>
<p>首先在未排序的序列中找到最小（大）元素，存放在排序序列的起始位置，然后在剩余的列表中查找，依次放入到新列表中。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找出最小元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_smallest_item</span>(<span class="params">arr</span>):</span></span><br><span class="line">    smallest = arr[<span class="number">0</span>]</span><br><span class="line">    smallest_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; smallest:</span><br><span class="line">            smallest = arr[i]</span><br><span class="line">            smallest_index = i</span><br><span class="line">    <span class="keyword">return</span> smallest_index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    new_arr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        smallest_index = find_smallest_item(arr)</span><br><span class="line">        new_arr.append(arr.pop(smallest_index))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(select_sort([<span class="number">4</span>, <span class="number">324</span>, <span class="number">42</span>, <span class="number">45</span>, <span class="number">2435</span>, <span class="number">2</span>, <span class="number">2</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>分而治之的思想</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快速排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="comment"># 基准的选择</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = arr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        less_arr = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">        greater_arr = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quick_sort(less_arr) + [pivot] + quick_sort(greater_arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(quick_sort([<span class="number">2</span>, <span class="number">3</span>, <span class="number">49</span>, <span class="number">10</span>, <span class="number">24</span>, <span class="number">3</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote>
<p>冒泡排序思想：遍历整个数据列表，在一组数据中，每遍历比较一次数据，最大的数便会”冒泡”到数据列表右端</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binaray_search</span>(<span class="params">li, item</span>):</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(li) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:  <span class="comment"># 确定范围</span></span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        guess = li[mid]</span><br><span class="line">        <span class="keyword">if</span> guess == item:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> guess &gt; item:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(binaray_search([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">6</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊传输层协议- TCP 协议</title>
    <url>/posts/ac41cac4/</url>
    <content><![CDATA[<h1 id="什么是-TCP-协议？"><a href="#什么是-TCP-协议？" class="headerlink" title="什么是 TCP 协议？"></a>什么是 TCP 协议？</h1><blockquote>
<p>首先，TCP 协议是位于 <code>传输层</code>的协议，是<code>面向连接的</code>、<code>可靠的</code>流协议<br>TCP 为了提高可靠性传输，实行<code>顺序控制</code>或<code>重发控制</code>。此外还有<code>流量控制</code>、<code>拥塞控制</code>、<code>提高网络利用率</code>等众多功能</p>
</blockquote>
<p>下面，就从 TCP 协议的这些特点说开去：</p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><blockquote>
<p>TCP 协议是如何实现传输过程中的可靠性，又是怎么实现的？<br>一句话概括：<strong>TCP 通过 校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输</strong>。<br>接下来，将引入包的传递过程，来带入这些概念：</p>
</blockquote>
<p>ack - 校验和</p>
<blockquote>
<p>客户端和服务端之间通过校验随机数+1，来确认连接</p>
</blockquote>
<p>ACK - 确认应答</p>
<blockquote>
<p>客户端和服务端使用确认应答 ACK 来知道二者的连接请求。</p>
</blockquote>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><blockquote>
<p>TCP 是提供面向连接的通信传输。面向连接指的就是在数据通信开始之前先建立连接，确保传输通道的连通性。<br>而所谓三次握手就是建立一个 TCP 连接时需要 客户端和服务端总共发送三个包以确认连接的建立</p>
</blockquote>
<p>这里引入三次握手来解释相关概念：<strong>校验和（ack）&amp;&amp; 确认应答（ACK）</strong></p>
<p>流程图：<br><img src="/images/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="direct"></p>
<p>第一次握手：客户端将标志位 <code>SYN = 1</code>，随机生成一个值 <code>seq = j</code>，并将该数据包发送给服务端，客户端进入 <code>SUN_SENT</code> 状态，等待客户端的确认。<br>第二次握手：服务端接收到 <code>SYN = 1</code>的数据包后，明确客户端请求建立连接，服务端将标志位<code>SYN = 1、ACK=1</code>，随机生成一个随机数 <code>seq=k</code>，<strong>校验和 ack=j+1</strong>，并将该数据包发送给客户端以确认连接请求，服务器进入<code>SYN_RCVD</code>状态。<br>第三次握手：客户端收到确认后，检查<code>检验和 ack = j+1</code>,ACK=1。如果正确将标志位 ACK = 1 。<strong>校验和 ack = k+1</strong>,并将该数据包发送给服务器端，服务器端检查 <strong>检验和 ack = k+1,ACK=1</strong>,如果正确则连接建立成功，客户端和服务器端进入<code>ESTABLISHED</code>状态，完成三次握手，随后便可以开始通信了。</p>
<h3 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h3><blockquote>
<p>在数据的传输中，可能存在<code>数据包丢失</code>或者<code>未收到确认应答</code>的情况，此时为了实现<code>可靠传输</code>,就会触发<strong>重发机制</strong>。<br>但是，也会有部分原因导致确认应答延迟到达，数据包实际上已经到达来服务端，那么服务端就会反复的接收到相同的数据包，为了避免这种情况，就会有<strong>重复控制</strong>功能。</p>
</blockquote>
<p>上述<strong>确认应答机制</strong>、<strong>重发控制</strong>以及<strong>重复控制</strong>等功能都可以借助<strong>序列号</strong>来实现。</p>
<blockquote>
<p>序列号是按顺序给发送数据的每一个字节（8位字节）都标上号码的编号。将自己下一步应该接收的序列号作为确认应答返送回去。<br><img src="/images/%E5%BA%8F%E5%88%97%E5%8F%B7.png" alt="direct"></p>
</blockquote>
<p>通过序列号和确认应答号，TCP 就可以实现顺序传输和可靠传输</p>
<h2 id="重发超时如何确定"><a href="#重发超时如何确定" class="headerlink" title="重发超时如何确定"></a>重发超时如何确定</h2><blockquote>
<p>当发送端发送数据后，会有一个等待确认应答到来的<strong>特定时间间隔</strong>。若超过了这个时间仍未收到确认应答，发送端将数据进行数据重发。</p>
</blockquote>
<p>然而这个重发超时时间的确定是根据当前的网络环境确认的，随着网络环境的不同而有所变化。</p>
<p>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。<br>它在每次发包时都会计算<code>往返时间</code>及其<code>偏差</code>。</p>
<p>重发超时的值就是比<code>往返时间</code>和<code>偏差</code>相加大一点的值，由于数据包的分段是经过不同路线到达的，所以网络环境的往返时间可能会产生大幅度的摇摆。</p>
<p>TCP/IP 的目的就是即使在这种环境下也要进行控制，避免流量的浪费。</p>
<p><img src="/images/%E9%87%8D%E5%8F%91%E8%B6%85%E6%97%B6.png" alt="direct"></p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><blockquote>
<p>TCP 提供面向有连接的通信传输。面向有连接的是指在数据通信开始之前先做好通信两端之间的准备工作。<br>这里通常是指<code>三次握手和四次挥手</code><br><img src="/images/%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86.png" alt="direct"></p>
</blockquote>
<h2 id="TCP-发送数据的单位：段"><a href="#TCP-发送数据的单位：段" class="headerlink" title="TCP 发送数据的单位：段"></a>TCP 发送数据的单位：段</h2><blockquote>
<p>在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们称为<strong>最大消息长度</strong>（MSS: Maximum Segment Size）。<br>最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。</p>
</blockquote>
<h4 id="MSS-的计算方式"><a href="#MSS-的计算方式" class="headerlink" title="MSS 的计算方式"></a>MSS 的计算方式</h4><p>MSS 是在三次握手的时候，在两端主机之间被计算出。两端主机在建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 大小。<br>MSS 的大小就会在两者之间选择一个较小的值。</p>
<p><img src="/images/MSS%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F.png" alt="direct"></p>
<h2 id="窗口控制提高速度"><a href="#窗口控制提高速度" class="headerlink" title="窗口控制提高速度"></a>窗口控制提高速度</h2><blockquote>
<p>TCP 以 1 个段为单位，每发送一个段就进行一次确认应答的处理。但是这样传输的话，包的往返时间越长性能也就越低。<br>为了解决这个问题，TCP 就引入了窗口这个概念。即使在往返时间较长的情况下，它也能控制网络性能的下降。</p>
</blockquote>
<p><strong>确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅度的缩短</strong><br><img src="/images/%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6.png" alt="direct"></p>
<h2 id="重发控制"><a href="#重发控制" class="headerlink" title="重发控制"></a>重发控制</h2><blockquote>
<p>窗口控制中的重发控制，是以序列号进行管理的，当数据包丢失后，发送端会根据接收端序列号来进行重发<br><img src="/images/%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%9A%84%E9%87%8D%E5%8F%91.png" alt="direct"></p>
</blockquote>
<h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><blockquote>
<p>为了防止网络流量的无端浪费（接收端数据的处理）,TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。</p>
</blockquote>
<p>接收端告诉发送端自己接收的数据大小，实际上就是该窗口大小。<br><img src="/images/%E6%B5%81%E6%8E%A7%E5%88%B6.png" alt="direct"></p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><blockquote>
<p>一般来说，计算机网络都处在一个共享的环境，因此也有坑因为其他主机之间的通信使得网络拥堵。<br>所以，如果一开始发送端就发送一个特大的数据包，可能会导致整个网络的瘫痪。<br>为了防止这个问题，TCP 在通信一开始时，就会通过一个叫做慢启动的算法得出的数值，对发送数据量进行控制。</p>
</blockquote>
<p>首先，为了在发送端调节所要发送的数据的量，定义了一个叫做<code>拥塞窗口</code>的概念。在慢启动的时候，将这个拥塞窗口的大小设置为一个数据段（1 MSS）发送数据，<br>之后每收到一次确认应答（ACK）,拥塞窗口的值就加一。<br>不过，随着包的每次往返，拥塞窗口也会以 1、2、4 等指数函数的增长，拥堵状况激增甚至导致网络拥塞的发生。为了防止这些，又引入了慢启动阈值的概念。<br>只允许按照特定比例放大拥塞窗口：</p>
<p>1 个数据段的字节数/拥塞窗口（字节）* 1 个数据段字节数</p>
<p><img src="/images/%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3.png" alt="direct"></p>
<p>于是，当 TCP 通信开始以后，网络的吞吐量会 逐步上升，但是随着网络拥堵的发生吞吐量也会极速下降。<br>接着，会再次进入吞吐量慢慢上升的过程。因此所谓 TCP 的吞吐量的特点就像是在逐步占领网络带宽的感觉。</p>
<p>参考：1.「 图解 TCP/IP 」2. 「 TCP/IP 卷一 」</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式-Python 实现</title>
    <url>/posts/26a37a49/</url>
    <content><![CDATA[<h1 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式 ?"></a>什么是单例模式 ?</h1><blockquote>
<p>单例模式（Singleton Pattern）是软件设计中的一种常用设计模式，其目的是在一个进程中，确保某一个类(class)只有一个实例(instance)存在。<br>例如，当我们在操作数据库时，多个服务都要调用数据库的 connection ，其配置信息都是相同的，这种情况就可以使用单例模式。在该系统中，只使用一个用于连接数据库的 connection 实例</p>
</blockquote>
<h2 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a>单例模式的实现方式</h2><h3 id="1-模块构建"><a href="#1-模块构建" class="headerlink" title="1. 模块构建"></a>1. 模块构建</h3><blockquote>
<p><strong>Python 的模块就是天然的单例模式</strong>，模块在第一次导入的时候，会生成 <code>.pyc</code> 文件，就会直接加载<code>.pyc</code>文件，而不会再次执行模块<br>因此，我们只需要把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。</p>
</blockquote>
<p><strong>Singleton.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">singleton = Singleton()</span><br></pre></td></tr></table></figure>
<p>当我们需要使用这个 instance 的时候，直接使用即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Singleton <span class="keyword">import</span> singleton</span><br></pre></td></tr></table></figure>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><blockquote>
<p>使用 dict 类型，以 key-value 方式存储类的实例和运行的函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span>(<span class="params">cls</span>):</span></span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_singleton</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> _instance:</span><br><span class="line">            _instance[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> _instance[cls]</span><br><span class="line">    <span class="keyword">return</span> _singleton</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">a1 = A(<span class="number">1</span>)</span><br><span class="line">a2 = A(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a1 <span class="keyword">is</span> a2)</span><br></pre></td></tr></table></figure>
<h3 id="类方法实现"><a href="#类方法实现" class="headerlink" title="类方法实现"></a>类方法实现</h3><blockquote>
<p>使用方法 <code>hasattr</code> 方法判断类中是否已实现了对应的实例方法，实现了就直接返回，未返回就添加单例属性</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line">obj = Singleton.instance()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="多线程场景"><a href="#多线程场景" class="headerlink" title="多线程场景"></a>多线程场景</h3><p>但是在<code>多线程</code>的使用中，由于每个线程有自己的数据资源，所以会<code>存在问题</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">arg</span>):</span></span><br><span class="line">    obj = Singleton.instance()</span><br><span class="line">    <span class="built_in">print</span>(obj) <span class="comment"># 显示 instance 的详情信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=task,args=[i,])</span><br><span class="line">    t.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上的实例显示出的详情可以看到 obj 的 id 并不一致，解决办法就是加 <code>锁</code>(mutex)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">with</span> Singleton.lock:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> Singleton._instance</span><br></pre></td></tr></table></figure>
<p>以上实现方式对整个实例的创建过程都进行了加锁，可以进行优化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                <span class="keyword">with</span> Singleton.lock:</span><br><span class="line">                    Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> Singleton._instance</span><br></pre></td></tr></table></figure>
<p>但是这样的实现方式，需要借助 <code>instance 方法</code></p>
<h3 id="new-方法实现"><a href="#new-方法实现" class="headerlink" title="__new__ 方法实现"></a><code>__new__</code> 方法实现</h3><blockquote>
<p>一个类在被实例化的过程中，先是执行默认的<code>__new__</code> 方法，然后再执行<code>__init__</code>方法初始化对象</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            <span class="keyword">with</span> cls._instance_lock:</span><br><span class="line">                cls._instance = <span class="built_in">super</span>.__new__(cls)</span><br><span class="line">            <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure>

<h3 id="metaclass-方式实现"><a href="#metaclass-方式实现" class="headerlink" title="metaclass 方式实现"></a><code>metaclass</code> 方式实现</h3><blockquote>
<ol>
<li>类由 <code>type</code>创建，创建类时，type 的 <code>__init__</code> 方法自动执行，类() 的方式执行<code>type</code> 的<code>__call__</code>方法（类的 <strong>new__、__init</strong> 方法）</li>
<li>对象由类创建，创建对象时，类的 <code>__init__</code> 方法自动执行，对象()执行类的<code>__call__</code> 方法</li>
</ol>
</blockquote>
<p>其实，我们就是要保证在创建类的时候，保证这个类只有一个实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonType</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    _instance_lock = threading.Lock</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            <span class="keyword">with</span> SingletonType._instance_lock:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                    cls._instance = <span class="built_in">super</span>.__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">                </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">metaclass=SingletonType</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观锁与悲观锁-Python 实现</title>
    <url>/posts/102bc233/</url>
    <content><![CDATA[<h1 id="Python-乐观锁与悲观锁"><a href="#Python-乐观锁与悲观锁" class="headerlink" title="Python 乐观锁与悲观锁"></a>Python 乐观锁与悲观锁</h1><p>参考：<a href="https://xie.infoq.cn/article/2085a95ad6b486d3905adc7d6">https://xie.infoq.cn/article/2085a95ad6b486d3905adc7d6</a></p>
<blockquote>
<p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题</p>
</blockquote>
<h2 id="什么是乐观锁-？"><a href="#什么是乐观锁-？" class="headerlink" title="什么是乐观锁 ？"></a>什么是乐观锁 ？</h2><blockquote>
<p>乐观锁在操作数据时采用乐观的态度，认为不会出现多个操作数据的事件。因此乐观锁不糊上锁，只是在进行更新操作的时候<br>判断该期间是否同时存在修改了数据的情况：若在修改时数据已被修改则放弃操作，否则继续执行操作。</p>
</blockquote>
<h2 id="乐观锁的实现"><a href="#乐观锁的实现" class="headerlink" title="乐观锁的实现"></a>乐观锁的实现</h2><blockquote>
<ol>
<li>CAS 机制。2.版本号机制。这里将采用 python + orm 的实现方式</li>
</ol>
</blockquote>
<h3 id="CSA-Compare-and-Swap"><a href="#CSA-Compare-and-Swap" class="headerlink" title="CSA (Compare and Swap)"></a>CSA (Compare and Swap)</h3><p>CSA 的操作主要包括了 3 个操作数：</p>
<ul>
<li>需要读写的内存位置(V)</li>
<li>进行比较的预期值(A)</li>
<li>拟写入的新值(B)<br>具体的操作逻辑为：若内存位置的值等于预期的 A 值，则将该位置更新为新值 B, 否则不进行任何操作。<br>直到重试次数消耗完毕。<h3 id="CSA-实现"><a href="#CSA-实现" class="headerlink" title="CSA 实现"></a>CSA 实现</h3><blockquote>
<p>乐观锁（Optimistic Lock）,适用于多读</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"><span class="keyword">from</span> 应用名.models <span class="keyword">import</span> GoodsSKU</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类视图 (并发，乐观锁)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>(<span class="params">View</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @transaction.atomic</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;订单创建&#x27;&#x27;&#x27;</span></span><br><span class="line">        count = <span class="number">3</span>  <span class="comment"># 订购3件商品</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置事务保存点</span></span><br><span class="line">        s1 = transaction.savepoint()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 乐观锁，最多尝试5次</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="comment"># 查询商品的信息(库存)</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                sku = GoodsSKU.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="comment"># 商品不存在</span></span><br><span class="line">                transaction.savepoint_rollback(s1)</span><br><span class="line">                <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;res&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;errmsg&#x27;</span>: <span class="string">&#x27;商品不存在&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断商品的库存</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; sku.stock:</span><br><span class="line">                transaction.savepoint_rollback(s1)</span><br><span class="line">                <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;res&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;errmsg&#x27;</span>: <span class="string">&#x27;商品库存不足&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新商品的库存和销量</span></span><br><span class="line">            orgin_stock = sku.stock  <span class="comment"># 原库存 (数据库隔离级别必须是Read Committed；如果是Repeatable Read,那么多次尝试读取的原库存都是一样的,读不到其他线程提交更新后的数据。)</span></span><br><span class="line">            new_stock = orgin_stock - count  <span class="comment"># 更新后的库存</span></span><br><span class="line">            new_sales = sku.sales + count  <span class="comment"># 更新后的销量</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># update 商品表 set stock=new_stock, sales=new_sales where id=1 and stock = orgin_stock</span></span><br><span class="line">            <span class="comment"># 通过where子句中的条件判断库存是否进行了修改。(并发，乐观锁)</span></span><br><span class="line">            <span class="comment"># 返回受影响的行数</span></span><br><span class="line">            res = GoodsSKU.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">1</span>, stock=orgin_stock).update(stock=new_stock, sales=new_sales)</span><br><span class="line">            <span class="keyword">if</span> res == <span class="number">0</span>:  <span class="comment"># 如果修改失败</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">                    <span class="comment"># 如果尝试5次都失败</span></span><br><span class="line">                    transaction.savepoint_rollback(s1)</span><br><span class="line">                    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;res&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;errmsg&#x27;</span>: <span class="string">&#x27;下单失败&#x27;</span>&#125;)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># 再次尝试</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 否则更新成功</span></span><br><span class="line">            <span class="comment"># 跳出尝试循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提交事务</span></span><br><span class="line">        transaction.savepoint_commit(s1)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回应答</span></span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;res&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;创建成功&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="什么是悲观锁"><a href="#什么是悲观锁" class="headerlink" title="什么是悲观锁 ?"></a>什么是悲观锁 ?</h2><p>悲观锁在操作数据的时候，比较悲观，认为别人会同时修改数据。<br>因此操作数据时会直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据</p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>例如，有用户 A 和用户 B，在同一家店铺去购买同一个商品，但是商品的可购买数量只有一个<br><img src="/images/img.png" alt="direct"></p>
<p>若，用户 A 和用户 B 同时下单，就会报错。<br>悲观锁的实现，往往依靠数据库提供的锁机制，在数据库中，我们如何用悲观锁去结局这个事情呢？</p>
<ol>
<li>用户 A 在执行购买商品的时候，先尝试对该商品加上悲观锁。</li>
<li>若加锁失败，说明商品正在被其他事务进行修改，当前查询需要等待或者抛出异常，具体返回的方式需要开发者根据具体情况去定义</li>
<li>加锁成功：对商品进行修改</li>
<li>在此期间如果有其他用户对数据做修改或加锁的操作，都会等待我们解锁后或直接抛出异常<br><img src="/images/img_1.png" alt="direct"></li>
</ol>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>那么如何加上悲观锁呢，1. 首先关闭 MySQL 数据库的自动提交属性。因为 MySQL 默认使用 autocommit 模式（默认提交）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set autocommit = 0;</span><br></pre></td></tr></table></figure>
<p>悲观锁加锁 sql 语句： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select num form t_goods where id = 2 for update</span><br></pre></td></tr></table></figure>
<p>此时，其他事务都不能获取到此行的数据去进行操作。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 如何实现装饰器？</title>
    <url>/posts/e67a2035/</url>
    <content><![CDATA[<h1 id="Python-如何实现一个装饰器"><a href="#Python-如何实现一个装饰器" class="headerlink" title="Python 如何实现一个装饰器"></a>Python 如何实现一个装饰器</h1><blockquote>
<p>首先，装饰器为调用高阶函数提供了一种简单的语法<br>根据定义，装饰器是一个函数，它接受另外一个函数并在其基础功能上做统一的扩展</p>
</blockquote>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote>
<p>对于 Python 来说，一切皆对象，对象也是可以作为参数传递，这就是装饰器实现的基础</p>
</blockquote>
<p>例如，我想实现一个<code>日志打印</code>功能，调用对应方法或者对象时，可以显示其运行的信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> running&quot;</span>, )</span><br><span class="line">    func()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> ended&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    printer(task)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里我们实现了<code>task</code> 方法，在调用这个方法的时候，会显示调用的相关信息。</p>
<p>可以看到我们使用<code>printer</code> 这个功能的时候，都是采用<code>printer(func)</code>的方式，如果在多处使用的话，<br>那么有没有比较简单的方式，例如在执行<code>task</code>方法的时候，自动去触发<code>printer</code>呢，还能像调用原方法一样？</p>
<p>于是, 我们可以将该方法当成一个参数传递后，返回一个新的对象调用的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> running&quot;</span>, )</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> ended&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run&quot;</span>)</span><br><span class="line"></span><br><span class="line">task = printer(task)</span><br><span class="line">task()</span><br></pre></td></tr></table></figure>

<p>Python 中<code>允许在一个方法中嵌套另外一个方法</code>，这种特殊的机制就是<strong>闭包</strong>。<br>这个内部方法可以保留外部方法的作用域，内部方法也可以访问到外部方法的参数和变量。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><blockquote>
<p>python 支持一种装饰器语法糖「@」，使用这个语法糖，我们也可以实现与上面完全相同的功能</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@printer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run &quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h2><blockquote>
<p>现在我们已经知道，装饰器其实就是先定义好一个闭包，然后使用语法糖<code>@</code>来装饰方法，最后达到重新定义方法的作用<br>但是这样使用的方法其实最终执行的是 <code>inner</code> 方法</p>
</blockquote>
<p>like: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@printer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(task.__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: inner</span></span><br></pre></td></tr></table></figure>
<p>如何解决这个问题？</p>
<p>python 其实有内置的 functools 模块，提供了一个 <code>wraps</code> 方法，专门来解决这个问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> running&quot;</span>, )</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> ended&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@logger</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(task.__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># hello</span></span><br></pre></td></tr></table></figure>

<h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>装饰器当然也可以传入参数，例如：<code>*args</code>、<code>**kwargs</code><br>例如使用装饰器来计算程序的运行时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span>(<span class="params">prefix</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            start = time.time()</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">            end = time.time()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s: duration time: %ds&#x27;</span> % (prefix, <span class="built_in">int</span>(end - start)))</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@timeit(<span class="params"><span class="string">&#x27;prefix1&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello %s&#x27;</span> % name)</span><br></pre></td></tr></table></figure>
<h2 id="装饰器模版"><a href="#装饰器模版" class="headerlink" title="装饰器模版"></a>装饰器模版</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># do something</span></span><br><span class="line">        value = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<h2 id="类实现装饰器"><a href="#类实现装饰器" class="headerlink" title="类实现装饰器"></a>类实现装饰器</h2><p><code>__call__</code> 魔法方法结合类也可以实现装饰器</p>
<p>这里也给出一个通用模版</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self, params</span>):</span></span><br><span class="line">        self.params = params</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="comment"># do something</span></span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@Decorator(<span class="params"><span class="string">&#x27;params&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="装饰器的使用场景"><a href="#装饰器的使用场景" class="headerlink" title="装饰器的使用场景"></a>装饰器的使用场景</h2><h3 id="记录调用日志"><a href="#记录调用日志" class="headerlink" title="记录调用日志"></a>记录调用日志</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="comment"># 记录调用日志</span></span><br><span class="line">            logging.getLogger().setLevel(logging.INFO)</span><br><span class="line">            logging.info(<span class="string">&#x27;call method: %s %s %s&#x27;</span>, func.__name__, args, kwargs)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Logger(<span class="params"><span class="string">&#x27;airflow&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;run <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    task(name=<span class="string">&quot;task&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="路由映射"><a href="#路由映射" class="headerlink" title="路由映射"></a>路由映射</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.url_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">func</span>):</span></span><br><span class="line">            self.url_map[url] = func</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        func = self.url_map.get(url)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> func:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;No url function: %s&#x27;</span>, url)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router = Router()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.register(<span class="params"><span class="string">&#x27;/page1&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page1</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page1&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(router.call(<span class="string">&#x27;page1&#x27;</span>))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 常用的魔法方法</title>
    <url>/posts/c0462762/</url>
    <content><![CDATA[<h2 id="Python-常用魔法方法"><a href="#Python-常用魔法方法" class="headerlink" title="Python 常用魔法方法"></a>Python 常用魔法方法</h2><p><a href="https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id2">https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id2</a></p>
<blockquote>
<p>为了实现更好的可扩展性，Python 语言提供了大量的特殊方法，它们大致可分为以下几类：</p>
<ul>
<li><p>特性访问（Attribute Access）这类特殊方法实现了对象的特性访问，使用方法为 <code>object.attribute</code> ，既可以用来赋值，也可以在 del 语句中执行删除操作。</p>
</li>
<li><p>可调用对象（Callables）: 这个方法的适用对象为参数，就像 Python 内部的 len() 函数</p>
</li>
<li><p>集合（Collections）这类方法提供了很多集合操作的功能。类似这类方法的使用有 sequence[index]、mapping[key] 和 some_set | another_set</p>
</li>
<li><p>数字（Numbers）: 这类方法提供了大量的数学运算符和比较运算符。</p>
</li>
<li><p>上下文(Context)：这类函数通常使用 with 语句来实现上下文的管理</p>
</li>
<li><p>迭代器(Iterator)：可以使用这类方法定义迭代器</p>
</li>
</ul>
</blockquote>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="new"><a href="#new" class="headerlink" title="__new__"></a><code>__new__</code></h3><p>在我们调用 <code>x=SomeClass()</code> 的时候，<code>__init__</code> 并不是第一个被调用的方法，事实上，第一个被调用的是 <code>__new__</code> ，这个方法才真正地创建了实例。当这个对象的生命周期结束的时候，<code>__del__</code> 会被调用。</p>
<ul>
<li><p><code>__new__(cls, [...])</code></p>
<p><code>__new__</code> 是对象实例化时第一个调用的方法，它只取下 <code>cls</code> 参数，并将其它参数传给 <code>__init__</code> 。<code>__init__</code> 很少使用，但是它也有它合适的场景，尤其是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。但是其并不是很有用。</p>
</li>
</ul>
<h3 id="init"><a href="#init" class="headerlink" title="__init__"></a><code>__init__</code></h3><ul>
<li><p>对象的初始化</p>
</li>
<li><p><code>__init__</code> 方法的参数可以多种形式来完成赋值</p>
</li>
</ul>
<blockquote>
<p>object 类是所有类的基类，对于任何自定义类，都会隐式继承 object。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">X.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">type</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">X</span>.<span class="title">__class__</span>.<span class="title">__base__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">object</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>对于每个 <code>__init__</code>方法，都应当显式地指定要初始化的变量。</strong></p>
<h3 id="del"><a href="#del" class="headerlink" title="__del__"></a><code>__del__</code></h3><p><code>__new__</code> 和 <code>__init__</code> 是对象的构造器，<code>__del__</code>是对象的销毁器。它并非实现了语句 del x</p>
<p>而是定义了当对象被垃圾回收时的行为。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># __new__ 方法实现单例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    init_flag = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> SingleNode.init_flag:</span><br><span class="line">            self.do_something()</span><br><span class="line">            SingleNode.init_flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;do something...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    single = SingleNode()</span><br><span class="line">    <span class="built_in">print</span>(single, <span class="built_in">id</span>(single))</span><br><span class="line">    single2 = SingleNode()</span><br><span class="line">    <span class="built_in">print</span>(single2, <span class="built_in">id</span>(single))</span><br></pre></td></tr></table></figure>

<h2 id="自定义序列"><a href="#自定义序列" class="headerlink" title="自定义序列"></a>自定义序列</h2><p>有许多办法可以让你的 Python 类表现得像是内建序列类型（字典，元组，列表，字符串等）</p>
<p>在 Python 中，协议完全是非正式的，也不需要显式的声明，事实上，它们更像是一种参考标准。</p>
<p>在 Python 中实现自定义容器类型需要用到一些协议。首先，不可变容器类型有如下协议：想实现一个不可变容器，你需要定义<code>__len__</code> 和 <code>__getitem__</code> 。可变容器的协议除了上面提到的两个方法之外，还需要定义 <code>__setitem__</code> 和 <code>__delitem__</code> 。最后，如果你想让你的对象可迭代，你需要定义<code>__iter__</code>,这个方法返回一个迭代器。迭代器必须遵守迭代器协议，需要定义 <code>__iter__</code> 和 next 方法。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li><p><code>__len__(self)</code></p>
<p>返回容器的长度，可变和不可变类型都需要实现</p>
</li>
<li><p><code>__getitem__(self, key)</code></p>
<p>定义对容器中某一项使用 <code>self[key]</code> 的方式读取操作时的行为。这也是可变和不可变容器类型都需要实现的一个方法。它应该在键的类型错误时产生 TypeError 异常，同时在没有与键值相匹配的内容时产生 KeyError 异常</p>
</li>
<li><p><code>__setitem__(self, key)</code></p>
<p>定义对容器中某一项使用 self[key] 的方式进行赋值操作时的行为。它是可变容器类型必须实现的一个方法，同样应该在合适的时候产生 KeyError 和 TypeError 异常</p>
</li>
<li><p><code>__iter__</code></p>
<p>它应该返回当前容器的一个迭代器。迭代器以一连串内容的形式返回，最常见的是使用 </p>
<p><code>iter()</code> 函数调用，以及在类似 for x in container 的循环中被调用。</p>
</li>
<li><p><code>__reversed__(self)</code></p>
<p>定义了对容器使用 <code>reversed()</code> 内建函数时的行为。它应该返回一个反转之后的序列。</p>
</li>
<li><p><code>__contains__(self, item)</code> </p>
<p>定义了使用 in 和 not in 进行成员测试时的行为。</p>
</li>
<li><p><code>__missing__(self, key)</code> </p>
<p><code>__missing__</code> 在字典的子类中使用，它定义了当试图访问一个字典中不存在的键的行为。例如 d[“george”] 中不存在 george key 时，就会调用 <code>d.__missing__</code></p>
</li>
</ul>
<h2 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h2><p>使用 Python 魔法方法的一个巨大优势就是可以构建一个拥有 Python 内置类型行为的对象。这意味着你可以避免使用非标准的、丑陋的方式来表达简单的操作。</p>
<ul>
<li><code>__cmp__</code>是所有比较魔法方法中最基础的一个，它实际上定义了所有比较操作符的行为（&lt;, ==, != 等等）</li>
<li><code>__lt__</code> <code>__le__()</code> <code>__eq__</code> <code>__ne__</code> <code>__gt__()</code> <code>__get__</code></li>
</ul>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><blockquote>
<p>Python 不是通过显式定义的字段和方法修改器，而是通过魔法方法实现了一系列的封装</p>
</blockquote>
<ul>
<li><p><code>_getattr__(self, name)</code></p>
<p>当用户试图访问一个根本不存在的属性时，你可以通过这个魔法方法来定义类的行为。这个可以用于捕捉错误的拼写并且给出指引。只有当试图访问不存在的属性时它才会被调用。</p>
</li>
<li><p><code>__setattr__(self, name, value)</code></p>
<p>它可以用于真正意义上的封装。允许你自定义某个属性的赋值行为，不管这个属性存在与否，也就是说你可以对任意属性的任何变化都定义自己的规则。</p>
</li>
<li><p><code>__delattr__(self, name)</code></p>
<p>用于处理删除属性时的行为。和 <code>__setattr__</code>一样，使用它时也需要多加小心，防止产生无限递归</p>
</li>
<li><p><code>__getattribute__</code>看起来和上面那些方法很合得来，但是最好不要使用它。</p>
<p>允许你自定义属性被访问时的行为，它也同样可能遇到无限递归问题。<code>__getattribute__</code>基本上可以替代<code>__getattr__</code> 只有当它被使用，并且显式地被调用，或者产生 AttributeError 时它才被调用。不推荐被使用</p>
</li>
</ul>
<h2 id="与-Python-无缝集成——基本特殊方法"><a href="#与-Python-无缝集成——基本特殊方法" class="headerlink" title="与 Python 无缝集成——基本特殊方法"></a>与 Python 无缝集成——基本特殊方法</h2><blockquote>
<p>Python 中有一些特殊方法，它们允许我们的类和 Python 更好地集成。在标准库参考中，它们被称为<strong>基本特殊方法</strong>，是与 Python 的其他特性无缝集成的基础</p>
<p>例如：</p>
<ul>
<li><code>__repr__</code> <code>__str__</code> 标准化表示对象的值</li>
<li><code>__hash__</code> <code>__bool__</code> <code>__byts__</code> 转换方法</li>
<li><code>__lt__</code> <code>__le__()</code> <code>__eq__</code> <code>__ne__</code> <code>__gt__()</code> <code>__get__</code></li>
<li><code>__new__</code> <code>__del__</code></li>
</ul>
</blockquote>
<h3 id="repr-amp-amp-str-方法"><a href="#repr-amp-amp-str-方法" class="headerlink" title="__repr__&amp;&amp; __str__ 方法"></a><code>__repr__</code>&amp;&amp; <code>__str__</code> 方法</h3><blockquote>
<p>对于一个对象，Python 提供了两种字符串表示方法。它们和内建函数 <code>repr()</code> <code>str()</code> <code>print</code> <code>string.format()</code> 功能是一致的</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/1436703/what-is-the-difference-between-str-and-repr">https://stackoverflow.com/questions/1436703/what-is-the-difference-between-str-and-repr</a></p>
<ul>
<li><p>通常，<code>str()</code> 方法表示的对象对用户更加友好。这个方法是由对象的 <code>__str__</code> 方法实现的</p>
</li>
<li><p><code>repr()</code> 方法的表示通常会更加技术化，甚至有可能是一个完整的 Python 表达式</p>
</li>
<li><p>容器 <code>__str__</code> 使用包含的对象 <code>__repr__</code></p>
</li>
</ul>
<p>默认情况下，二者的行为一致</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import datetime</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; today = datetime.datetime.now()</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; str(today)</span></span><br><span class="line">&#x27;2012-03-14 09:21:58.130922&#x27;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; repr(today)</span></span><br><span class="line">&#x27;datetime.datetime(2012, 3, 14, 9, 21, 58, 130922)&#x27;</span><br></pre></td></tr></table></figure>



<h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><p>上下文管理的概念在 Python 中并不是全新引入的（之前它作为标准库的一部分实现），直到 PEP 343 才被接受，它才成为一种一级的语言结构</p>
<p>类似：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>. <span class="built_in">open</span>(<span class="string">&quot;f.txt&quot;</span>) <span class="keyword">as</span> bar:</span><br><span class="line">  f.read()</span><br></pre></td></tr></table></figure>

<p>当对象使用 with 声明创建时，上下文管理器允许类做一些设置和清理工作。上下文管理器的行为由下面两个魔法方法所定义：</p>
<ul>
<li><p><code>__enter__</code></p>
<p>定义使用 with 声明创建的语句块最开始上下文管理器应该做些什么。<code>__enter__</code> 的返回值会赋给 with 声明的目标，也就是 as 之后的东西。</p>
</li>
<li><p><code>__exit__</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContext</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="comment"># __enter__的返回值被as后面的变量接收</span></span><br><span class="line">        self.name = <span class="string">f&#x27;Big <span class="subst">&#123;self.name&#125;</span>&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">		<span class="comment"># __exit__在with中的语句结束之后立即执行</span></span><br><span class="line">		<span class="comment"># 假如with管辖的上下文内没有抛出任何异常，当解释器出发__exit__方法时，其三个参数都为None，如果有异常抛出则三个参数会有具体内容</span></span><br><span class="line">		<span class="comment"># exc_type：异常类型，exc_value：异常对象，traceback：错误的堆栈对象</span></span><br><span class="line">		<span class="comment"># __exit__返回值：True：异常被忽略， False：异常正常抛出</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Exiting MyContext&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> MyContext(<span class="string">&#x27;王大锤&#x27;</span>) <span class="keyword">as</span> me:</span><br><span class="line">        <span class="built_in">print</span>(me.name)</span><br></pre></td></tr></table></figure>



<h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p><a href="https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id5">https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id5</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象的 SOLID 原则</title>
    <url>/posts/b2c40e9d/</url>
    <content><![CDATA[<h2 id="面向对象的-SOLID-原则"><a href="#面向对象的-SOLID-原则" class="headerlink" title="面向对象的 SOLID 原则"></a>面向对象的 SOLID 原则</h2><blockquote>
<p>SOLID 原则是面向对象 class 设计的五条原则</p>
<p>由 Robert C · Martin 提出的，其著作有 《代码整洁之道》《架构整洁之道》</p>
</blockquote>
<p>其目标是一致的：</p>
<blockquote>
<p>创建可多人协作的、易于理解的、易读的以及可测试的代码</p>
</blockquote>
<p>依次看一下 SOLID 原则：</p>
<ul>
<li>S 职责单一原则</li>
<li>O 开闭原则</li>
<li>L 里式替换原则</li>
<li>I 接口隔离原则</li>
<li>D 依赖倒置原则</li>
</ul>
<h2 id="SRP-Single-Responsibility-Principle"><a href="#SRP-Single-Responsibility-Principle" class="headerlink" title="SRP (Single Responsibility Principle)"></a>SRP (Single Responsibility Principle)</h2><blockquote>
<p>职责单一原则——软件设计的低耦合、高内聚，提高内聚性来减少引起变化的原因</p>
</blockquote>
<p>核心思想：<strong>一个 Class 只做一件事情，并把这件事做好，其只有一个引起其变化的原则（职责变化）</strong></p>
<p>因此，减少各个模块的依赖，确保一个 Class 只做一种工作。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delete</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update_info</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="OCP-Open-Closed-Principle"><a href="#OCP-Open-Closed-Principle" class="headerlink" title="OCP (Open/Closed Principle)"></a>OCP (Open/Closed Principle)</h2><blockquote>
<p>开闭原则</p>
</blockquote>
<p>核心思想：<strong>模块是可扩展的，而不可修改的</strong></p>
<p>当存在已有模块方法时，对于新的需求或者变化时，可以对现有代码进行扩展，以适应新的情况。</p>
<p>对修改封闭，意味着一旦设计完成，就可以独立完成一些需求，而不要对类进行修改</p>
<p><strong>当然，对于重构而言，该原则可适当调整。（随机应变）</strong></p>
<h2 id="LSP-Liskov-substation-Principle"><a href="#LSP-Liskov-substation-Principle" class="headerlink" title="LSP (Liskov substation Principle)"></a>LSP (Liskov substation Principle)</h2><blockquote>
<p>里氏代换原则</p>
</blockquote>
<p><strong>Rober C. Martin 将该原则最终简化为：  <code>Subtypes must be subsititutable for theire bases types</code>——子类必须能够替换成它们的父类</strong></p>
<ul>
<li><p>子类可以替换成它们的父类，并且经过替换之后，代码还能正常工作</p>
</li>
<li><p>在代码中，不应该出现 if/else 之类来对子类类型进行判断的条件。</p>
</li>
<li><p>LSP 原则是使代码符合开闭原则的一个重要保证，正是由于子类的可替换性才使得父类的模块在无需修改的情况下就可以扩展。</p>
</li>
</ul>
<p><strong>LSP 原则其实对应 Python 中的继承和多态，即子类可以继承父类的属性和方法，子类也可以修改并扩展父类；</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.age = age</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sing</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;wangwang&quot;</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sleep&quot;</span>)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h2 id="ISP-Interface-Segregation-Principle"><a href="#ISP-Interface-Segregation-Principle" class="headerlink" title="ISP (Interface Segregation Principle)"></a>ISP (Interface Segregation Principle)</h2><blockquote>
<p>接口隔离原则</p>
</blockquote>
<p>核心思想：使用专门的接口，而不是单一的总接口，即客户端不应该依赖那些它不需要的接口</p>
<p>例如：总接口 Animal</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>(<span class="params">metacalss=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swim</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>但是，并不是所有的 Animal 都会飞，游泳，于是:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WalkAnimal</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;walking...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwimAnimal</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swim</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyAnimal</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="DIP-Dependency-Inversion-Principle"><a href="#DIP-Dependency-Inversion-Principle" class="headerlink" title="DIP (Dependency Inversion Principle)"></a>DIP (Dependency Inversion Principle)</h2><blockquote>
<p>依赖倒置原则</p>
</blockquote>
<p>高层模块不应该依赖于低层模块的实现，而是依赖于高层抽象。</p>
<p>冰箱的开关不应该依赖于电灯的开关实现，而是依赖于一个抽象的<strong>开关标准接口</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">off</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span>(<span class="params">Switch</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;light on&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">off</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;light off&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Refrigerator</span>(<span class="params">Switch</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;refrigerator on&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">off</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;refrigerator off&quot;</span>)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.freecodecamp.org/chinese/news/solid-principles/">https://www.freecodecamp.org/chinese/news/solid-principles/</a></p>
<p><a href="https://www.51cto.com/article/667555.html">https://www.51cto.com/article/667555.html</a></p>
<p> <a href="https://blog.csdn.net/weixin_51098806/article/details/123908651">https://blog.csdn.net/weixin_51098806/article/details/123908651</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>linux shell 脚本</title>
    <url>/posts/77fe4966/</url>
    <content><![CDATA[<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>什么是 shell ?</p>
<p>在计算机科学中，shell 就是一个<strong>命令解释器</strong></p>
<p>功能定位</p>
<p><strong>shell 担任了操作系统和应用程序之间的中间人</strong>，它负责将应用程序的输入命令信息解释给操作系统，操作系统将指令集结果反馈给应用程序。</p>
<p>Category</p>
<p>linux: sh/csh/ksh/bash/…</p>
<h3 id="Basic-Operation"><a href="#Basic-Operation" class="headerlink" title="Basic Operation"></a>Basic Operation</h3><ol>
<li>查看当前系统的 shell</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看当前系统环境支持的 shell</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>更改默认的 shell</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chsh 用户名 -s newshell</span><br></pre></td></tr></table></figure>

<h3 id="执行操作"><a href="#执行操作" class="headerlink" title="执行操作"></a>执行操作</h3><p>shell脚本的执行通常可以采用以下几种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash /path/to/script-name 或 /bin/bash /path/to/script-name (强烈推荐使用)</span><br><span class="line">/path/to/script-name 或 ./script-name (当前路径下执行脚本)</span><br><span class="line">source script-name 或 . script-name (注意“</span><br></pre></td></tr></table></figure>

<h2 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h2><h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>本地变量</td>
<td>变量仅仅在当前Shell终端有效</td>
</tr>
<tr>
<td>环境变量</td>
<td>也叫全局变量，变量在当前Shell终端其派生出来的任意子进程Shell终端中有效</td>
</tr>
<tr>
<td>内置变量</td>
<td>Shell解析器内部的一些功能参数变量</td>
</tr>
</tbody></table>
<h4 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h4><p>def: 变量仅仅在当前 Shell 终端有效</p>
<p><strong>表现样式</strong>：</p>
<p>① 普通变量的定义方式有如下三种：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>样式</th>
<th>特点</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>无引号</td>
<td>变量名=变量值</td>
<td>变量值必须是一个整体，中间没有特殊字符</td>
<td>“=” 前后不能有空格</td>
</tr>
<tr>
<td>单引号</td>
<td>变量名=’变量值’</td>
<td>原字符输出</td>
<td></td>
</tr>
<tr>
<td>双引号</td>
<td>变量名=”变量值”</td>
<td>变量值先解析，后整合</td>
<td>无</td>
</tr>
</tbody></table>
<p>② 命令变量的定义方式有如下两种：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>样式</th>
<th>特点</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>反引号</td>
<td>变量名=‘ 命令’</td>
<td>反引号</td>
<td>不要用中文</td>
</tr>
<tr>
<td>小括号</td>
<td>变量名=$(命令)</td>
<td>$()</td>
<td>无</td>
</tr>
</tbody></table>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>def：也叫全局变量，变量在当前Shell终端其派生出来的任意子进程Shell终端中有效</p>
<p>表现形式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export 变量=值</span><br></pre></td></tr></table></figure>

<h4 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h4><p>查看：$变量名、“$变量名”、${变量名}、”${变量名}”</p>
<p>取消：unset 变量名</p>
<h4 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h4><p><strong>属性含义</strong>：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>获取当前脚本文件名</td>
</tr>
<tr>
<td>$n</td>
<td>获取脚本的第n个参数值，样式：$1，${1}</td>
</tr>
<tr>
<td>$#</td>
<td>获取脚本参数的总个数</td>
</tr>
<tr>
<td>$?</td>
<td>获取上一个指令的状态返回值(0为成功，非0为失败)</td>
</tr>
</tbody></table>
<h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><p>① 方式A：test 条件表达式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意：=号两边必须有空格</span></span><br><span class="line"><span class="built_in">test</span> 1 = 1</span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line"><span class="built_in">test</span> 1 = 2</span><br><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>

<p>② 方式B：[ 条件表达式 ]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注：=号两边必须有空格，并且方括号[、]与条件表达式之间也要至少有一个空格</span></span><br><span class="line">[ 1 = 1 ]</span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line">[ 1 = 2 ]</span><br><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>

<p>条件成立，状态返回值是0；条件不成立，状态返回值是1。</p>
<h3 id="表达样式"><a href="#表达样式" class="headerlink" title="表达样式"></a>表达样式</h3><p><strong>① 重点表达式</strong>：</p>
<table>
<thead>
<tr>
<th>逻辑</th>
<th>样式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>命令1 &amp;&amp; 命令2</td>
<td>只有1成功，2才执行</td>
</tr>
<tr>
<td>||</td>
<td>命令1 || 命令2</td>
<td>1和2只能执行一个</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>文件</th>
<th>样式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>-f|d|s</td>
<td>-f file_name</td>
<td>判断文件格式</td>
</tr>
<tr>
<td>-r|w|x</td>
<td>-x file_name</td>
<td>判断文件权限</td>
</tr>
</tbody></table>
<p><strong>② 一般表达式</strong>：</p>
<table>
<thead>
<tr>
<th>数字</th>
<th>样式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>eq</td>
<td>数字1 eq 数字2</td>
<td>相等eq，不等ne</td>
</tr>
<tr>
<td>gt</td>
<td>数字1 gt 数字2</td>
<td>gt大于，小于lt</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>字符串</th>
<th>样式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>== | !=</td>
<td>str1 == str2</td>
<td>字符串内容是否一致</td>
</tr>
<tr>
<td>-z|n</td>
<td>-z str1</td>
<td>z空，n不空</td>
</tr>
</tbody></table>
<p><strong>③ 计算表达式</strong>：</p>
<p>样式一：$[计算表达式]、a=$[变量名a+1]</p>
<p>样式二：$((计算表达式)) 或 a=$((变量名a+1))</p>
<p>样式三：let 变量名a=变量名a+1</p>
<blockquote>
<p>注意：样式三的表达式必须是一个整体，中间不能出现空格等特殊字符</p>
</blockquote>
<h3 id="常见符号"><a href="#常见符号" class="headerlink" title="常见符号"></a>常见符号</h3><p><strong>① 信息传递</strong></p>
<table>
<thead>
<tr>
<th>重定向符号</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;|&lt;</td>
<td>表示将符号左侧|右侧的内容，以覆盖的方式输入到右侧|左侧文件</td>
</tr>
<tr>
<td>&gt;&gt;|&lt;&lt;</td>
<td>表示将符号左侧|右侧的内容，以追加的方式输入到右侧|左侧文件的末尾行中</td>
</tr>
</tbody></table>
<p><strong>② 其他符号</strong></p>
<table>
<thead>
<tr>
<th>后台展示符号</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>就是将一个命令从前台转到后台执行</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>信息获取符号</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>表示正确输出的信息</td>
</tr>
<tr>
<td>2</td>
<td>表示错误输出的信息</td>
</tr>
<tr>
<td>2&gt;&amp;1</td>
<td>代表所有输出的信息,也可以简写为 “&amp;&gt;”</td>
</tr>
</tbody></table>
<h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>global search regular expression and print out the line </p>
<p>文本搜索命令</p>
<p>命令格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [参数] [关键字] &lt;文件名&gt;</span><br></pre></td></tr></table></figure>

<p><strong>参数详解</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>只输出匹配行的计数</td>
</tr>
<tr>
<td>-n</td>
<td>显示匹配行及行号</td>
</tr>
<tr>
<td>-v</td>
<td>显示不包含匹配文本的所有行</td>
</tr>
<tr>
<td>-E</td>
<td>使用扩展正则匹配</td>
</tr>
</tbody></table>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>行文件编辑工具</p>
<p><strong>命令格式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed [参数] <span class="string">&#x27;&lt;匹配条件&gt; [动作]&#x27;</span> [文件名]</span><br></pre></td></tr></table></figure>

<p><strong>参数详解</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>参数为空</td>
<td>表示sed的操作效果，实际上不对文件进行编辑</td>
</tr>
<tr>
<td>-n</td>
<td>默认只输出修改的内容，一般在动作中结合”p”使用</td>
</tr>
<tr>
<td>-i</td>
<td>表示对文件进行编辑</td>
</tr>
</tbody></table>
<blockquote>
<p>注：mac版本的bash中使用 -i参数，必须在后面单独加个东西: -i ‘’</p>
</blockquote>
<p><strong>① 替换操作</strong></p>
<p><strong>命令格式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;行号s#原内容#替换后内容#列号&#x27;</span> [文件名]</span><br><span class="line">或</span><br><span class="line">sed -i <span class="string">&#x27;/匹配关键字/s#原内容#替换后内容#列号&#x27;</span> [文件名]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：行号不写表示所有行，列号不写表示第1列，列号写成g，表示当前所有匹配的内容</p>
</blockquote>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>awk是一个功能非常强大的文档编辑工具，它不仅能以行为单位还能以列为单位处理文件。</p>
<p><strong>命令格式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk [参数] <span class="string">&#x27;BEGIN&#123;...&#125;&#123;动作&#125;END&#123;...&#125;&#x27;</span> [文件名]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">常见参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-F</td>
<td align="left">指定列的分隔符</td>
</tr>
<tr>
<td align="left"><strong>常见动作</strong></td>
<td align="left"><strong>说明</strong></td>
</tr>
<tr>
<td align="left">print</td>
<td align="left">显示内容</td>
</tr>
<tr>
<td align="left">$0</td>
<td align="left">显示当前行所有内容</td>
</tr>
<tr>
<td align="left">$n</td>
<td align="left">显示当前行的第n列内容，如果存在多个$n，它们之间使用逗号(,)隔开</td>
</tr>
<tr>
<td align="left"><strong>常见内置变量</strong></td>
<td align="left"><strong>说明</strong></td>
</tr>
<tr>
<td align="left">FILENAME</td>
<td align="left">当前输入文件的文件名，该变量是只读的</td>
</tr>
<tr>
<td align="left">NF</td>
<td align="left">输出最后一列的内容</td>
</tr>
<tr>
<td align="left">OFS</td>
<td align="left">输出格式的列分隔符，缺省是空格</td>
</tr>
<tr>
<td align="left">FS</td>
<td align="left">输入文件的列分融符，缺省是连续的空格和Tab</td>
</tr>
</tbody></table>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p><strong>① 单分支if</strong></p>
<p>特点：单条件，单结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    指令</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 单if语句的使用场景 </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;man&quot;</span> ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;您的性别是：男&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p><strong>② 双分支if</strong></p>
<p>特点：单条件，两结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    指令1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    指令2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 双分支if语句的使用场景 </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;man&quot;</span> ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;您的性别是：男&quot;</span> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;您的性别是：女&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p><strong>③ 多分支if</strong></p>
<p>特点：n条件，n+1结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    指令1</span><br><span class="line"><span class="keyword">elif</span> [ 条件2 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    指令2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    指令3</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 多分支if语句的使用场景 </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;man&quot;</span> ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;您的性别是：男&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;woman&quot;</span> ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;您的性别是：女&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;您的性别，我不知道&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-脚本案例"><a href="#1-2-脚本案例" class="headerlink" title="1.2 脚本案例"></a>1.2 脚本案例</h4><p><strong>① 需求说明</strong></p>
<p>要求脚本执行需要有参数，通过传入参数来实现不同的功能。</p>
<p>参数和功能详情如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>执行效果</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>服务启动中…</td>
</tr>
<tr>
<td>stop</td>
<td>服务关闭中…</td>
</tr>
<tr>
<td>restart</td>
<td>服务重启中…</td>
</tr>
<tr>
<td>*</td>
<td>脚本x.sh使用方式为： x.sh [ start|stop|restart ]</td>
</tr>
</tbody></table>
<p><strong>② 脚本内容</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 多if语句的使用场景</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;start&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;服务启动中...&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;stop&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;服务关闭中...&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;restart&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;服务重启中...&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span> 脚本的使用方式: <span class="variable">$0</span> [ start | stop | restart ]&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="2-case语句"><a href="#2-case语句" class="headerlink" title="2. case语句"></a>2. case语句</h3><p>我们发现多if语句使用的时候，代码量很多，而且整体看起来确实有那么一丁点乱，有没有办法更好的实现这种效 果呢？就是case语句。</p>
<h4 id="2-1-语法格式"><a href="#2-1-语法格式" class="headerlink" title="2.1 语法格式"></a>2.1 语法格式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 变量名 <span class="keyword">in</span></span><br><span class="line">    值 1)</span><br><span class="line">        指令1</span><br><span class="line">        ;;</span><br><span class="line">    ...</span><br><span class="line">    值 n)</span><br><span class="line">        指令n</span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：<br>① 首行关键字是case，末行关键字esac<br>② 选择项后面都有 )<br>③ 每个选择的执行语句结尾都有两个分号</p>
</blockquote>
<h4 id="2-2-语法示例"><a href="#2-2-语法示例" class="headerlink" title="2.2 语法示例"></a>2.2 语法示例</h4><p>场景：在多if语句的基础上对脚本进行升级</p>
<p>需求：要求脚本执行需要有参数，通过传入参数来实现不同的功能</p>
<p>参数和功能详情如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>执行效果</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>服务启动中…</td>
</tr>
<tr>
<td>stop</td>
<td>服务关闭中…</td>
</tr>
<tr>
<td>restart</td>
<td>服务重启中…</td>
</tr>
<tr>
<td>*</td>
<td>脚本x.sh使用方式为： x.sh [ start|stop|restart ]</td>
</tr>
</tbody></table>
<p>脚本内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi case.sh </span></span><br><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line"><span class="comment"># case语句使用场景</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span> </span><br><span class="line">    <span class="string">&quot;start&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;服务启动中...&quot;</span></span><br><span class="line">        ;; </span><br><span class="line">    <span class="string">&quot;stop&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;服务关闭中...&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">  <span class="string">&quot;restart&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;服务重启中...&quot;</span></span><br><span class="line">        ;; </span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span> 脚本的使用方式: <span class="variable">$0</span> [ start | stop | restart ]&quot;</span></span><br><span class="line">        ;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h3 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3. 循环语句"></a>3. 循环语句</h3><h4 id="3-1-语法格式"><a href="#3-1-语法格式" class="headerlink" title="3.1 语法格式"></a>3.1 语法格式</h4><p><strong>for循环语句</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 条件</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：for语句，循环的数量有列表中元素个数来决定</p>
</blockquote>
<p>简单实践：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># for语句的使用示例 </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(ls /root) </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;i&#125;</span>&quot;</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>while条件</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：while语句，只要条件满足，就一直循环下去</p>
</blockquote>
<p>简单实践：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># while 的示例</span></span><br><span class="line">a=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$&#123;a&#125;</span>&quot;</span> -lt 5 ] </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;a&#125;</span>&quot;</span></span><br><span class="line">    a=$((a+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>util条件</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">until 条件</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：until语句，只要条件不满足，就一直循环下去</p>
</blockquote>
<p>简单实践：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># until的示例</span></span><br><span class="line">a=1</span><br><span class="line">until [ <span class="string">&quot;<span class="variable">$&#123;a&#125;</span>&quot;</span> -eq 5 ] </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;a&#125;</span>&quot;</span></span><br><span class="line">    a=$((a+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h2><h3 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h3><p>定义：函数就是将某些命令组合起来实现某一特殊功能的方式，是脚本编写中非常重要的一部分。</p>
<h4 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a>1.1 基本语法</h4><p><strong>简单函数格式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名()&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用函数：函数名</p>
</blockquote>
<p><strong>传参函数格式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名()&#123;</span><br><span class="line">    函数体 <span class="variable">$n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用函数：函数名 参数</p>
<p>注：function 关键字可以省略</p>
</blockquote>
<h4 id="1-2-简单实践"><a href="#1-2-简单实践" class="headerlink" title="1.2 简单实践"></a>1.2 简单实践</h4><p><strong>简单函数定义和调用示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 函数使用场景一：执行频繁的命令</span></span><br><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;my name is smart&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 函数调用</span></span><br><span class="line">func</span><br></pre></td></tr></table></figure>

<p><strong>函数传参和函数体内调用参数示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 函数的使用场景二</span></span><br><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;my name is <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 函数调用</span></span><br><span class="line">func <span class="string">&quot;smart&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-函数进阶"><a href="#2-函数进阶" class="headerlink" title="2. 函数进阶"></a>2. 函数进阶</h3><h4 id="2-1-进阶样式"><a href="#2-1-进阶样式" class="headerlink" title="2.1 进阶样式"></a>2.1 进阶样式</h4><p><strong>脚本传参和函数调用</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 脚本传参数</span></span><br><span class="line">/bin/bash 脚本名 参数</span><br></pre></td></tr></table></figure>

<p>函数定义和调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">函数名()&#123;</span><br><span class="line">    函数体 <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line">函数名 <span class="variable">$1</span></span><br></pre></td></tr></table></figure>

<p>函数定义和调用(生成用)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">本地变量名=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">函数名()&#123;</span><br><span class="line">    函数体 <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line">函数名 <span class="string">&quot;<span class="variable">$&#123;本地变量名&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-进阶实践"><a href="#2-2-进阶实践" class="headerlink" title="2.2 进阶实践"></a>2.2 进阶实践</h4><p>脚本传参+函数调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 函数传参演示</span></span><br><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;my name is <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 函数传参</span></span><br><span class="line">func <span class="variable">$1</span></span><br></pre></td></tr></table></figure>

<p>脚本传参+函数调用(生产用)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 函数的使用场景二</span></span><br><span class="line">name=&quot;$1&quot; </span><br><span class="line">func()&#123;</span><br><span class="line">    echo &quot;my name is $1&quot;</span><br><span class="line">&#125;</span><br><span class="line">func &quot;$&#123;name&#125;&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 linux 命令</title>
    <url>/posts/92072779/</url>
    <content><![CDATA[<h1 id="linx-面试题"><a href="#linx-面试题" class="headerlink" title="linx 面试题"></a>linx 面试题</h1><p>参考：<a href="https://segmentfault.com/a/1190000040007585">https://segmentfault.com/a/1190000040007585</a><br><a href="https://www.edureka.co/blog/interview-questions/linux-interview-questions-for-beginners/">https://www.edureka.co/blog/interview-questions/linux-interview-questions-for-beginners/</a></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vat vi vim ls mkdir touch cp mv</span><br></pre></td></tr></table></figure>
<p>查找是否存在文件名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name mysql</span><br></pre></td></tr></table></figure>
<h2 id="日志操作"><a href="#日志操作" class="headerlink" title="日志操作"></a>日志操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f /var/www/data.log.out</span><br></pre></td></tr></table></figure>
<p>抓取关键字</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat  data.log.out | grep &quot;error&quot;</span><br><span class="line">grep -i &quot;返回 resp &quot; data.log</span><br></pre></td></tr></table></figure>

<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf filename.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar –cvf jpg.tar *.jpg</span><br></pre></td></tr></table></figure>

<h2 id="查找进程"><a href="#查找进程" class="headerlink" title="查找进程"></a>查找进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux | grep java</span><br></pre></td></tr></table></figure>

<h2 id="系统、内存、磁盘、网络相关"><a href="#系统、内存、磁盘、网络相关" class="headerlink" title="系统、内存、磁盘、网络相关"></a>系统、内存、磁盘、网络相关</h2><p>top 查看内存、cpu 情况<br>du、df 查看磁盘、文件大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -s -h /data</span><br></pre></td></tr></table></figure>
<p>ping、curl 查看网络是否正常</p>
<h2 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h2><p>chmod: 修改文件或者目录的权限<br>chown: 即 change owner, 修改文件和目录的所有者权限<br>chattr: chmod 的底层操作，锁定文件<br>例如，你想设置权限，使用户可以读取、写入和执行它，并且你的组的成员可以读取和执行它，而其他人只能读取它<br>chmod u=rwx,g=rx,o=r a  ilename<br>chmod 751 filename<br>绝对模式</p>
<table>
<thead>
<tr>
<th><strong>0</strong></th>
<th>没有权限</th>
<th>– – –</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>执行权限</td>
<td>- - X</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>写权限</td>
<td>– w –</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>执行和写入权限：1（执行）+2（写入）=3</td>
<td>– wx</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>读取权限</td>
<td>r – –</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>读取和执行权限：4（读取）+1（执行）=5</td>
<td>r - x</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>读写权限：4（读）+2（写）=6</td>
<td>rw—— _</td>
</tr>
<tr>
<td><strong>7</strong></td>
<td>所有权限：4（读取）+ 2（写入）+ 1（执行）= 7</td>
<td>rwx</td>
</tr>
<tr>
<td><img src="img.png" alt="img.png"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="内存命令"><a href="#内存命令" class="headerlink" title="内存命令"></a>内存命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top </span><br><span class="line">free -h</span><br><span class="line">vmstat</span><br><span class="line">htop</span><br><span class="line">free -h -s 3 3 秒一次的间隔秒数</span><br></pre></td></tr></table></figure>

<h2 id="buff-cache"><a href="#buff-cache" class="headerlink" title="buff/cache"></a>buff/cache</h2><p>缓冲/缓存是两种类型的内存。<br>先总结一下：<br><strong>缓冲</strong>主要目的是进行流量整形，把突发的大数量较小规模的 I/O 整理成平稳的<br>小数量较大规模的 I/O ，以<strong>减少响应次数</strong>。（比如从网上下电影，你不能下一点点数据就写一下硬盘，而是积攒一定量的数据以后一整块一起写，不然硬盘都要被你玩坏了）<br><strong>缓存</strong> 是为了弥补高速设备和低速设备的鸿沟而引入的中间层，最终起到<strong>加快访问速度</strong><br>的作用。</p>
<h2 id="CPU-负载很高怎么办"><a href="#CPU-负载很高怎么办" class="headerlink" title="CPU 负载很高怎么办"></a>CPU 负载很高怎么办</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -axjf 查看 STAT 这一列是否存在 D 状态进程</span><br></pre></td></tr></table></figure>
<blockquote>
<p>D 状态是指不可中断的睡眠状态。该状态的进程无法被 kill, 也无法自行退出<br>只能通过恢复其依赖的资源或者重启系统来解决。</p>
</blockquote>
<h2 id="如何查看-CPU-和-CPU-核心？"><a href="#如何查看-CPU-和-CPU-核心？" class="headerlink" title="如何查看 CPU 和 CPU 核心？"></a>如何查看 CPU 和 CPU 核心？</h2><p>查看 cpu 和 cpu 核心？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;model name&quot;</span><br></pre></td></tr></table></figure>
<p>查看 cpu 核心</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;cpu cores&quot;</span><br></pre></td></tr></table></figure>

<h2 id="查看硬盘的使用情况"><a href="#查看硬盘的使用情况" class="headerlink" title="查看硬盘的使用情况"></a>查看硬盘的使用情况</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -hl</span><br><span class="line">du -s -h /root</span><br></pre></td></tr></table></figure>
<h2 id="怎么杀死进程？"><a href="#怎么杀死进程？" class="headerlink" title="怎么杀死进程？"></a>怎么杀死进程？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看进程</span><br><span class="line">ps -aux | grep  python</span><br><span class="line">找到需要杀死的进程</span><br><span class="line">kill -9 3827</span><br></pre></td></tr></table></figure>
<h2 id="linux-vm-内核参数优化设置"><a href="#linux-vm-内核参数优化设置" class="headerlink" title="linux vm 内核参数优化设置"></a>linux vm 内核参数优化设置</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>使用 uptime 查看 CPU 使用情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uptime</span><br></pre></td></tr></table></figure>
<p>vmstat 查看 CPU 使用情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmstat 2 10</span><br></pre></td></tr></table></figure>

<h2 id="如何合理的查找（find）"><a href="#如何合理的查找（find）" class="headerlink" title="如何合理的查找（find）"></a>如何合理的查找（find）</h2><h3 id="在-software-目录下找出大小超过-10-MB的文件"><a href="#在-software-目录下找出大小超过-10-MB的文件" class="headerlink" title="在 /software 目录下找出大小超过 10 MB的文件"></a>在 /software 目录下找出大小超过 10 MB的文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /software -type f -size +10240k</span><br></pre></td></tr></table></figure>

<h3 id="在-目录下找出-365-天未被访问过的文件"><a href="#在-目录下找出-365-天未被访问过的文件" class="headerlink" title="在 目录下找出 365 天未被访问过的文件"></a>在 目录下找出 365 天未被访问过的文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /software \! -atime -365</span><br></pre></td></tr></table></figure>

<h3 id="目录下找出-365-天之前被修改过的文件"><a href="#目录下找出-365-天之前被修改过的文件" class="headerlink" title="目录下找出 365 天之前被修改过的文件"></a>目录下找出 365 天之前被修改过的文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /home -mtime +365</span><br></pre></td></tr></table></figure>

<h2 id="什么是-inode-和-process-id"><a href="#什么是-inode-和-process-id" class="headerlink" title="什么是 inode 和 process id ?"></a>什么是 inode 和 process id ?</h2><p>inode 是操作系统赋予每个文件的唯一名称。同样，进程 ID 是赋予每个进程的唯一 ID</p>
<h2 id="什么是守护进程（daemon）"><a href="#什么是守护进程（daemon）" class="headerlink" title="什么是守护进程（daemon）"></a>什么是守护进程（daemon）</h2><p>守护进程是作为后台进程运行以提供基本操作系统中可能不可用的功能的计算机程序。守护进程通常用于在后台运行服务，<br>而不直接控制交互式用户。守护进程的目的是处理周期性请求，然后将请求转发给适当程序执行。</p>
<h2 id="Linux-中的进程状态有哪些？"><a href="#Linux-中的进程状态有哪些？" class="headerlink" title="Linux 中的进程状态有哪些？"></a>Linux 中的进程状态有哪些？</h2><ul>
<li>Ready: 进程已创建并准备运行</li>
<li>Running: 进程正在执行</li>
<li>Blocked or wait: 进程正在等待用户输入</li>
<li>Terminated or Completed: 进程已完成或者被操作系统终止</li>
<li>Zombie:进程终止，但进程表仍然存在信息</li>
</ul>
<h2 id="解释-Linux-中的进程管理系统调用"><a href="#解释-Linux-中的进程管理系统调用" class="headerlink" title="解释 Linux 中的进程管理系统调用"></a>解释 Linux 中的进程管理系统调用</h2><p>管理进程的系统调用：</p>
<ul>
<li>fork(): 用户创建新进程</li>
<li>exec(): 执行一个新进程</li>
<li>wait(): 等待进程完成执行</li>
<li>exit(): 退出进程</li>
</ul>
<h2 id="为什么要使用-tar-命令？"><a href="#为什么要使用-tar-命令？" class="headerlink" title="为什么要使用 tar 命令？"></a>为什么要使用 tar 命令？</h2><blockquote>
<p>tar 命令用于提取或创建归档文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvzf sample.tar.gz</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -cvzf filename.tar.gz</span><br></pre></td></tr></table></figure>
<p>其中 c: 创建存档；x: 提取；v: 详细；f: 文件</p>
<h2 id="如何查看-Linux-上挂载的设备列表？"><a href="#如何查看-Linux-上挂载的设备列表？" class="headerlink" title="如何查看 Linux 上挂载的设备列表？"></a>如何查看 Linux 上挂载的设备列表？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -l</span><br></pre></td></tr></table></figure>

<h2 id="如何查找两个配置文件的不同之处"><a href="#如何查找两个配置文件的不同之处" class="headerlink" title="如何查找两个配置文件的不同之处"></a>如何查找两个配置文件的不同之处</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">diff abc.conf xyz.conf</span><br></pre></td></tr></table></figure>
<p><img src="img_1.png" alt="img_1.png"></p>
<h2 id="你会如何在-linux-中安排任务？"><a href="#你会如何在-linux-中安排任务？" class="headerlink" title="你会如何在 linux 中安排任务？"></a>你会如何在 linux 中安排任务？</h2><p>linux 中有两个用于调度任务的命令：cron 和 at。<br>cron 命令用于在特定时间重复调度任务。任务存储在 cron 文件中，然后使用 cron 命令执行。<br>cron 命令从该文件中<code>读取字符串</code>并安排任务。<br>cron 文件语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;minute&gt; &lt;hour&gt; &lt;day&gt; &lt;month&gt; &lt;weekday&gt; &lt;command&gt;</span><br></pre></td></tr></table></figure>
<p>假设您想在每周日下午 4 点运行一个命令，那么字符串将是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 16 * * 0 &lt;command&gt;</span><br></pre></td></tr></table></figure>
<p>假设您想在今天下午 6 点关闭系统，那么执行操作的命令将是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;shutdown now&quot; | at -m 18:00</span><br></pre></td></tr></table></figure>
<h2 id="如何识别你使用的是哪个-shell"><a href="#如何识别你使用的是哪个-shell" class="headerlink" title="如何识别你使用的是哪个 shell?"></a>如何识别你使用的是哪个 shell?</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>

<h2 id="如何从您的系统登陆到您网络中的另一个系统？"><a href="#如何从您的系统登陆到您网络中的另一个系统？" class="headerlink" title="如何从您的系统登陆到您网络中的另一个系统？"></a>如何从您的系统登陆到您网络中的另一个系统？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh &lt;username&gt;@&lt;ip address&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何使用-vim-编辑器以只读模式打开文件？"><a href="#如何使用-vim-编辑器以只读模式打开文件？" class="headerlink" title="如何使用 vim 编辑器以只读模式打开文件？"></a>如何使用 vim 编辑器以<code>只读</code>模式打开文件？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim -R &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何使用-vim-编辑器在文件中搜索特定的员工-ID"><a href="#如何使用-vim-编辑器在文件中搜索特定的员工-ID" class="headerlink" title="如何使用 vim 编辑器在文件中搜索特定的员工 ID ?"></a>如何使用 vim 编辑器在文件中搜索特定的员工 ID ?</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim +/&lt;employee id to be searched&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何使用-vim-编辑器跳转到文件中的特定行？"><a href="#如何使用-vim-编辑器跳转到文件中的特定行？" class="headerlink" title="如何使用 vim 编辑器跳转到文件中的特定行？"></a>如何使用 vim 编辑器跳转到文件中的特定行？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim +/&lt;line number&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何按照升序对文本文件中的条目进行排序"><a href="#如何按照升序对文本文件中的条目进行排序" class="headerlink" title="如何按照升序对文本文件中的条目进行排序?"></a>如何按照升序对文本文件中的条目进行排序?</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort sample.txt</span><br></pre></td></tr></table></figure>

<h2 id="如何检查特定服务是否在运行？"><a href="#如何检查特定服务是否在运行？" class="headerlink" title="如何检查特定服务是否在运行？"></a>如何检查特定服务是否在运行？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service &lt;service-name&gt; status</span><br></pre></td></tr></table></figure>

<h2 id="如何查看所有服务的状态"><a href="#如何查看所有服务的状态" class="headerlink" title="如何查看所有服务的状态?"></a>如何查看所有服务的状态?</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service --status-all</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GIL 解释及探究</title>
    <url>/posts/723b604d/</url>
    <content><![CDATA[<h1 id="什么是-GIL-？"><a href="#什么是-GIL-？" class="headerlink" title="什么是 GIL ？"></a>什么是 GIL ？</h1><p>GIL，全称 <code>Global Interpreter Lock</code>, 即<code>全局解释器锁</code>, 它的官方解释如下：</p>
<blockquote>
<p>In CPython, the global interpreter lock, or GIL, is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)</p>
</blockquote>
<blockquote>
<p>在 CPython 解释器中，全局解释器锁 GIL 是在于执行 Python 字节码时，为了保护访问 Python 对象而阻止多个线程执行的一把互斥锁。<br>这把锁的存在主要是因为 CPython 解释器的内存管理不是线程安全的。然而直到今天 GIL 依旧存在，现在很多功能已经习惯于依赖它作为执行的保证。</p>
</blockquote>
<ul>
<li>GIL 是存在于 CPython 解释器中的，属于解释器层级，而并非属于 Python 的语言特性。也就是说，如果你自己有能力<br>实现一个 Python 解释器，完全可以不用 GIL。</li>
<li>GIL 是为了让解释器在执行 Python 代码时，同一时刻只有一个线程在运行，以此保证<code>内存管理是安全</code>的</li>
<li>历史原因，现在很多 Python 项目已经习惯于依赖 GIL (开发者认为 Python 就是线程安全的，写代码时对共享资源的访问不会加锁)</li>
</ul>
<p>常见的 Python 解释器还有：</p>
<ul>
<li>CPython</li>
<li>IPython</li>
<li>PyPy: 目标是加快执行速度，采用 JIT 技术，对 Python 代码进行动态编译，可以显著提高代码的执行速度。</li>
<li>Jpython: 运行在 Java 平台的 Python 解释器，可以把 Python 编译为 Java 字节码</li>
<li>IronPython: .Net 平台</li>
</ul>
<h2 id="GIL-带来的问题"><a href="#GIL-带来的问题" class="headerlink" title="GIL 带来的问题"></a>GIL 带来的问题</h2><p>一个 Python 线程想要执行一段代码，必须先拿到 <code>GIL 锁</code>后才被允许执行，也就是说，即使我们使用了多线程，但同一时刻却只有一个线程在执行。</p>
<h2 id="GIL-原理"><a href="#GIL-原理" class="headerlink" title="GIL 原理"></a>GIL 原理</h2><p>其实，由于 Python 的线程就是 C 语言的 pthread, 它是通过操作系统调度算法调度执行的。</p>
<p>python3.x 进行了优化，基于固定时间的调度方式，就是每执行固定时间的字节码，或者遇到系统 IO 时，强制释放<br>GIL，触发系统的线程调度。</p>
<p>而在python3.x中，GIL不使用 ticks 计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），<br>这样对<strong>CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题</strong>，所以效率依然不尽如人意。</p>
<p><strong>多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，<br>但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低</strong></p>
<p>而线程在调度时，又依赖系统的 CPU 环境，也就是在单核 CPU 或者多核 CPU 下，多线程在调度切换时的成本是不同的。</p>
<p>如果多线程运行一个 <code>CPU 密集型任务</code>，那么 Python 多线程是无法提高运行效率的。</p>
<p>如果需要运行 IO 密集型任务，Python 多线程是可以提高运行效率的。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>IO 密集型任务场景，可以使用多线程提高运行效率</li>
<li>CPU 密集型任务场景，不使用多线程，推荐使用多进程方式部署运行</li>
<li>更换没有 GIL 的 Python 解释器，需要预评估运行结果是否与 CPython 一致</li>
<li>编写 Python 的 C 扩展模块，将 CPU 密集型任务交给 C 模块处理。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 高可用方案</title>
    <url>/posts/7c68620a/</url>
    <content><![CDATA[<h1 id="Redis-高可用方案"><a href="#Redis-高可用方案" class="headerlink" title="Redis 高可用方案"></a>Redis 高可用方案</h1><p>Redis 高可用方式主要有以下四种：</p>
<ul>
<li><strong>数据持久化</strong></li>
<li><strong>主从数据同步（主从复制）</strong></li>
<li><strong>Redis 哨兵模式 (Sentinel)</strong></li>
<li><strong>Redis 集群（Cluster）</strong></li>
</ul>
<p>数据持久化保证系统在发生宕机或者重启之后数据不会丢失，增加了系统的可靠性和减少了系统不可用的时间（省去了手动恢复数据的过程）；<br>主从数据同步可以将数据存储至多台服务器，这样当遇到一台服务器宕机之后，可以很快地切换到另一台服务器以继续提供服务；<br>哨兵模式发生故障之后自动切换主服务器；<br>Redis 集群提供多主多从的 Redis 分布式集群环境，用于提供性能更好的 Redis 服务，并且它自身拥有故障自动切换的能力。</p>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>Redis 4.0 之前数据持久化方式有两种：<strong>AOF 方式和 RDB 方式。</strong></p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB (Redis Database, 快照方式) 按照<code>一定的时间周期</code> 策略把内存的数据以<code>快照(snapshot)</code>的方式保存到硬盘的二进制文件中。<br>即：snapshot 快照存储，对应产生数据文件为 <code>dump.db</code>，通过配置文件中的 <code>save</code> 参数来定义快照的周期。<br>核心函数：<code>rdbSave</code>(生成 RDB 文件) 和 <code>rdbLoad</code>（从文件加载内存）两个函数。</p>
<p><strong>优点：是以二进制存储的，占用空间更小、数据存储更紧凑，并且与 AOF 相比，RDB 具备更快的重启恢复能力。</strong></p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF 是 (append only file) 的缩写。Redis 会将每一个收到的写命令都通过 <code>Write</code> 函数追加到文件最后，类似于 MySQL 的 binlog.<br>当 Redis 重启时，就会从 <code>appendlonly.aof</code> 中加载命令来重建整个 Redis 数据库。<br>每当执行服务器函数或函数时，<code>flushAppendOnlyFile</code> 函数都会被调用，这个函数执行两个工作：</p>
<ul>
<li>WRITE<br>根据条件，将 <code>aof_buf</code> 中的缓存写入 AOF 文件中；</li>
<li>SAVE<br>根据条件，调用 <code>fsync</code> 或 <code>fdatasync</code> 函数，将 AOF 文件保存到磁盘中</li>
</ul>
<p>总结：</p>
<ul>
<li>RDB 占用空间更小、占用空间小，具备更快的重启恢复能力。</li>
<li>AOF 存储频率更高，数据丢失的风险越低，招用空间大，重启速度较慢。</li>
<li>也可以使用混合持久化功能，通过<code>config get aof-use-rdb-preamble</code> 的命令来查询 Redis 混合持久化的功能是否开启。</li>
</ul>
<h2 id="Redis-主从同步"><a href="#Redis-主从同步" class="headerlink" title="Redis 主从同步"></a>Redis 主从同步</h2><p>在 Redis 集群环境中，对于主机器和从机器数据一致的操作，就需要主从同步，也叫 application，来同步主节点的数据。</p>
<p>Redis 主从同步分为：<strong>主从模式</strong> 和 <strong>从从模式</strong></p>
<h3 id="主从复制的三种机制"><a href="#主从复制的三种机制" class="headerlink" title="主从复制的三种机制"></a>主从复制的三种机制</h3><ul>
<li><ol>
<li>主从节点连接正常时，主设备会发送一连串的数据流来保持对 <code>slave</code> 的更新：包括客户端的写入，key 的过期或被逐出等待。</li>
</ol>
</li>
<li><ol start="2">
<li>当 master 和 slave 之间的连接断开之后（网络原因、连接超时等），slave 重新连接 master 会尝试进行部分重同步：<strong>尝试获取在断开连接期间丢失的命令流</strong></li>
</ol>
</li>
<li><ol start="3">
<li>当第二步中无法进行部分重同步，<strong>slave 会进行全量同步</strong></li>
</ol>
</li>
</ul>
<p>Redis 使用的默认是<strong>异步复制</strong>，其特点是<code>低延迟</code>和<code>高性能</code>。</p>
<h2 id="Redis-哨兵模式"><a href="#Redis-哨兵模式" class="headerlink" title="Redis 哨兵模式"></a>Redis 哨兵模式</h2><p>Redis 哨兵模式是用来监视 Redis 主从服务器的，当 Redis 的主从服务器发生故障之后，Redis 哨兵提供了自动容灾修复的功能。<br>Redis 哨兵模块存储在 Redis 的 src/redis-sentinel 目录。我们可以使用命令<code>./src/redis-sentinel sentinel.conf</code> 来启动哨兵功能。</p>
<p>Redis Sentinel 是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：<strong>Redis Sentinel 集群</strong>和 <strong>Redis 数据集群</strong>。</p>
<p>其中 Redis Sentinel 集群是由若干个 Sentinel 节点组成的分布式集群，可以实现</p>
<ul>
<li><strong>故障发现</strong></li>
<li><strong>故障自动转移</strong></li>
<li><strong>配置中心</strong></li>
<li><strong>客户端通知</strong></li>
</ul>
<p>Redis Sentinel 的节点数量要满足 <code>2n+1</code> 的奇数个。<br>哨兵的工作主要是：</p>
<ul>
<li>监控</li>
<li>故障检测</li>
<li>故障转移</li>
<li>sentinel leader</li>
<li>master 重选</li>
</ul>
<h3 id="哨兵（Sentinel）工作方式"><a href="#哨兵（Sentinel）工作方式" class="headerlink" title="哨兵（Sentinel）工作方式"></a>哨兵（Sentinel）工作方式</h3><ul>
<li><ol>
<li>每个 Sentinel 以每秒钟一次的频率向它管理的 master, slave 以及其他 Sentinel 实例发送一个 PING 命令。</li>
</ol>
</li>
<li><ol start="2">
<li>如果一个节点距离最后一次有效回复 PING 命令的时间超过 <code>own-after-milliseconds</code> 选项所指定的值，则这个实例会被<code>Sentinel</code>标记为主观下线。</li>
</ol>
</li>
<li><ol start="3">
<li>若一个 master 节点被标记为主观下线，则正在监视这个 master 的所有 Sentinel 要以每秒一次的频率确认 master 是否进入了主观下线的状态</li>
</ol>
</li>
<li><ol start="4">
<li>当有足够数量的 Sentinel (大于等于配置文件指定的值) 在指定的时间范围内确认 master 的确进入了主观下线状态，则 master 会被标记为客观下线。</li>
</ol>
</li>
<li><ol start="5">
<li>在一般情况下，每个 Sentinel 会以 10 s 一次的频率向它已知的所有 master, slave 发送 INFO 命令。</li>
</ol>
</li>
<li><ol start="6">
<li>当 master 被 Sentinel 标记为客观下线时，sentinel 向下线的 master 的所有 slave 发送 INFO 命令的频率会从 10s/次改为 1s/次</li>
</ol>
</li>
</ul>
<h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><ul>
<li>主观下线(Subjective Down, SDOWN): 是指一个哨兵通过检测发现某个主节点发生故障的一种状态。</li>
<li>客观下线(Objective Down, ODOWN): 是指哨兵检测到某个主节点发生故障，通过命令 SENTINEL <code>is-master-down-by-addr</code> 与其他哨兵节点协商，并且在指定时间内接收到指定数量的其他哨兵的确认反馈时的一种状态。</li>
</ul>
<p><strong>主观下线表示哨兵通过检测发现节点宕机，客观下线表示哨兵不但自己认为该节点宕机，而且该哨兵与其他节点沟通后，达到一定数量的哨兵都认为节点宕机了。</strong></p>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>Sentinel 判定主节点客观宕机（ODOWN）后，将进入故障转移过程。</p>
<p>进入故障转移的前提是：<strong>主节点为客观宕机状态</strong>，当前<strong>没有故障转移在执行、上次故障转移已经超时</strong>。Sentinel 确认可以执行故障转移后，会进行以下几项准备工作：</p>
<ul>
<li>故障转移等待开始；<br>设置 failover_state: SENTINEL_FAILOVER_STATE_WAIT_START </li>
<li>主节点处于故障转移过程中<br>设置当前主节点标识位：SRI_FAILOVER_IN_PROGRESS （主节点处于故障转移过程中）</li>
<li>记录故障转移开始时间以及 failover_state 状态修改时间；</li>
</ul>
<h4 id="Sentinel-故障转移-Leader-选举"><a href="#Sentinel-故障转移-Leader-选举" class="headerlink" title="Sentinel 故障转移 Leader 选举"></a>Sentinel 故障转移 Leader 选举</h4><p><strong>当一个主节点被判断为客观下线时，监控这个主节点的所有 Sentinel 会进行协商，选举一个 Leader 对下线的主节点执行故障转移操作。</strong><br>Sentinel 需要在集群内进行”拉票”，”拉票” 的依据就是配置 quorum 以及 “拉票”的时间。</p>
<ul>
<li><strong>配置 quorum 越大，优先级越高；</strong></li>
<li><strong>“拉票” 请求时间越早，优先级越高；</strong></li>
</ul>
<p>“投票”完成后就到了”唱票”环节，该过程是在 <code>SENTINEL_FAILOVER_STATE_WAIT_START</code> 状态下执行的。</p>
<p>Redis 使用了 Raft 算法实现领导者选举，大体思路：</p>
<ul>
<li>每个在线的 Sentinel 节点都有资格成为 Leader, 每个 Sentinel 节点发现当它确认主节点客观下线检查的时候，会向其他 Sentinel 节点发送<br><code>sentinel is-master-down-by-addr</code> 命令，要求将自己设置为<code>leader</code></li>
<li>每个节点在每个选举轮次中只有一次投票权，接收到命令的 Sentinel 节点，如果没有同意过其他 Sentinel 节点的 <code>sentinel is-master-down-by-addr</code> 命令，<br>将同意该请求，否则拒绝</li>
<li>如果该 Sentinel 节点发现自己的票数已经大于等于 max (quorum, num(sentinels)/ 2 + 1),那么它将成为领导者。其他的投票就会终止，即使后续还有其他的哨兵节点到达配置，也没有作用</li>
<li>如果此过程中没有产生领导者，暂停一段时间，再进行下一轮选举，current_epoch 加 1<br>合理部署 Sentinel 的节点的个数，以及配置 sentinel 选举的法定人数<ol>
<li>sentinel 节点个数最好 &gt;= 3.</li>
<li>sentinel 节点个数最好是奇数.</li>
<li>sentinel 的选举法定人数设置为 （n/2 + 1）</li>
</ol>
</li>
</ul>
<p>配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sentinel.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>quorum</code> 是<strong>法定人数</strong>。作用：多个 sentinel 进行相互选举，有超过<strong>法定人数</strong>的 sentinel 选举某个 sentinel 为 leader,那么他就成为 leader,<br>leader 负责故障转移。这个法定人数，一般配置为 （n/2 + 1）较为合理</p>
<h4 id="新主节点的选举"><a href="#新主节点的选举" class="headerlink" title="新主节点的选举"></a>新主节点的选举</h4><p><strong>当主节点客观下线时，Sentinel Leader 会从该主节点存活的从节点中选出一个新的主节点。</strong><br>首先，过滤掉相关从节点：</p>
<ul>
<li>主观下线的或者处于断线状态的从节点；</li>
<li>最近 5s 内未回复过 Sentinel Leader INFO 命令的从节点；</li>
<li>从节点的优先级为 0 的从节点，由配置项 replica-priority 决定；</li>
<li>与主节点断开连接超过 10 倍 <code>down-after-milliseconds</code> 的从节点；</li>
</ul>
<p>当 Sentinel 集群选举出 Sentinel Leader 后，由 Sentinel Leader 从 redis 从节点中选择一个 redis 节点作为主节点：</p>
<ul>
<li><ol>
<li>过滤故障的节点</li>
</ol>
</li>
<li><ol start="2">
<li>选择优先级 <code>slave-priority</code> 最大的从节点作为主节点，如不存在则继续</li>
</ol>
</li>
<li><ol start="3">
<li>选择复制偏移量最大的从节点作为主节点，如不存在则继续</li>
</ol>
</li>
<li><ol start="4">
<li>选择 runid（redis 每次启动的时候生成随机的 runid 作为 redis 的标识）最小的从节点作为主节点</li>
</ol>
</li>
</ul>
<h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><p>Redis 集群是 Redis 3.0 版本推出的 Redis 集群方案，将数据分布在不同的主服务器上，以此来降低系统对单主节点的依赖，并且可以大大提高 Redis 服务的读写性能。</p>
<p>Redis 集群除了拥有主从模式 + 哨兵模式的所有功能之外，还提供了多个主从节点的集群功能，实现了真正意义上的分布式集群服务。<br>Redis 集群可以实现数据分片服务，也就是说在 Redis 集群中有 16384 个槽位来存储所有的数据，当我们有 N 个主节点时，可以把 16384 个槽位平均分配到 N 台主服务器上。<br>当有 key-value 存储时，Redis 会使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384进行取模来得到具体槽位，再把此值存储在对应的服务器上，读取操作也是同样的道理，这样我们就实现了数据分片的功能。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 进程、线程、协程</title>
    <url>/posts/76b43893/</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>参考：<a href="https://www.cnblogs.com/panlq/p/13180589.html">https://www.cnblogs.com/panlq/p/13180589.html</a><br><strong>进程是系统进行资源分配和调度的独立单位，<code>程序段</code>、<code>数据段</code>、<code>PCB(进程控制模块)</code>三部分组成了<code>进程 实体(进程映像)</code>，PCB 是进程存在的唯一标准</strong></p>
<blockquote>
<p>操作系统为了管理进程设置的一个专门的<code>数据结构</code>，用它来记录进程的外部特征，描述进程的运动变化进程。系统利用 PCB 来控制和管理进程，所以 <strong>PCB 是系统感知进程存在的唯一标志</strong>。进程与 PCB 是一一对应的。<br>detail: <a href="http://www.haodaquan.com/159">http://www.haodaquan.com/159</a></p>
</blockquote>
<h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><p><img src="../../images/threads/PCB.png" alt="direct"></p>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><ul>
<li><strong>创建态</strong><br>操作系统为进程分配资源， 初始化 PCB</li>
<li><strong>就绪态</strong><br>运行资源等条件都满足，存储在就绪队列中，等待 CPU 调度</li>
<li><strong>运行态</strong><br>CPU 正在执行进程</li>
<li><strong>阻塞态</strong><br>等待某些条件满足，等待消息回复，等待同步锁，Sleep 等，阻塞队列</li>
<li><strong>终止态</strong><br>回收进程拥有的资源，撤销 PCB</li>
</ul>
<h2 id="进程之间的转换"><a href="#进程之间的转换" class="headerlink" title="进程之间的转换"></a>进程之间的转换</h2><p><img src="../../images/threads/%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png" alt="img.png"></p>
<h3 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h3><blockquote>
<p>进程的调度、切换是有代价的</p>
</blockquote>
<ul>
<li><ol>
<li>对原来运行进程的各种数据的保存</li>
</ol>
</li>
<li><ol start="2">
<li>对新的进程各种数据恢复(程序计数器，程序状态字，各种数据寄存器的现场)<br>进程调度算法的相关参数：</li>
</ol>
</li>
<li>CPU 利用率：CPU 工作时间/作业完成的总时间</li>
<li>系统吞吐量: 单位时间内完成作业的数量</li>
<li>周转时间: 从作业被提交给系统开始，到作业完成为止的时间间隔 = 作业完成时间 - 作业提交时间</li>
<li>带权周转时间: (由于周转时间相同的情况下，可能实际作业的运行时间不一样，这样就会给用户带来不一样的感觉)<br>作业周转时间/作业实际运行时间，带权周转时间 &gt;= 1, 越小越好</li>
<li>平均带权周转时间: 各作业带权周转时间之和/作业数</li>
<li>等待时间</li>
<li>响应时间</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>算法思想？用于解决什么问题<br>算法规则，用于作业（PCB作业）调度还是进程调度<br>抢占式的还是非抢占式的？<br>优缺点？是否会导致饥饿？</p>
<h3 id="当前交互式系统常用调度算法"><a href="#当前交互式系统常用调度算法" class="headerlink" title="当前交互式系统常用调度算法"></a>当前交互式系统常用调度算法</h3><ul>
<li><strong>时间片轮转(Round-Robin)</strong><ul>
<li>算法思想: 公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内可以得到响应</li>
<li>算法规则: 按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(例如：100ms),若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</li>
<li>用于作业/进程调度: 用于进程的调度（只有作业放入内存）</li>
<li>是否可抢占？若进程未能在规定时间片内完成，将被强行剥夺处理机使用权，由时钟装置发出时钟终端信号来通知 CPU 时间片到达</li>
<li>优缺点: 适用于分时操作系统，由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度</li>
<li>是否会导致饥饿：不会</li>
</ul>
</li>
<li><strong>优先级调度算法</strong><ul>
<li>算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的进程程度决定处理顺序</li>
<li>算法规则: 每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li>
<li>用于作业/进程调度: 即可用于作业调度（处于外存后备队列中的作业调度进内存），也可用于进程调度(选择就绪队列中的进程，为其分配处理机)，甚至 I/O 调度</li>
<li>是否可抢占？具有可抢占版本，也有非抢占式的</li>
<li>优缺点: 适用于实时操作系统，用优先级区分紧急程度，可灵活地调整对各种作业/及进程的偏好程度。缺点：会导致饥饿</li>
<li>是否会导致饥饿：会</li>
</ul>
</li>
<li><strong>多级反馈队列调度算法</strong><br>维护了多个按照<strong>优先级从高到低</strong>的进程队列，且每个队列时间片不一致，采用抢占式算法调度。<ul>
<li>算法思想：综合 FCFS、SJF(SPF)、时间片轮转、优先级调度</li>
<li>算法规则：<ul>
<li><ol>
<li>设置多级别就绪队列，各级别队列优先级从高到低，时间片从小到大</li>
</ol>
</li>
<li><ol start="2">
<li>新进程到达时先进入第 1 级队列，按照 FCFS 原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾</li>
</ol>
</li>
<li><ol start="3">
<li>只有第 k 级别队列为空是，才会为 K+1 级对头的进程分配时间片</li>
</ol>
</li>
</ul>
</li>
<li>用于作业/进程调度：用于进程调度</li>
<li>是否可抢占？抢占式算法。在 k 级队列的进程运行过程中，若更上级别的队列（1-k-1级）中进入一个新进程，则由于新进程处于优先级高的队列中，因此新进程会抢占处理机，原本运行的进程放回 k 级别队列队尾。</li>
<li>优缺点：对各类的进程相对公平(FCFS 的有点)；每个新到达的进程都可以很快就得到响应（RR优点）；短进程只用较少的时间就可以完成（SPF）的优点；不必实现估计进程的运行时间；可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I/O 密集型进程（可以将因 I/O 而阻塞的进程重新放回原队列，这样 I/O 形进程就可以保持较高优先级）</li>
<li>是否会导致饥饿感：会</li>
</ul>
</li>
</ul>
<p>相关知识：<a href="https://www.cnblogs.com/whu-2017/p/9477391.html">https://www.cnblogs.com/whu-2017/p/9477391.html</a><br>例题:<br><img src="../../images/threads/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95.png" alt="img.png"></p>
<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><p>参考：<a href="https://www.jianshu.com/p/c1015f5ffa74">https://www.jianshu.com/p/c1015f5ffa74</a><br>在计算机系统中，进程之间有时需要进行数据的通信，但是不同进程之间的数据存储是相互隔离的，每一个进程都只能访问自己占有的数据，这时我们就需要使用用于进程间的通信的机制了<br>不过，出来套接字外，进程间的通信的前提是两进程必须是父子进程关系，没有这种关系的进程间是不能直接进行通信，而是需要利用其共同的父进程进行信息的中转</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><blockquote>
<p>管道通信在系统中，是以文件的方式进行读写的，匿名管道在物理上由文件系统的高速缓冲区构成，而命名管道则可在系统的临时文件中找到具体的文件，相当于通过外部文件来交流信息。<br>父子进程间以比特流、字符流的方式传递信息。管道属于半双工通信，在父子进程中同时创建一对管道，然后利用其中一端(0端)来读数据，另一端来写数据。</p>
</blockquote>
<h4 id="python-实现匿名管道"><a href="#python-实现匿名管道" class="headerlink" title="python 实现匿名管道"></a>python 实现匿名管道</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc1</span>(<span class="params">pipe0, pipe1</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[proc1] 发送：  &quot;</span>, i)</span><br><span class="line">        pipe0.send(i)</span><br><span class="line">        pipe1.send(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[proc1] proc2 接收:&#x27;</span>, pipe0.recv())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[proc1] proc3 接收:&#x27;</span>, pipe1.recv())</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc2</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = pipe.recv()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[proc2] proc2 接收:&#x27;</span>, msg)</span><br><span class="line">        pipe.send(<span class="string">&#x27;proc2收到数据：&#x27;</span> + <span class="built_in">str</span>(msg))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc3</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = pipe.recv()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[proc3] proc3 接收:&#x27;</span>, msg)</span><br><span class="line">        pipe.send(<span class="string">&#x27;proc3收到数据：&#x27;</span> + <span class="built_in">str</span>(msg))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build a pipe</span></span><br><span class="line">    pipe0 = multiprocessing.Pipe()</span><br><span class="line">    pipe1 = multiprocessing.Pipe()</span><br><span class="line">    <span class="built_in">print</span>(pipe0)</span><br><span class="line">    <span class="built_in">print</span>(pipe1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Pass an end of the pipe to process 1</span></span><br><span class="line">    p1 = multiprocessing.Process(target=proc1, args=(pipe0[<span class="number">0</span>], pipe1[<span class="number">0</span>],))</span><br><span class="line">    <span class="comment"># Pass the other end of the pipe to process 2</span></span><br><span class="line">    p2 = multiprocessing.Process(target=proc2, args=(pipe0[<span class="number">1</span>],))</span><br><span class="line">    <span class="comment"># Pass the other end of the pipe to process 3</span></span><br><span class="line">    p3 = multiprocessing.Process(target=proc3, args=(pipe1[<span class="number">1</span>],))</span><br><span class="line"></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br></pre></td></tr></table></figure>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li>生产者进程生产产品，消费者进程消费产品</li>
<li>当生产者进程生产产品时，如果没有空缓冲区可用，那么生产者进程必须等待消费者进程释放出一个缓冲区</li>
<li>当消费者进程消费产品时，如果缓冲区中没有产品，那么消费者进程将被阻塞，直到新的产品被生产出来。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing.sharedctypes <span class="keyword">import</span> Array</span><br><span class="line"></span><br><span class="line">a = Array(<span class="string">&#x27;i&#x27;</span>, [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)])  <span class="comment"># 共享内存</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">semaphore_num = multiprocessing.Semaphore(<span class="number">0</span>)  <span class="comment"># 产品个数</span></span><br><span class="line">semaphore_empty = multiprocessing.Semaphore(<span class="number">20</span>)  <span class="comment"># 缓冲区空位个数n</span></span><br><span class="line">semaphore_mutex = multiprocessing.Semaphore(<span class="number">1</span>)  <span class="comment"># 对缓冲区进行操作的互斥信号量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">flag</span>):</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">global</span> no</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;消费者 &quot;</span> + <span class="built_in">str</span>(flag) + <span class="string">&quot; 等待中...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        item = random.randint(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(item):</span><br><span class="line">            semaphore_num.acquire()  <span class="comment"># 消费 -1</span></span><br><span class="line">            semaphore_mutex.acquire()  <span class="comment"># 加锁</span></span><br><span class="line">            no = a[<span class="number">0</span>]</span><br><span class="line">            num = a[<span class="number">1</span>]</span><br><span class="line">            num -= <span class="number">1</span></span><br><span class="line">            no += <span class="number">1</span></span><br><span class="line">            a[<span class="number">0</span>] = no</span><br><span class="line">            a[<span class="number">1</span>] = num</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(no) + <span class="string">&quot; [消费者 &quot;</span> + <span class="built_in">str</span>(flag) + <span class="string">&quot;] 消费产品 1. 剩余： &quot;</span> + <span class="built_in">str</span>(num))</span><br><span class="line">            semaphore_mutex.release()  <span class="comment"># 开锁</span></span><br><span class="line">            semaphore_empty.release()  <span class="comment"># 释放空位 +1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>():</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">global</span> no</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;生产者开始生产...&quot;</span>)</span><br><span class="line">        item = random.randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;生产个数：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(item))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(item):</span><br><span class="line">            semaphore_empty.acquire()  <span class="comment"># 占用空位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(item):</span><br><span class="line">            semaphore_mutex.acquire()  <span class="comment"># 加锁</span></span><br><span class="line">            no = a[<span class="number">0</span>]</span><br><span class="line">            num = a[<span class="number">1</span>]</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            no += <span class="number">1</span></span><br><span class="line">            a[<span class="number">0</span>] = no</span><br><span class="line">            a[<span class="number">1</span>] = num</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(no) + <span class="string">&quot; [生产者] 生产产品 1. 剩余： &quot;</span> + <span class="built_in">str</span>(num))</span><br><span class="line">            semaphore_mutex.release()  <span class="comment"># 开锁</span></span><br><span class="line">            semaphore_num.release()  <span class="comment"># 生产</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    p1 = multiprocessing.Process(target=producer)</span><br><span class="line">    p2 = multiprocessing.Process(target=consumer, args=(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">    p3 = multiprocessing.Process(target=consumer, args=(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序结束&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">size = <span class="number">8</span> * <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pro1</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pro2</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, size):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[porc2] 写入：  &quot;</span>, i)</span><br><span class="line">        a[i] = i</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pro3</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, size):</span><br><span class="line">        msg = a[i]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[pro3] pro3 读出：&#x27;</span>, msg)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing.sharedctypes <span class="keyword">import</span> Array</span><br><span class="line"></span><br><span class="line">a = Array(<span class="string">&#x27;i&#x27;</span>, [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size)])</span><br><span class="line"></span><br><span class="line">p1 = multiprocessing.Process(target=pro1, args=(a,))</span><br><span class="line">p2 = multiprocessing.Process(target=pro2, args=(a,))</span><br><span class="line">p3 = multiprocessing.Process(target=pro3, args=(a,))</span><br><span class="line"></span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br><span class="line">p3.start()</span><br><span class="line"></span><br><span class="line">p1.join()</span><br><span class="line">p2.join()</span><br><span class="line">p3.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="socket-套接字"><a href="#socket-套接字" class="headerlink" title="socket 套接字"></a>socket 套接字</h3><blockquote>
<p>套接字是网络进程通信的机制，一般是用于位于不同机器上的进程间的通信。很多网络程序如即时通讯软件、游戏、浏览器<br>数据库等，都往往使用的这种机制。<br>参考：<a href="https://blog.ailemon.net/2018/01/21/python-implement-about-socket-connection/">https://blog.ailemon.net/2018/01/21/python-implement-about-socket-connection/</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientProcess</span>(<span class="params">multiprocessing.Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,conn,addr</span>):</span></span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.conn = conn</span><br><span class="line">        self.addr = addr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.conn.sendall(<span class="built_in">bytes</span>(<span class="string">&quot;你好，我是AI柠檬~&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">        ret_timeout = <span class="built_in">str</span>(self.conn.recv(<span class="number">1024</span>),encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        self.conn.settimeout(<span class="built_in">int</span>(ret_timeout))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                ret = <span class="built_in">str</span>(self.conn.recv(<span class="number">1024</span>),encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">                self.conn.sendall(<span class="built_in">bytes</span>(<span class="string">&quot;我收到了你的信息：&quot;</span>+ret,encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">                <span class="keyword">if</span>(ret==<span class="string">&quot;:q&quot;</span>):</span><br><span class="line">                    self.conn.close()</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">                self.conn.close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = socket.socket()</span><br><span class="line">    inp_addr = <span class="built_in">input</span>(<span class="string">&quot;Please input this server&#x27;s ip address:\n&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    inp_port = <span class="built_in">input</span>(<span class="string">&quot;Please input this server&#x27;s port:\n&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    s.bind((inp_addr,<span class="built_in">int</span>(inp_port)))</span><br><span class="line">    s.listen()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;服务器已开启&quot;</span>)</span><br><span class="line">    users = []</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        conn,addr=s.accept()</span><br><span class="line">        </span><br><span class="line">        p = ClientProcess(conn,addr)</span><br><span class="line">        p.start()</span><br><span class="line">        users.append(p)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;有一个新用户连接，进程号pid:&quot;</span>, p.pid)</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        tmp_users=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(users)):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(users[i].is_alive()==<span class="literal">True</span>):</span><br><span class="line">                tmp_users.append(users[i])</span><br><span class="line">            </span><br><span class="line">        users = tmp_users</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前用户数：&quot;</span>, <span class="built_in">len</span>(users))</span><br><span class="line">    s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">obj = socket.socket()</span><br><span class="line"></span><br><span class="line">inp_addr = <span class="built_in">input</span>(<span class="string">&quot;Please input server&#x27;s ip address:\n&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">inp_port = <span class="built_in">input</span>(<span class="string">&quot;Please input server&#x27;s port:\n&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">obj.connect((inp_addr,<span class="built_in">int</span>(inp_port)))</span><br><span class="line"></span><br><span class="line">inp_timeout = <span class="built_in">input</span>(<span class="string">&quot;Please input timeout(s):\n&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">obj.sendall(<span class="built_in">bytes</span>(inp_timeout,encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">obj.settimeout(<span class="built_in">int</span>(inp_timeout))</span><br><span class="line"></span><br><span class="line">msg = <span class="built_in">str</span>(obj.recv(<span class="number">1024</span>),encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    inp = <span class="built_in">input</span>(<span class="string">&quot;Please(:q\退出):\n&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(inp!=<span class="string">&quot;&quot;</span>):</span><br><span class="line">        obj.sendall(<span class="built_in">bytes</span>(inp,encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span>(inp == <span class="string">&quot;:q&quot;</span>):</span><br><span class="line">        obj.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ret = <span class="built_in">str</span>(obj.recv(<span class="number">1024</span>),encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(ret)</span><br><span class="line">    <span class="keyword">except</span> socket.timeout:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[Error]Network Connection Time Out!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[Error]Unknown Network Connection Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><strong>线程是 CPU 进行调度的基本单位</strong><br><img src="../../images/threads/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AF%B9%E6%AF%94.png" alt="img.png"><br>类比：<br>去图书馆看书。<br>切换进程运行环境：有一个不认识的人要用桌子，你需要把你的书收走，他把自己的书放到桌子上<br>同一进程内的线程切换=你的舍友要用这张书桌，可以不把桌子上的书收走</p>
<h2 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h2><ul>
<li>线程是处理机调度的单位</li>
<li>多 CPU 计算机中，各个线程可占用不同的 CPU</li>
<li>每个线程都有一个线程 ID、线程控制块（TCB）</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，开销很大</li>
</ul>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><ul>
<li><strong>用户级线程(User-Level Thread)</strong>, <strong>用户级线程是由应用程序通过线程库实现</strong>，如 python(thread), 线程的管理由应用程序负责</li>
<li><strong>内核级线程(kernel-Level Thread)</strong>, <strong>内核级线程的管理工作由操作系统内核完成，线程调度，切换等工作都由内核负责</strong>，因此内核级线程的切换必然需要在核心态下才能完成</li>
</ul>
<p>进程和线程关系：一条线程指的是<strong>进程中一个单一顺序的控制流</strong>，一个进程中可以并发多个线程，每条线程并行执行不同的任务。CPU 的最小调度单元是线程。</p>
<h2 id="线程的基本状态"><a href="#线程的基本状态" class="headerlink" title="线程的基本状态"></a>线程的基本状态</h2><ul>
<li>新建（New）: 线程在进程内派生出来，它即可由进程派生，也可由线程派生</li>
<li>阻塞（blocked）: 线程运行过程中，可能由于各种进入阻塞状态<ul>
<li>通过 sleep 方法进入睡眠状态</li>
<li>线程调用一个在 I/O 阻塞的操作，即该操作在输入输出操作完成之前不会返回它的调用者</li>
<li>试图得到一个锁，而该锁被其他线程持有</li>
<li>等待某个触发条件</li>
</ul>
</li>
<li>就绪（ready）：一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的 start()方法。<br>当线程对象调用 start()方法返回后，线程就处于就绪状态。处于就绪状态的线程并不一定运行 run()方法，线程还必须同其他线程竞争 CPU 时间，只有获得 CPU 时间才可以运行线程</li>
<li>运行(running): 线程后的 CPU 时间后，进入运行状态真正开始执行 run() 方法</li>
<li>死亡(dead): 线程退出自然死亡，或者异常终止导致线程猝死<br><img src="../../images/threads/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="img.png"></li>
</ul>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="用户级线程模型（一对多模型）"><a href="#用户级线程模型（一对多模型）" class="headerlink" title="用户级线程模型（一对多模型）"></a>用户级线程模型（一对多模型）</h3><p><img src="../../images/threads/thread_1.png" alt="img.png"><br><strong>多个用户态的线程对应着一个内核线程，程序的创建、终止、切换或者同步等线程工作必须自身来完成</strong>。python 就是这种。虽然可以实现异步，但是不能有效利用多核（GIL）</p>
<h3 id="内核级别线程模型（一对一）"><a href="#内核级别线程模型（一对一）" class="headerlink" title="内核级别线程模型（一对一）"></a>内核级别线程模型（一对一）</h3><p><img src="../../images/threads/thread_2.png" alt="img.png"><br>这种模型直接<strong>调用操作系统的内核线程，所有线程的创建、终止、切换、同步等操作，都由内核来完成</strong>。C++ 就是这种</p>
<h3 id="两级线程模型-M-N"><a href="#两级线程模型-M-N" class="headerlink" title="两级线程模型(M:N)"></a>两级线程模型(M:N)</h3><p><img src="../../images/threads/thread_3.png" alt="img.png"><br>这种线程模型会<strong>先创建多个内核级线程，然后用自身的用户级线程去对应创建的多个内核级线程</strong>，自身的用户级线程需要本身程度去调度，内核级的线程交给操作系统内核去调度。<br>GO 语言就是这种</p>
<h3 id="线程总结"><a href="#线程总结" class="headerlink" title="线程总结"></a>线程总结</h3><p>python 中的多线程因为 GIL 的存在，并不能利用多核CPU优势，但是在阻塞的系统调用中，如 sock.connect(),<br>sock.recv() 等耗时的 I/O 操作，当前的线程会释放 GIL,让出处理器。但是单个线程内，阻塞调用上还是阻塞的。除了 GIL 之外，所有的多线程还有通病，它们的调度策略是抢占式的，以保证同等优先级的线程都有机执行，带来的问题就是：<br>并不知道下一刻执行那个线程，也不知道正在执行什么代码，会存在<strong>竞态条件</strong></p>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程通过在线程中实现调度，避免了陷入内核级别的上下文切换造成的性能损失，进而突破了线程在 IO 上的性能瓶颈。</p>
<h2 id="python-协程"><a href="#python-协程" class="headerlink" title="python 协程"></a>python 协程</h2><p><strong>eventloop 协程模型</strong><br>python 的协程源于 yield 指令</p>
<ul>
<li>yield item 用于产出一个值，反馈给 next() 的调用方法</li>
<li>让出处理机，暂停执行生成器，让调用方继续工作，直到需要使用另一个值时再调用 next()</li>
</ul>
<p>协程式对线程的调度，yield 类似惰性求职方式可以视为一种流程控制工具，实现协作式多任务，python3.5引入了 async/await 表达式，使得协程证实在语言层面得到支持和优化，大大简化之前的 yield 写法。<br>python 中的协程的调度是非抢占式的，也就是说一个协程必须主动让出执行机会，其他协程才有机会运行。让出执行的关键字 await,如果一个协程阻塞了，持续不让出 CPU 处理机，那么整个线程就卡住了，没有任何并发。</p>
<h2 id="go-协程"><a href="#go-协程" class="headerlink" title="go 协程"></a>go 协程</h2><p>go - <strong>GMP模型</strong><br>go 语言使用 go 关键字，goroutine 之间使用 channel 通信</p>
<p>go 实现了两种并发形式：</p>
<ul>
<li>多线程共享内存：如 Java 或者 C++ 在多线程中共享数据的时候，通过锁来访问</li>
<li>Go 语言特有的，也是 Go 语言推荐的 <strong>CSP （communicating sequential processes）并发模型</strong></li>
</ul>
<p><strong>协程本质上来说是一种用户态的线程，不需要系统来执行抢占式调度，而是在语言层面实现线程的调度。</strong></p>
<p>go 协程是<strong>轻量级</strong>的，栈初始为 2KB(os 操作系统的线程一般都是固有的栈内存 2M)，调度不涉及系统调用，用户函数调用前会检查栈空间是否充足，不够的话，会进行栈扩容，栈大小限制可以达到 1GB。</p>
<p>Go 语言相比起其他语言的优势在于 OS 线程是由 OS 内核来调度的，<strong>goroutine 则是由 Go 运行时（runtime）自己的调度器调度的</strong>，这个调度器使用一个称为 m:n 调度的技术。<br>其一大特点是 goroutine 的调度是在用户态下完成的，不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池，不直接调用系统的 malloc 函数，成本比调度 OS 线程低很多。<br>另外一方面<strong>充分利用了多核的硬件资源，近似的把若干 goroutine 均分在物理线程上。</strong></p>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie &amp;&amp; Session &amp;&amp; JWT 使用总结</title>
    <url>/posts/ea9b1fcc/</url>
    <content><![CDATA[<h1 id="认证-授权-凭证"><a href="#认证-授权-凭证" class="headerlink" title="认证-授权-凭证"></a>认证-授权-凭证</h1><h2 id="什么是认证"><a href="#什么是认证" class="headerlink" title="什么是认证"></a>什么是认证</h2><p><strong>认证就是验证当前用户的身份</strong>：<br>互联网中的认证：</p>
<ul>
<li>用户名密码登陆</li>
<li>邮箱发送登陆连接验证</li>
<li>手机号接收验证码</li>
</ul>
<h2 id="什么是授权"><a href="#什么是授权" class="headerlink" title="什么是授权"></a>什么是授权</h2><p>用户授权第三方应用访问该用户某些资源的权限</p>
<ul>
<li>你在安装手机应用的时候，APP 会询问是否允许授予权限（地址获取，存储权限获取）</li>
<li>微信访问小程序时，登陆时，小程序会询问是否允许授予权限</li>
<li>实现授权的方式：cookie、session、token、OAuth</li>
</ul>
<h2 id="什么是凭证-Credentials"><a href="#什么是凭证-Credentials" class="headerlink" title="什么是凭证(Credentials)"></a>什么是凭证(Credentials)</h2><p>实现认证和授权的前提是需要一种<strong>媒介（证书）</strong>来标记访问者身份</p>
<p>在互联网应用中一般网站（如掘金）会有两种模式，游客模式和登陆模式。游客模式中，可以正常浏览网站上面的文章，但是一旦想要点赞/收藏/分享文章，就需要登陆或者注册账号。<br>当用户登陆成功后，服务器会给该用户使用的浏览器颁发一个令牌（token）,这个林牌用来表明你的身份，每次浏览器发送请求时就会带上这个令牌，就可以使用游客模式下无法使用的功能。</p>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><ul>
<li><p><strong>HTTP 是无状态的协议</strong>（对于网络请求没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是独立的，服务端无法确认当前访问者的身份信息。<br>所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后端前后两个请求是否来自同一浏览器。而这个状态通过 cookie 或者 session 去实现。</p>
</li>
<li><p><strong>cookie 存储在客户端</strong>：cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p>
</li>
<li><p><strong>cookie 是不可跨域的</strong>：每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。</p>
</li>
</ul>
<p>cookie 常用的属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name=value</td>
<td>key-value,设置 Cookie 的名称及相对应的值，都必须是<strong>字符串类型</strong><br />- 如果值为 Unicode 字符，需要为字符编码<br />- 如果值为二进制数据，则需要使用 BASE64 编码</td>
</tr>
<tr>
<td>domain</td>
<td>指定 cookie 所属域名，默认是当前域名</td>
</tr>
<tr>
<td>path</td>
<td><strong>指定 cookie 在哪个路径（路由）下生效，默认是 ‘/‘</strong><br />如果设置为 <code>/abc</code>，则只有 <code>/abc</code>下的路由可以访问到该 cookie，如：<code>abc/read</code></td>
</tr>
<tr>
<td>maxAge</td>
<td>cookie 失效时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie。如果为 0 ,表示删除该 cookie。默认为 -1。</td>
</tr>
<tr>
<td>expires</td>
<td>过期时间，在设置的某个时间点后该 cookie 就会失效。<br />一般浏览器的 cookie 都是默认存储的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除。</td>
</tr>
<tr>
<td>secure</td>
<td>该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 False</td>
</tr>
<tr>
<td>httpOnly</td>
<td><strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie,所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong></td>
</tr>
</tbody></table>
<h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><ul>
<li>session 是另一种记录服务器和客户端<strong>会话状态</strong>的机制</li>
<li>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储在客户端的 cookie 中</li>
</ul>
<p><img src="/images/session.png" alt="direct"></p>
<h2 id="session-认证流程"><a href="#session-认证流程" class="headerlink" title="session 认证流程"></a>session 认证流程</h2><ul>
<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li>
<li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li>
<li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息发送给客户端，服务端会从 Cookie 中获取 SessionID, 再根据 SessionID 查找对应的 Session 信息，如果没有找到说民用户没有登陆或者登陆失败，如果找到 Session 证明用户已经登陆可执行后面操作。</li>
</ul>
<p><strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登陆状态</p>
<h1 id="Cookie-和-Session-区别"><a href="#Cookie-和-Session-区别" class="headerlink" title="Cookie 和 Session 区别"></a>Cookie 和 Session 区别</h1><ul>
<li><strong>安全性</strong>：Session 比 Cookie 安全，Session 是<strong>存储在服务器端</strong>的，Cookie 是<strong>存储在客户端</strong>的。</li>
<li><strong>存取值的类型不同</strong>：Cookie 只支持存<strong>字符串</strong>数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型</li>
<li><strong>有效性不同</strong>：Cookie 可设置长时间保持，比如我们经常使用默认登陆功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效</li>
<li><strong>存储大小不同</strong>：单个 Cookie 保存的<strong>数据不能超过 4K</strong>，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li>
</ul>
<h1 id="Token-（令牌）"><a href="#Token-（令牌）" class="headerlink" title="Token （令牌）"></a>Token （令牌）</h1><h2 id="Acess-Token"><a href="#Acess-Token" class="headerlink" title="Acess Token"></a>Acess Token</h2><ul>
<li>访问资源接口（API）时所需要的资源凭证</li>
<li>简单 token 的组成：<code>uid(用户唯一的身份标识)</code>、<code>time(当前时间的时间戳)</code>、<code>sign</code>(签名，token 的前几位以哈希算法压缩成一定长度的十六进制字符串)</li>
<li>特点：<ul>
<li><strong>服务端无状态化、可扩展性好</strong></li>
<li><strong>支持移动端设备</strong></li>
<li>安全</li>
<li>支持跨程序调用</li>
</ul>
</li>
</ul>
<h3 id="tocken-的身份验证流程："><a href="#tocken-的身份验证流程：" class="headerlink" title="tocken 的身份验证流程："></a>tocken 的身份验证流程：</h3><p><img src="/images/token_verify.png" alt="direct"></p>
<ul>
<li><ol>
<li>客户端使用用户名跟密码请求登陆</li>
</ol>
</li>
<li><ol start="2">
<li>服务端收到请求，去验证用户端与密码</li>
</ol>
</li>
<li><ol start="3">
<li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li>
</ol>
</li>
<li><ol start="4">
<li>客户端收到 token 后，会把它存储起来，比如放在 <code>cookie</code> 或者 <code>localStorage</code> 里</li>
</ol>
</li>
<li><ol start="5">
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li>
</ol>
</li>
<li><ol start="6">
<li>服务端收到请求，然后去验证客户端请求里面带着的 token，如果验证成功，就向客户端返回请求的数据</li>
</ol>
</li>
</ul>
<p>特点：</p>
<ul>
<li><strong>每一次请求都需要携带 token,需要把 token 放在 HTTP 的 Header 里</strong></li>
<li><strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不同存放 token 数据。用解析 token 的计算方式换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</strong></li>
<li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li>
</ul>
<h2 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h2><p><img src="/images/refresh_token.png" alt="direct"></p>
<ul>
<li>refresh token 是专门用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登陆用户名和密码，比较麻烦。有了 refresh token，就可以减少这个麻烦，<br>客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。</li>
</ul>
<h2 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a>Token 和 Session 的区别</h2><ul>
<li>Session 是一种<strong>记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。</strong></li>
<li>Token 是<strong>令牌</strong>，**访问资源接口（API）时所需要的资源凭证。Token <strong>使服务端无状态化，不会存储会话信息</strong></li>
<li>作为身份验证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。</li>
<li>所谓的 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂时认为是安全的。而 Token，如果指的是 OAuth Token 或类似机制的话，提供的是认证和授权，认证是针对用户，授权是指的 App。其目的是让某 App 有权利访问某用户的信息。<br>这里的 <strong>Token 是唯一的</strong>（每个项目的 secret 还是相关信息不同）。不可以转移到其他 App 上，也不可以转到其他用户上。</li>
<li>Session 只是提供一种简单的认证，即只要有此 SessionID,即认为有此 User 的全部权限。是需要严格保密的，这个数据只是保存在服务器上，不应该共享给其他往后在哪或者第三方 App。<br>所以简单来说：<ul>
<li><strong>如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token。若永远只是自己的 website 则可以用 Seesion</strong>。</li>
</ul>
</li>
</ul>
<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><ul>
<li>Json Web Token 是目前前后端分离的<strong>跨域认证</strong>解决方案</li>
<li>是一种<strong>认证授权</strong>机制</li>
<li>基于 JSON 的开放标准（RFC 7519）</li>
<li>使用 HMAC 算法或者是 RSA 的公/私密钥对 JWT 进行签名。<br><img src="/images/JWT.png" alt="direct"></li>
</ul>
<p>这里参考：<a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></p>
<p>用户认证流程：</p>
<ul>
<li>客户端使用用户名和密码来请求服务器进行登陆</li>
<li>服务器进行用户名和密码的验证</li>
<li>通过验证，服务器生成一个 token 并返回给浏览器</li>
<li>客户端存储 token,存储位置为 header/localstorge/url?token=xxxxx 的方式</li>
<li>服务端验证 token 值，并返回相应的响应</li>
</ul>
<h2 id="JWT-token-数据组成格式"><a href="#JWT-token-数据组成格式" class="headerlink" title="JWT token 数据组成格式"></a>JWT token 数据组成格式</h2><p>JWT token 是一个字符串，由三部分组成，用 . 隔开</p>
<ul>
<li>头部（header）</li>
<li>载荷（payload）</li>
<li>签名（signature）</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Generate JWT token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateJwtToken</span><span class="params">(username, password <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	nowTime := time.Now()</span><br><span class="line">	expireTime := nowTime.Add(<span class="number">2</span> * time.Hour)</span><br><span class="line"></span><br><span class="line">	claims := Claims&#123;</span><br><span class="line">	    <span class="comment">// header</span></span><br><span class="line">		username,</span><br><span class="line">		password,</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// payload</span></span><br><span class="line">		jwt.StandardClaims&#123;</span><br><span class="line">			ExpiresAt: expireTime.Unix(),</span><br><span class="line">			Issuer:    PROJECTISSUE,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// signature</span></span><br><span class="line">	tokenClaims := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)</span><br><span class="line">	</span><br><span class="line">	token, err := tokenClaims.SignedString(projectSecret)</span><br><span class="line">	<span class="keyword">return</span> token, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="基于-Gin-的-JWT-实现"><a href="#基于-Gin-的-JWT-实现" class="headerlink" title="基于 Gin 的 JWT 实现"></a>基于 Gin 的 JWT 实现</h2><p>代码地址：<a href="https://github.com/tyronemaxi/Jwt-practice">https://github.com/tyronemaxi/Jwt-practice</a></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 与容器技术畅谈</title>
    <url>/posts/bc91ee72/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote>
<p>2018 年可以说是 <strong>docker 容器技术</strong> 最火热的一年，各大厂商，互联网公司都开始构建自己的容器化平台，CI/CD 工具<br>那么为什么 <strong>docker 会这么火</strong>，以及 **docker 技术内涵是什么?**，这篇文章，我将以一个学习者的身份详细解析 docker 容器化技术</p>
</blockquote>
<h1 id="为什么选择-docker"><a href="#为什么选择-docker" class="headerlink" title="为什么选择 docker"></a>为什么选择 docker</h1><p>在容器化时代到来之前，<code>AWS</code> 以及 <code>OpenStack</code> 可谓盛极一时，与此同时还有以 <code>Cloud Foundry</code> 为代表的开源 <code>PaaS</code> 项目。</p>
<p>PaaS 开源项目火热的主要原因主要是它提供了一种<strong>应用托管</strong> 的能力。各个国内外技术厂商都在进行<strong>上云</strong>体验。<br>具体的操作就是：<code>Cloud Foundry</code> 为每种主流编程语言都定义了一种打包格式，类似 <code>cf push app</code> 的操作就是将 app 的可执行文件和启动命令<br>打包进一个压缩包中，上传到 Cloud Foundry 的存储中。然后 Cloud Foundry 会通过调度器选择一个可以运行这个应用的<code>虚拟机</code>，然后通过这个机器上的 agent 将应用压缩包下载下来启动。</p>
<p>对于一个虚拟机来说，需要在其上启动很多个来自不同用户的应用，Cloud Foundry 会调用操作系统 <code>Cgroups</code> 和 <code>Namespace</code> 机制为每个应用单独创建一个<br>称作<code>沙盒</code>的隔离环境，然后在<code>沙盒</code>环境中启动这些应用，这样就形成了一个个隔离的环境运行多个应用。</p>
<p>以上就是 <strong>PaaS 项目的核心的功能，也就是容器化技术</strong>。</p>
<p>也正是和 docker 项目相同的技术核心，通过 <code>Cgroups</code> 和 <code>Namespace</code>来构建一个资源和边界，实现沙盒环境。</p>
<p>那么为什么 docker 技术为何在短短几个月就风靡全世界了？</p>
<ul>
<li><strong>实则正是 <code>docker image</code></strong></li>
</ul>
<p>对于 Paas 项目而言，将项目运行的文件打包是一件极其麻烦的事情，对于每种语言，每种框架，每个版本都需要维护一个打好的包。</p>
<p><strong>docker image 可以基于你所需要的系统文件，构建一个可以基于云端环境运行的压缩包。</strong></p>
<h2 id="容器化技术的发展"><a href="#容器化技术的发展" class="headerlink" title="容器化技术的发展"></a>容器化技术的发展</h2><p>在以上的文章中，介绍了 docker 技术为何火热的原因。<br>对于一个大型的业务应用来说，从前端，后端，到数据库系统，文件系统等，往往是需要多个容器的，那么就存在着，如何能够优雅的在云端环境有序地运行。<br>于是，docker 公司便开发出了一个<code>容器编排化的工具</code>, <strong>docker Swarm</strong> 项目</p>
<p>与此同时，Mesos 社区也开发出了一个类似的工具<code>Marathon</code>, 它虽然不能像 Swarm 那样提供原生的 Docker API, 但是其却拥有一个独特的核心竞争力：</p>
<ul>
<li><strong>超大规模集群的管理经验</strong></li>
</ul>
<p>也就在这个时候，google 公司根据公司多年的发展经验和借助成熟的内部项目<code>Borg</code>系统，宣布了 <code>Kubernetes</code> 项目的诞生。<br>而也是仅仅在两年之前，各个国内外的互联网厂商开始将自己的项目接入 k8s，宣布了 k8s 时代的到来。</p>
<p>本文仅仅讨论 <code>docker 容器化技术</code>，对于<code>容器化编排</code>不做过多的介绍。</p>
<h1 id="容器到底是怎么一回事？"><a href="#容器到底是怎么一回事？" class="headerlink" title="容器到底是怎么一回事？"></a>容器到底是怎么一回事？</h1><p>在上述的文章中，已经简单介绍了几个概念:</p>
<ul>
<li><code>虚拟器</code></li>
<li><code>容器</code></li>
<li><code>容器化技术</code></li>
<li><code>镜像</code></li>
</ul>
<p>我们可以总结一下：<strong>容器其实就是一种沙盒技术，使用 <code>Cgroups</code>和<code>Namespace</code> 技术，将你的应用通过限制和隔离的技术在指定的环境中，良好的运行起来</strong></p>
<p>先说结论，容器其实就是一种<code>特殊的进程</code>而已</p>
<h2 id="隔离技术-Namespace"><a href="#隔离技术-Namespace" class="headerlink" title="隔离技术 - Namespace"></a>隔离技术 - Namespace</h2><blockquote>
<p>那么隔离技术是如何实现的？</p>
</blockquote>
<p>首先创建一个容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name=ubuntu-test ubuntu:18.04 /bin/sh</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ps</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 pts/0    00:00:00 sh</span><br><span class="line">    7 pts/0    00:00:00 ps</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到这个容器中，一共有两个进程，通过 ps 可以看到 sh ,就是这个容器内部的第 1 号进程（PID=1）。</p>
<p>这是为什么呢？</p>
<p>本来，当我们在宿主机上运行了一个 /bin/sh 程序的时候，我们的操作系统都会给其分配一个进程编号，例如 PID=100。但是通过 <code>docker run</code> 命令时，docker<br>就会在当前的进程时，调整其 namespace 相关参数，将其变为在这个 docker 中的 1 号进程。</p>
<p>这种技术就是<strong>Linux 里面的 Namespace 机制</strong>。</p>
<p>我们知道，在 Linux 系统中创建进程的系统调用是 clone():</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">int pid = clone(main_function, stack_size, SIGCHID, NUll);</span><br></pre></td></tr></table></figure>

<p>通过指定 <code>CLONE_NEWPID</code> 参数，而每个 <code>Namespace</code>里的应用进程，都会认为自己是当前容器里的第一号进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL)</span><br></pre></td></tr></table></figure>

<p>在 Linux 操作系统中，还提供了 <code>Mount</code>、<code>UTS</code>、<code>IPC</code>、<code>Network</code>、<code>User</code> 这些 Namespace，用来对<code>各种不同的进程</code>上下文进行”障眼法”操作。</p>
<h2 id="限制技术-Cgroups"><a href="#限制技术-Cgroups" class="headerlink" title="限制技术 - Cgroups"></a>限制技术 - Cgroups</h2><blockquote>
<p>Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等<br>在 Linux 中，Cgroups 给用户暴露出来的操作接口是<strong>文件系统</strong>，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># mount -t cgroup</span></span></span><br><span class="line">cpuset on /sys/fs/cgroup/cpuset type cgroup (ro,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cpu on /sys/fs/cgroup/cpu type cgroup (ro,nosuid,nodev,noexec,relatime,cpu)</span><br><span class="line">cpuacct on /sys/fs/cgroup/cpuacct type cgroup (ro,nosuid,nodev,noexec,relatime,cpuacct)</span><br><span class="line">blkio on /sys/fs/cgroup/blkio type cgroup (ro,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">memory on /sys/fs/cgroup/memory type cgroup (ro,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">devices on /sys/fs/cgroup/devices type cgroup (ro,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">freezer on /sys/fs/cgroup/freezer type cgroup (ro,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">net_cls on /sys/fs/cgroup/net_cls type cgroup (ro,nosuid,nodev,noexec,relatime,net_cls)</span><br><span class="line">perf_event on /sys/fs/cgroup/perf_event type cgroup (ro,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">net_prio on /sys/fs/cgroup/net_prio type cgroup (ro,nosuid,nodev,noexec,relatime,net_prio)</span><br><span class="line">hugetlb on /sys/fs/cgroup/hugetlb type cgroup (ro,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">pids on /sys/fs/cgroup/pids type cgroup (ro,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">rdma on /sys/fs/cgroup/rdma type cgroup (ro,nosuid,nodev,noexec,relatime,rdma)</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd type cgroup (ro,nosuid,nodev,noexec,relatime,name=systemd)</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>其中，例如 <code>cpuset</code>、<code>cpu</code>、<code>memory</code> 这样的子目录，也叫子系统。这些都是可以被 <code>Cgroups</code> 进行限制的资源种类。</p>
<p>现在我们看一下子系统中关于 CPU 的相关配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls /sys/fs/cgroup/cpu</span></span><br><span class="line">cgroup.clone_children  cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  notify_on_release</span><br><span class="line">cgroup.procs	       cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat	 tasks</span><br></pre></td></tr></table></figure>
<p>这些输出配置中，可以看到 <code>cpu.cfs_period_us</code> 和 <code>cpu.cfs_quota_us</code>，这两个参数需要组合使用，可以用来限制进程在长度<code>cfs_period</code>的一段时间内，<br>只能被分配到总量为 <code>cfs_quota</code> 的 CPU 时间。</p>
<p>另开一个终端，输入:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while : ; do : ; done &amp;</span><br><span class="line"></span><br><span class="line">23223</span><br></pre></td></tr></table></figure>
<p>键入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu0 :100.0 us, 0.0 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</span></span><br></pre></td></tr></table></figure>
<p>可以看到 CPU 的使用率已经 100% 了， quota 还没有任何限制（-1）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us</span> </span><br><span class="line">-1</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/fs/cgroup/cpu/container/cpu.cfs_period_us</span> </span><br><span class="line">100000</span><br></pre></td></tr></table></figure>
<p>在现在的默认配置中，在 100 ms 中的 cpu 时间中，使用 100ms 的 CPU 时间，也就是 100 %。<br>现在调整为 20%:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 20000 &gt; /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us</span></span><br></pre></td></tr></table></figure>
<p>然后将限制的进程 PID 写入 container 组里的 tasks 文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 23223 &gt; /sys/fs/cgroup/cpu/container/tasks</span> </span><br></pre></td></tr></table></figure>
<p>然后使用 <code>top</code> 指令查看:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">Cpu0 : 20.3 us, 0.0 sy, 0.0 ni, 79.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</span></span><br></pre></td></tr></table></figure>
<p>现在可以看到已经为 <code>20%</code> 左右了<br>其他关于 <code>blkio</code>，<code>cpuset</code>，<code>memory</code> 可以自行尝试</p>
<h3 id="docker-运行时的限制参数"><a href="#docker-运行时的限制参数" class="headerlink" title="docker 运行时的限制参数"></a>docker 运行时的限制参数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu:18.04 /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>这个配置就会将对应的值写入到 docker-container 的配置文件中，这个 Docker 容器，只能使用到 20% 的 CPU 带宽。</p>
<h3 id="虚拟机和容器对比"><a href="#虚拟机和容器对比" class="headerlink" title="虚拟机和容器对比"></a>虚拟机和容器对比</h3><img src="/images/虚拟机和容器对比图.png" width = "500" height = "300" alt="" align=center />

<p>虚拟机的工作原理，通过硬件虚拟化功能，模拟出了运行一个操作系统需要的各种硬件，例如 CPU、内存、I/O 设备等等。<br>docker 项目帮助用户启动的，还是原来的应用进程，但是 Docker 会为它们加上了各种各样的 Namespace 参数。</p>
<p>所以，”敏捷” 和 “高性能” 是容器相较于虚拟机最大的优势，也是它能够在 PaaS 这种更细粒度的资源管理平台上大行其道的重要原因。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么使用链表&amp;&amp;实现</title>
    <url>/posts/2c2cd033/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>从一个经典的<strong>链表</strong>应用场景：<strong>LRU 缓存淘汰算法</strong>说开去。</p>
</blockquote>
<blockquote>
<p><strong>缓存</strong>是为了解决高低速存储之间的差距而引入的技术。</p>
</blockquote>
<p>链表和数组对比：</p>
<p><img src="https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg" alt="img"></p>
<p>缓存的大小有限，当缓存被打满的时候，就需要<strong>清理或者保留某些数据</strong>，这一部分就需要缓存淘汰策略来决定。</p>
<p><strong>常见的策略有三种:</strong></p>
<ul>
<li><strong>先进先出策略 FIFO (First In, First Out)</strong></li>
<li><strong>最少使用策略（Least Frequently Used）</strong></li>
<li><strong>最近最少使用策略（Least Recently Used）</strong></li>
</ul>
<p>这些策略就和我们清理房间采取的策略一致</p>
<p>那么如何采用 <strong>链表</strong>，来实现 <strong>LRU缓存淘汰策略</strong>呢 ？</p>
<h2 id="链表简介"><a href="#链表简介" class="headerlink" title="链表简介"></a>链表简介</h2><p>首先解释一个 <strong>链表</strong> 的数据结构</p>
<blockquote>
<p>与数组结构不同的是，<strong>链表不需要连续的内存空间来存储</strong>，<strong>它是通过<code>指针</code>将一组零散的内存块串联起来使用</strong>。</p>
</blockquote>
<p>用一张图直观的解释：</p>
<p><img src="https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg" alt="img"></p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><img src="https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg" alt="img"></p>
<p><strong>单链表</strong>是通过一个个<strong>节点（Node）</strong>组成的，每个节点包含了两个部分：</p>
<ul>
<li>存储数据的 <code>data</code></li>
<li>存储指针的<code>next</code>, 用于指向下一个 node</li>
</ul>
<p>特点：</p>
<ul>
<li>数据的<strong>插入</strong>和<strong>删除</strong>非常迅速（无序）—— 时间复杂度 O(1)</li>
<li>数据的<strong>查找</strong>时间复杂度是 O(n)</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg" alt="img"></p>
<h3 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h3><ul>
<li>查找 - find()</li>
<li>删除 - remove()</li>
<li>链表元素添加<ul>
<li>头部添加元素 - add</li>
<li>尾部添加元素 - append</li>
<li>插入某个元素 - insert</li>
</ul>
</li>
<li>链表元素展示 - traverse()</li>
<li>链表长度 - <code> __len__</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    单链表的实现</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            cur_data = cur.data</span><br><span class="line">            <span class="keyword">if</span> cur_data == data:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.data == data:</span><br><span class="line">                <span class="keyword">if</span> cur == self.head:</span><br><span class="line">                    self.head = self.head.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        node.<span class="built_in">next</span> = self.head</span><br><span class="line">        self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.head = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, index, data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            self.add(data)</span><br><span class="line">        <span class="keyword">elif</span> index &gt; self.__len__():</span><br><span class="line">            self.append(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index -<span class="number">1</span>):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            node = Node(data)</span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(cur.data, end=<span class="string">&#x27;-***-&#x27;</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    chain = LinkedList()</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> items:</span><br><span class="line">        node = Node(value)</span><br><span class="line">        chain.append(value)</span><br><span class="line"></span><br><span class="line">    chain.traverse()</span><br><span class="line"></span><br><span class="line">    chain.append(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    chain.traverse()</span><br><span class="line"></span><br><span class="line">    chain.remove(<span class="number">3</span>)</span><br><span class="line">    chain.remove(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    chain.traverse()</span><br><span class="line">    chain.insert(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    chain.traverse()</span><br><span class="line">    <span class="built_in">print</span>(chain.find(<span class="number">5</span>), chain.find(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(chain))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><blockquote>
<p><strong>循环链表是一种特殊的单链表。它和单链表的唯一区别就是在尾节点</strong>。<br><strong>循环链表的尾结点指针指向链表的头节点。</strong></p>
</blockquote>
<p><img src="/images/linknode.png" alt="direct"><br>这种数据结构比较适合处理具有环形结构特点的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleLink</span>(<span class="params">SingleChain</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CircleLink, self).__init__()</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = node</span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span> = self._head</span><br><span class="line">            self._head = node</span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = self._head</span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span> = self._head</span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;-**&#123;&#125;&quot;</span>.<span class="built_in">format</span>(cur.data), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-**&#123;&#125;&quot;</span>.<span class="built_in">format</span>(cur.data), end=<span class="string">&#x27;&#x27;</span>)  <span class="comment"># 由于是 cur.next 判断的，故 cur 指向最后一个节点</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        cur = self._head</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            <span class="keyword">if</span> cur.data == data:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> cur.data == data:  <span class="comment"># 最后一个</span></span><br><span class="line">            <span class="keyword">return</span> self.__len__()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">if</span> cur.<span class="built_in">next</span> == self._head:</span><br><span class="line">            self._head = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            <span class="keyword">if</span> cur.data == data:</span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 退出循环, cur指向尾结点</span></span><br><span class="line">        <span class="keyword">if</span> cur.data == data:</span><br><span class="line">            <span class="comment"># 链表中只有一个结点</span></span><br><span class="line">            pre.<span class="built_in">next</span> = self._head</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count + <span class="number">1</span>  <span class="comment"># 未计算最后一个 Node</span></span><br></pre></td></tr></table></figure>


<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><blockquote>
<p>双向链表，顾名思义，它支持两个方向，每个节点分为三个部分：</p>
<ul>
<li>prev</li>
<li>data</li>
<li>next</li>
</ul>
<p>双向链表可以支持 O(1) 时间复杂度的情况下找到前驱节点，双向链表在某些情况下的 插入、删除等操作都要比单链表简单、高效。</p>
</blockquote>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><ul>
<li><p>删除节点中“值等于某个给定值” 的节点</p>
<p>对于这种情况，不管是单链表还是双链表，为了查找到值等于给定值的节点，都需要从头节点开始一个个依次遍历对比，找到后删除，时间复杂度为 O(n)</p>
</li>
<li><p>删除给定指针指向的节点</p>
<p>对于单链表来说，删除指定的节点时，还需要知道前驱节点，那么就会存在遍历的操作，时间复杂度为 O(n)。</p>
<p>对于双向链表来说，是存在 prev 指针的，那么时间复杂度相对于是 O(1)</p>
</li>
</ul>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ul>
<li>对于在某个节点前插入指定节点，时间复杂度是 O(1)</li>
</ul>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>对于一个有序链表来说，双向链表可以通过记录上次查找的位置 pos，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，平均时间复杂度为 O(log(n))</p>
<p><img src="https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt="img"></p>
<h3 id="双向链表实现"><a href="#双向链表实现" class="headerlink" title="双向链表实现"></a>双向链表实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> chain.single_chain <span class="keyword">import</span> SingleChain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLink</span>(<span class="params">SingleChain</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(DoubleLink, self).__init__()</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = XNode(data)</span><br><span class="line">        <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._head = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = self._head</span><br><span class="line">            self._head.prev = node</span><br><span class="line">            self._head = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = XNode(data)</span><br><span class="line">        <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._head = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            node.prev = cur</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, index, data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            self.add(data)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> index &gt;= self.__len__():</span><br><span class="line">            self.append(data)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># status 1: 空</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self.add(data)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># status 2: 只有一个节点</span></span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> index &lt;= <span class="number">0</span>:</span><br><span class="line">                    self.add(data)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">if</span> index &gt;= self.__len__():</span><br><span class="line">                    self.append(data)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># status 多个节点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                node = XNode(data)</span><br><span class="line">                cur = self._head</span><br><span class="line">                <span class="keyword">while</span> count &lt; index:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                node.<span class="built_in">next</span> = cur</span><br><span class="line">                node.prev = cur.prev</span><br><span class="line">                cur.prev.<span class="built_in">next</span> = node</span><br><span class="line">                cur.prev = node</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>链表包括：</p>
<ul>
<li>单向链表</li>
<li>双向链表</li>
<li>循环链表</li>
</ul>
<p>和数组相比，<strong>链表存储的数据是不连续的存储空间，数据之间采用指针引用方式连接。</strong><br>链表各适合插入、删除操作频繁的场景，查询的时间复杂度较高。</p>
<h3 id="链表实现注意点"><a href="#链表实现注意点" class="headerlink" title="链表实现注意点"></a>链表实现注意点</h3><ul>
<li><p>理解指针或引用含义</p>
<blockquote>
<p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量</p>
</blockquote>
</li>
<li><p>警惕指针丢失和内存泄露<br>在插入指针的时候，注意操作的顺序，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.<span class="built_in">next</span> = x</span><br><span class="line">x.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>上面的语句出现了自己指向自己的情况，交换两行就可以了<br>删除链表节点的时候，也一定要记得手动释放内存空间。</p>
</li>
<li><p>利用哨兵简化实现难度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cur = self.head</span><br></pre></td></tr></table></figure></li>
<li><p>重点留意边界条件处理</p>
</li>
</ul>
<ol>
<li>链表为空的时候</li>
<li>链表只包含一个节点的情况</li>
<li>链表只包含头尾节点</li>
</ol>
<ul>
<li>举例绘图，辅助思考<br><img src="/images/link_node_exaples.png" alt="direct"></li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>LRU 的实现？</p>
<p>字符串是通过单链表来存储的，那如何判断一个回文字符呢？</p>
<p>解决思路：</p>
<p>法一：</p>
<p>使用快慢指针找到中点，然后将后半链表 reversed，然后一个指针在头部，一个指针在中部，逐个比较。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span>(<span class="params">head</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    slow = reverse_node(find_middle_node(head))</span><br><span class="line">    traverse(slow)</span><br><span class="line">    traverse(head)</span><br><span class="line">    <span class="keyword">while</span> slow:</span><br><span class="line">        <span class="keyword">if</span> head.data != slow.data:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_middle_node</span>(<span class="params">head</span>):</span></span><br><span class="line">    fast, slow = head, head</span><br><span class="line">    <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_node</span>(<span class="params">head</span>):</span></span><br><span class="line">    p, rev = head, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> p:</span><br><span class="line">        rev, rev.<span class="built_in">next</span>, p = p, rev, p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rev</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">node</span>):</span></span><br><span class="line">    cur = node</span><br><span class="line">    <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(cur.data, end=<span class="string">&#x27;-***-&#x27;</span>)</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_str = <span class="string">&quot;1012101&quot;</span></span><br><span class="line">    c = Chain()</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> my_str:</span><br><span class="line">        c.append(v)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(is_palindrome(c.head))</span><br></pre></td></tr></table></figure>

<h2 id="链表练习题目"><a href="#链表练习题目" class="headerlink" title="链表练习题目"></a>链表练习题目</h2><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>206 - <a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>
<p>解题思路：<br>p = p.next 循环， 将 head.next 的引用指向前一个节点即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        res, p = <span class="literal">None</span>, head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            res, res.<span class="built_in">next</span>, p = p, res, p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="环状链表判断"><a href="#环状链表判断" class="headerlink" title="环状链表判断"></a>环状链表判断</h3><p>解题思路：使用快慢指针，如果两个指针相遇了说明是环状链表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        i = head</span><br><span class="line">        j = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j != <span class="literal">None</span> <span class="keyword">and</span> j.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            i = i.<span class="built_in">next</span></span><br><span class="line">            j = j.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>21 - <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">            <span class="keyword">if</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">                <span class="keyword">if</span> l1.val &gt; l2.val: l1, l2 = l2, l1</span><br><span class="line">                l1.<span class="built_in">next</span> = self.mergeTwoLists(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">            <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br></pre></td></tr></table></figure>

<h3 id="删除链表的到处第-N-个节点"><a href="#删除链表的到处第-N-个节点" class="headerlink" title="删除链表的到处第 N 个节点"></a>删除链表的到处第 N 个节点</h3><p>19 - <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLength</span>(<span class="params">head: ListNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line">    dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">    length = getLength(head)</span><br><span class="line">    cur = dummy</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length - n + <span class="number">1</span>):</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>876 - <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">https://leetcode-cn.com/problems/middle-of-the-linked-list/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        </span><br><span class="line">        n, cur = <span class="number">0</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        k, cur = <span class="number">0</span>, head</span><br><span class="line">        <span class="keyword">while</span> k &lt; n // <span class="number">2</span>:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<h1 id="链表实现源码"><a href="#链表实现源码" class="headerlink" title="链表实现源码"></a>链表实现源码</h1><p><a href="https://github.com/tyronemaxi/algorithm/tree/main/chain">https://github.com/tyronemaxi/algorithm/tree/main/chain</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是栈、栈的使用场景？</title>
    <url>/posts/da81f8d9/</url>
    <content><![CDATA[<h1 id="如何理解栈？"><a href="#如何理解栈？" class="headerlink" title="如何理解栈？"></a>如何理解栈？</h1><blockquote>
<p>关于”栈”，就像是一摞叠在一起的书籍。当我们放书籍的时候，都是一本本书的摞起来；当我们需要取书籍的时候，也是需要从上到下<br>一个个的依次的取。</p>
</blockquote>
<p>所谓的<strong>栈</strong>：就是<strong>后进者先出，先进者后出，这就是典型的 栈 的结构</strong>。</p>
<p>从栈的操作特性上来看，<strong>栈是一种”操作受限”的线性表</strong>，只允许在一端插入和删除数据。</p>
<p>从功能上来说，数组和链表确实可以替代栈，但是特定的数据结构是对特定场景的抽象，而且，数组或者链表暴露了太多的操作接口，操作上的灵活，<br>在使用时也就会变得不可控，自然也就更容易出错。</p>
<p><strong>当某个数据集合只涉及在一端插入和删除数据的时候，并且满足后进先出、先进先出的特性，这时我们就应该首选”栈”这种数据结构</strong></p>
<h1 id="如何实现一个”栈”？"><a href="#如何实现一个”栈”？" class="headerlink" title="如何实现一个”栈”？"></a>如何实现一个”栈”？</h1><p>栈可以使用数组来实现，也可以使用链表来实现；<br>这里我使用数组来实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self._stack.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._stack)</span><br></pre></td></tr></table></figure>
<p>先说结论：<br>栈的空间复杂度为 O(1), 时间复杂度为 O(1)。<br>这里存储数据需要一个大小为 n 的数组，并不是说空间复杂度就是 O(n)。我们在判断一个空间复杂度的时候，是指除了原本的数据存储空间外，<br>算法运行还需要额外的存储空间。</p>
<p>对于时间复杂度来说，入栈和出栈都是 O(1)</p>
<h1 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h1><h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>栈作为一个比较基础的数据结构，比较经典的应用场景就是<code>函数调用栈</code>。</p>
<p>操作系统给每个线程分配了一块<code>独立的内存空间</code>，这块内存被组织成<code>栈</code>这种数据结构，用来存储函数调用时的临时变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    a,b, c = <span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    _res = add(a,b)</span><br><span class="line">    res = _res + c</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(a,b)</span><br></pre></td></tr></table></figure>

<p>调用顺序：main() –&gt; add()<br><img src="../../images/algorithm/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.png" alt="direct"></p>
<h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><p>四则运算的实现<br>例如：16+26*36-2/2</p>
<p>实现思路：</p>
<ol>
<li>维护一个栈，然后<br><img src="../../images/algorithm/%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E6%A0%88%E5%AE%9E%E7%8E%B0.png" alt="img_2.png"></li>
</ol>
<p>实际上，编译器就是通过两个栈来实现的。其中一个来保存操作数的栈，另一个保存运算符的栈。</p>
<h3 id="基本运算器实现"><a href="#基本运算器实现" class="headerlink" title="基本运算器实现"></a>基本运算器实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    stack = []</span><br><span class="line">    preSign = <span class="string">&#x27;+&#x27;</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> s[i] != <span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> s[i].isdigit():</span><br><span class="line">            num = num * <span class="number">10</span> + <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(num)</span><br><span class="line">        <span class="keyword">if</span> i == n - <span class="number">1</span> <span class="keyword">or</span> s[i] <span class="keyword">in</span> <span class="string">&#x27;+-*/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> preSign == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                stack.append(num)</span><br><span class="line">            <span class="keyword">elif</span> preSign == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                stack.append(-num)</span><br><span class="line">            <span class="keyword">elif</span> preSign == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                stack.append(stack.pop() * num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(stack.pop() / num))</span><br><span class="line">            preSign = s[i]</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure>
<h2 id="浏览器前进和后退功能实现"><a href="#浏览器前进和后退功能实现" class="headerlink" title="浏览器前进和后退功能实现"></a>浏览器前进和后退功能实现</h2><p>解题思路：使用两个栈，A 和 B，将访问的页面一次压入栈 A 中，当点击后退按钮时，再依次从栈 A 中出栈，并将出栈的数据依次放入栈 B 中。点击前进按钮时，依次从栈 B<br>中取出数据，放入到 A 中。当栈 A 中没有数据时，那就是说明没有页面可以继续后退浏览了。当栈 B 中没有数据的时候，那就说明没有页面可以点击前进按钮浏览了。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self._stack.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._stack == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brower</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__forward_stack = Stack()</span><br><span class="line">        self.__back_stack = Stack()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">surf</span>(<span class="params">self, web_site_url</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;surf the website:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(web_site_url))</span><br><span class="line">        self.__forward_stack.push(web_site_url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.__back_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        top = self.__back_stack.pull()</span><br><span class="line">        self.__forward_stack.push(top)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;forward to the website: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(top))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.__forward_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        top = self.__forward_stack.pull()</span><br><span class="line">        self.__back_stack.push(top)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;back to the website: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(top))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    brower = Brower()</span><br><span class="line">    brower.surf(<span class="string">&#x27;www.1.com&#x27;</span>)</span><br><span class="line">    brower.surf(<span class="string">&#x27;www.2.com&#x27;</span>)</span><br><span class="line">    brower.surf(<span class="string">&#x27;www.3.com&#x27;</span>)</span><br><span class="line">    brower.surf(<span class="string">&#x27;www.4.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    brower.forward()</span><br><span class="line">    brower.back()</span><br><span class="line">    brower.back()</span><br><span class="line">    brower.back()</span><br><span class="line">    brower.back()</span><br><span class="line">    brower.back()</span><br><span class="line">    brower.forward()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>栈是一种<strong>操作受限</strong>的数据结构，只支持<code>入栈</code>和<code>出栈</code>操作。<br>可以通过<code>数组</code>或者<code>链表</code>来实现。<br>入栈、出栈的时间复杂度都是 O(1)。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="为什么函数调用要用栈来保存临时变量呢？"><a href="#为什么函数调用要用栈来保存临时变量呢？" class="headerlink" title="为什么函数调用要用栈来保存临时变量呢？"></a>为什么函数调用要用<strong>栈</strong>来保存临时变量呢？</h2><p>函数调用时，符合<code>后进先出</code>的特性，用栈这种数据结构来实现，是最符合的。</p>
<p>从调用函数进入被调用函数，比如：main –&gt; add –&gt; res 。变化的是<code>作用域</code>。所以从根本上，只要保证每进入一个新的函数，都是一个新的作用域都可以。<br>而要实现这个，用栈会非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p>
<h2 id="在-JVM-内存管理中有个堆栈的概念-？"><a href="#在-JVM-内存管理中有个堆栈的概念-？" class="headerlink" title="在 JVM 内存管理中有个堆栈的概念 ？"></a>在 JVM 内存管理中有个<code>堆栈</code>的概念 ？</h2><p>内存中的堆栈和数据结构堆栈不是同一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。<br>内存空间在逻辑上分为三部分：</p>
<ul>
<li>代码区</li>
<li>静态数据区</li>
<li>动态数据区<ul>
<li>栈区</li>
<li>堆区</li>
</ul>
</li>
</ul>
<p>代码区：<code>存储方法体的二进制代码</code>。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。<br>静态数据区：<code>存储全局变量</code>、<code>静态变量</code>、<code>常量</code>、常量包括 final 修饰的常量和 String 常量。系统自动分配和回收。</p>
<p>栈区：<strong>存储运行方法的形参、局部变量、返回值。由系统自动分配和回收</strong><br>堆区：<strong>new 一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</strong></p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><p>20 - <a href="https://leetcode-cn.com/problems/valid-parentheses/">https://leetcode-cn.com/problems/valid-parentheses/</a><br>解题思路：</p>
<ul>
<li><ol>
<li>括号是成对出现的，则判断字符串 s 是否为偶数，否则返回 False;</li>
</ol>
</li>
<li><ol start="2">
<li>遍历字符串，先将 左括号压入栈，匹配到右括号时，则判断栈顶是否匹配到，否则返回 False;  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid_bracket</span>(<span class="params">brackets: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(brackets) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    pairs = &#123;</span><br><span class="line">        <span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stack = Stack()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> brackets:</span><br><span class="line">        <span class="keyword">if</span> ch <span class="keyword">in</span> pairs:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack.top() != pairs[ch]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.pull()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.push(ch)</span><br><span class="line">    <span class="keyword">return</span> stack.is_empty()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(isValid_bracket(<span class="string">&#x27;([&#123;&#125;])&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2>解题思路：维护一个辅助栈，在入栈的时候，依次与辅助栈中的数据比较，采用 <code>min(val, min_stack[-1])</code> 的方式入栈。pop 时，min_stack 也会 pop<br>155 - <a href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._stack = []</span><br><span class="line">        self.min_stack = [math.inf] <span class="comment"># 存储正无穷大</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self._stack.append(val)</span><br><span class="line">        self.min_stack.append(<span class="built_in">min</span>(val, self.min_stack[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self._stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2>232 - <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">https://leetcode-cn.com/problems/implement-queue-using-stacks/</a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.s1 = []</span><br><span class="line">        self.s2 = []</span><br><span class="line">        self.front = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.s1:</span><br><span class="line">            self.front = x</span><br><span class="line">        self.s1.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.s2:</span><br><span class="line">            <span class="keyword">while</span> self.s1:</span><br><span class="line">                self.s2.append(self.s1.pop())</span><br><span class="line">            self.front = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.s2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.s2:</span><br><span class="line">            <span class="keyword">return</span> self.s2[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> self.front</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.s1 <span class="keyword">and</span> <span class="keyword">not</span> self.s2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="比较含退格的字符串"><a href="#比较含退格的字符串" class="headerlink" title="比较含退格的字符串"></a>比较含退格的字符串</h2>844 - <a href="https://leetcode-cn.com/problems/backspace-string-compare/">https://leetcode-cn.com/problems/backspace-string-compare/</a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">            ret = []</span><br><span class="line">            <span class="keyword">for</span> value <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> value != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    ret.append(value)</span><br><span class="line">                <span class="keyword">elif</span> ret:</span><br><span class="line">                    ret.pop()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ret)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> judge(s) == judge(t)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="基本计算器实现"><a href="#基本计算器实现" class="headerlink" title="基本计算器实现"></a>基本计算器实现</h2><p>224 - <a href="https://leetcode-cn.com/problems/basic-calculator/">https://leetcode-cn.com/problems/basic-calculator/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">s</span>):</span></span><br><span class="line">    res, num, sign = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> ch.isdigit():</span><br><span class="line">            num = num * <span class="number">10</span> + <span class="built_in">int</span>(ch)</span><br><span class="line">        <span class="keyword">elif</span> ch == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> ch == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            res += sign * num</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            sign = <span class="number">1</span> <span class="keyword">if</span> ch == <span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> ch == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            stack.append(res)</span><br><span class="line">            stack.append(sign)</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> ch == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            res += sign * num</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            res *= stack.pop()</span><br><span class="line">            res += stack.pop()</span><br><span class="line">    res += sign * num</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(calculate(<span class="string">&#x27;1+(1+2)-(1-1)+1&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="基本运算器-3"><a href="#基本运算器-3" class="headerlink" title="基本运算器 3"></a>基本运算器 3</h2><p><a href="https://leetcode-cn.com/problems/basic-calculator-iii/">https://leetcode-cn.com/problems/basic-calculator-iii/</a><br>基本运算元素：</p>
<ul>
<li><code>(</code></li>
<li><code>)</code></li>
<li><code>-</code></li>
<li><code>+</code></li>
<li><code>*</code></li>
<li><code>/</code></li>
</ul>
<p>运算符优先级：</p>
<ul>
<li>2<ul>
<li><code>/ *</code></li>
</ul>
</li>
<li>1<ul>
<li><code>+ -</code></li>
</ul>
</li>
<li>0<ul>
<li><code>( )</code></li>
</ul>
</li>
</ul>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>双栈法</p>
<ul>
<li>stack_num 存储<strong>数字</strong></li>
<li>stack_opt 存储<strong>运算符</strong></li>
</ul>
<p>最小原子计算：</p>
<ol>
<li>stack_num 中 pop 出两个数 A, B</li>
<li>stack_opt 中 pop 出一个操作符 opt</li>
<li>计算结果：res = B opt A</li>
<li>存储运算结果：stack_num.append(res)</li>
</ol>
<p>字符串枚举：</p>
<ol>
<li><code>空格</code>，continue 下一个循环</li>
<li><code>数字</code></li>
</ol>
<ul>
<li>单个数字<br><code>stack_num.append()</code></li>
<li>多位数字<br>解析多位数字，<code>append</code></li>
<li>‘(‘<br>直接进入 stack_opt 栈</li>
<li>‘)’<br>重复最小原子计算，直到 <code>stack_opt</code> 栈顶为 <code>(</code>。然后 stack_opt 栈 pop</li>
<li>操作符(+,-,*,/)<br>比较<code>当前操作符</code>与 <code>栈顶操作符</code>优先级，若前者大于后者，则进行最小原子计算操作。<br>反之，则压入 <code>stack_opt</code> 栈中。</li>
</ul>
<p>3.遍历完所有字符串后，判断 <code>stack_opt</code> 是否为空，重复执行最基本计算操作，直到为空。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本运算器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小原子计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">self, A, B, opt</span>):</span></span><br><span class="line">        <span class="keyword">if</span> opt == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(A) + <span class="built_in">int</span>(B)</span><br><span class="line">        <span class="keyword">if</span> opt == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(B) - <span class="built_in">int</span>(A)</span><br><span class="line">        <span class="keyword">if</span> opt == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(B) * <span class="built_in">int</span>(A)</span><br><span class="line">        <span class="keyword">if</span> opt == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(B) / <span class="built_in">int</span>(A)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">basic_cal</span>(<span class="params">self, stack_num, stack_opt</span>):</span></span><br><span class="line">        opt = stack_opt.pop()</span><br><span class="line">        A = stack_num.pop()</span><br><span class="line">        B = stack_num.pop()</span><br><span class="line">        res = self.cal(A, B, opt)</span><br><span class="line">        stack_num.append(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s:<span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># stack_num &amp;&amp; stack_opt</span></span><br><span class="line">        stack_num, stack_opt = [], []</span><br><span class="line">        priority = &#123;</span><br><span class="line">            <span class="string">&#x27;(&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;)&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;+&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;-&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;*&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="string">&#x27;/&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; length:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&quot; &quot;</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= s[i] &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">                start = i</span><br><span class="line">                <span class="keyword">while</span> i+<span class="number">1</span> &lt; length <span class="keyword">and</span> <span class="string">&#x27;0&#x27;</span> &lt;= s[i+<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">                    i = i+<span class="number">1</span></span><br><span class="line">                num = <span class="built_in">int</span>(s[start: i+<span class="number">1</span>])</span><br><span class="line">                stack_num.append(num)</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack_opt.append(s[i])</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">while</span> stack_opt[-<span class="number">1</span>] != <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    self.basic_cal(stack_num, stack_opt)</span><br><span class="line">                stack_opt.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack_opt <span class="keyword">and</span> priority[s[i]] &lt;= priority[stack_opt[-<span class="number">1</span>]]:</span><br><span class="line">                    self.basic_cal(stack_num, stack_opt)</span><br><span class="line">                stack_opt.append(s[i])</span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行全部计算</span></span><br><span class="line">        <span class="keyword">while</span> stack_opt:</span><br><span class="line">            self.basic_cal(stack_num, stack_opt)</span><br><span class="line">        val = stack_num[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(val)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>如何玩转二分法查找？</title>
    <url>/posts/975ea5bf/</url>
    <content><![CDATA[<h1 id="什么是二分查找？"><a href="#什么是二分查找？" class="headerlink" title="什么是二分查找？"></a>什么是二分查找？</h1><p>二分查找（Binary Search）算法，也叫做<strong>折半查找算法</strong></p>
<h1 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h1><p>典型的猜数游戏，随机在 0-99 中选中一个数让人去猜，猜的过程中，每猜一次，就会告诉对方大了还是小了，直到猜中为止。<br><img src="../../images/algorithm/guessNum.png" alt="direct"><br>在这个游戏中，7 次就猜出来了。<br>如果是 0 - 999 的数字，最多也就要 10 次就能猜中。</p>
<p><strong>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0</strong></p>
<h1 id="二分查找的时间复杂度"><a href="#二分查找的时间复杂度" class="headerlink" title="二分查找的时间复杂度"></a>二分查找的时间复杂度</h1><p>二分查找是一种非常高效的查找算法，**时间复杂度为 O(logn)。<br>被查找区间的大小变化为：n, n/2, n/4, n/8, ……, n/2^k ……<br>已知通过 <code>n/2^k=1</code> 得到 k=log2n。所以时间复杂度就为：<code>O(logn)</code></p>
<p>logn 是一个非常恐怖的数量级，即便 n 非常非常大，对应的 logn 也很小。2^32 次大约是 42 亿，但是利用二分查找，最多需要比较 32 次。</p>
<h1 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h1><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">arr: <span class="built_in">list</span>, guess: <span class="built_in">int</span></span>):</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &lt; guess:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &gt; guess:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    index = binary_search(arr, <span class="number">9</span>)</span><br><span class="line">    <span class="built_in">print</span>(index)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>三个注意点：</p>
<ul>
<li>循环退出条件<br>low &lt;= high，而不是 low &lt; high</li>
<li>mid 取值<br>实际上，<code>mid=(low+high)/2</code> 的写法是有问题的。如果 low 和 high 比较大的话，两者之和就会溢出。<br>改进的方法是将 mid 的计算方式写成 low+(high-low)/2。<br>性能优化到极致的话，可以改写成位运算<code>low+((high-low)&gt;&gt;1)</code>。</li>
<li>low 和 high 的更新<br><code>low=mid+1</code> 和 <code>high=mid-1</code>。如果直接写成 low=mid 或者 high=mid，就可能发生死循环。</li>
</ul>
<h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">half_search</span>(<span class="params">arr, key, left, right</span>):</span></span><br><span class="line">    <span class="keyword">if</span> left &gt; right:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    mid = (left + (right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> key == arr[mid]:</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">elif</span> key &gt; arr[mid]:</span><br><span class="line">        <span class="keyword">return</span> half_search(arr, key, mid + <span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> half_search(arr, key, left, mid - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h1><p>在以上的分析中，二分查找的时间复杂度为 <code>O(logn)</code>，查找数据的效率非常高。</p>
<ul>
<li><strong>二分查找依赖的是顺序表结构，简单点说就是数组</strong></li>
<li><strong>二分查找针对的是有序数组</strong></li>
<li><strong>数据量过小或者过大也不适合二分查找</strong></li>
</ul>
<h1 id="二分查找的变形问题"><a href="#二分查找的变形问题" class="headerlink" title="二分查找的变形问题"></a>二分查找的变形问题</h1><h2 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找第一个给定值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_search</span>(<span class="params">arr, value</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + (right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; value:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; value:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> arr[mid-<span class="number">1</span>] != value:  <span class="comment"># 若为 arr 的第一个元素或者前一个数不是 value</span></span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span>  <span class="comment"># 前移</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>以上的代码中还是分为三种情况，即<code>=,&gt;,&lt;</code>,但是当 = 的时候，为了找到是列表中第一个找到的元素，需要向前比较，当前一个数不等于目标值时，则为第一个</strong></p>
<h2 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a>查找最后一个值等于给定值的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">final_search</span>(<span class="params">arr, value</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + (right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; value:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; value:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="built_in">len</span>(arr) - <span class="number">1</span> <span class="keyword">or</span> arr[mid+<span class="number">1</span>] != value:  <span class="comment"># 若为 arr 的最后一个元素或者后一个数不是 value</span></span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># 后移</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找第一个大于等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_greater_search</span>(<span class="params">arr, value</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + (right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt;= value:</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> arr[mid - <span class="number">1</span>] &lt; value:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果 a[mid] 小于我们要查找的值 value, 那要查找的值肯定在 [mid+1, right] 之间，所以 left = mid + 1<br>对于 a[mid] 大于等于给定着 value 的情况，判断是否是第一个大于等于给定值的情况：mid=0 或者 前一个数小于要查找的值。</p>
<h2 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_greater_search</span>(<span class="params">arr, value</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + (right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; value:</span><br><span class="line">            right = mid - <span class="number">1</span>     </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="built_in">len</span>(arr) - <span class="number">1</span> <span class="keyword">or</span> arr[mid + <span class="number">1</span>] &gt; value:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>如何在 1000 W 个整数中快速查找某个整数？</p>
<p>如果我们内存限制是 100 MB,每个数据的大小是 8 字节，最简单的办法就是将数据存储在数组中，内存占用差不多是 80 MB,符合内存的限制。<br>可以先对这 1000 W 的数据从小到大排序，然后再利用二分查找随发，就可以快速地查找想要的数据了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python 如何实现装饰器？</title>
    <url>/posts/e67a2035/</url>
    <content><![CDATA[<h1 id="Python-如何实现一个装饰器"><a href="#Python-如何实现一个装饰器" class="headerlink" title="Python 如何实现一个装饰器"></a>Python 如何实现一个装饰器</h1><blockquote>
<p>首先，装饰器为调用高阶函数提供了一种简单的语法<br>根据定义，装饰器是一个函数，它接受另外一个函数并在其基础功能上做统一的扩展</p>
</blockquote>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote>
<p>对于 Python 来说，一切皆对象，对象也是可以作为参数传递，这就是装饰器实现的基础</p>
</blockquote>
<p>例如，我想实现一个<code>日志打印</code>功能，调用对应方法或者对象时，可以显示其运行的信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> running&quot;</span>, )</span><br><span class="line">    func()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> ended&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    printer(task)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里我们实现了<code>task</code> 方法，在调用这个方法的时候，会显示调用的相关信息。</p>
<p>可以看到我们使用<code>printer</code> 这个功能的时候，都是采用<code>printer(func)</code>的方式，如果在多处使用的话，<br>那么有没有比较简单的方式，例如在执行<code>task</code>方法的时候，自动去触发<code>printer</code>呢，还能像调用原方法一样？</p>
<p>于是, 我们可以将该方法当成一个参数传递后，返回一个新的对象调用的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> running&quot;</span>, )</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> ended&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run&quot;</span>)</span><br><span class="line"></span><br><span class="line">task = printer(task)</span><br><span class="line">task()</span><br></pre></td></tr></table></figure>

<p>Python 中<code>允许在一个方法中嵌套另外一个方法</code>，这种特殊的机制就是<strong>闭包</strong>。<br>这个内部方法可以保留外部方法的作用域，内部方法也可以访问到外部方法的参数和变量。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><blockquote>
<p>python 支持一种装饰器语法糖「@」，使用这个语法糖，我们也可以实现与上面完全相同的功能</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@printer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run &quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h2><blockquote>
<p>现在我们已经知道，装饰器其实就是先定义好一个闭包，然后使用语法糖<code>@</code>来装饰方法，最后达到重新定义方法的作用<br>但是这样使用的方法其实最终执行的是 <code>inner</code> 方法</p>
</blockquote>
<p>like: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@printer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(task.__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: inner</span></span><br></pre></td></tr></table></figure>
<p>如何解决这个问题？</p>
<p>python 其实有内置的 functools 模块，提供了一个 <code>wraps</code> 方法，专门来解决这个问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> running&quot;</span>, )</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;func <span class="subst">&#123;func.__name__&#125;</span> ended&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@logger</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task run &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(task.__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># hello</span></span><br></pre></td></tr></table></figure>

<h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>装饰器当然也可以传入参数，例如：<code>*args</code>、<code>**kwargs</code><br>例如使用装饰器来计算程序的运行时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span>(<span class="params">prefix</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            start = time.time()</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">            end = time.time()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s: duration time: %ds&#x27;</span> % (prefix, <span class="built_in">int</span>(end - start)))</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@timeit(<span class="params"><span class="string">&#x27;prefix1&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello %s&#x27;</span> % name)</span><br></pre></td></tr></table></figure>
<h2 id="装饰器模版"><a href="#装饰器模版" class="headerlink" title="装饰器模版"></a>装饰器模版</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># do something</span></span><br><span class="line">        value = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<h2 id="类实现装饰器"><a href="#类实现装饰器" class="headerlink" title="类实现装饰器"></a>类实现装饰器</h2><p><code>__call__</code> 魔法方法结合类也可以实现装饰器</p>
<p>这里也给出一个通用模版</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self, params</span>):</span></span><br><span class="line">        self.params = params</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="comment"># do something</span></span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@Decorator(<span class="params"><span class="string">&#x27;params&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="装饰器的使用场景"><a href="#装饰器的使用场景" class="headerlink" title="装饰器的使用场景"></a>装饰器的使用场景</h2><h3 id="记录调用日志"><a href="#记录调用日志" class="headerlink" title="记录调用日志"></a>记录调用日志</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="comment"># 记录调用日志</span></span><br><span class="line">            logging.getLogger().setLevel(logging.INFO)</span><br><span class="line">            logging.info(<span class="string">&#x27;call method: %s %s %s&#x27;</span>, func.__name__, args, kwargs)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Logger(<span class="params"><span class="string">&#x27;airflow&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;run <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    task(name=<span class="string">&quot;task&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="路由映射"><a href="#路由映射" class="headerlink" title="路由映射"></a>路由映射</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.url_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">func</span>):</span></span><br><span class="line">            self.url_map[url] = func</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        func = self.url_map.get(url)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> func:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;No url function: %s&#x27;</span>, url)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router = Router()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.register(<span class="params"><span class="string">&#x27;/page1&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page1</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page1&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(router.call(<span class="string">&#x27;page1&#x27;</span>))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观锁与悲观锁-Python 实现</title>
    <url>/posts/102bc233/</url>
    <content><![CDATA[<h1 id="Python-乐观锁与悲观锁"><a href="#Python-乐观锁与悲观锁" class="headerlink" title="Python 乐观锁与悲观锁"></a>Python 乐观锁与悲观锁</h1><p>参考：<a href="https://xie.infoq.cn/article/2085a95ad6b486d3905adc7d6">https://xie.infoq.cn/article/2085a95ad6b486d3905adc7d6</a></p>
<blockquote>
<p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题</p>
</blockquote>
<h2 id="什么是乐观锁-？"><a href="#什么是乐观锁-？" class="headerlink" title="什么是乐观锁 ？"></a>什么是乐观锁 ？</h2><blockquote>
<p>乐观锁在操作数据时采用乐观的态度，认为不会出现多个操作数据的事件。因此乐观锁不糊上锁，只是在进行更新操作的时候<br>判断该期间是否同时存在修改了数据的情况：若在修改时数据已被修改则放弃操作，否则继续执行操作。</p>
</blockquote>
<h2 id="乐观锁的实现"><a href="#乐观锁的实现" class="headerlink" title="乐观锁的实现"></a>乐观锁的实现</h2><blockquote>
<ol>
<li>CAS 机制。2.版本号机制。这里将采用 python + orm 的实现方式</li>
</ol>
</blockquote>
<h3 id="CSA-Compare-and-Swap"><a href="#CSA-Compare-and-Swap" class="headerlink" title="CSA (Compare and Swap)"></a>CSA (Compare and Swap)</h3><p>CSA 的操作主要包括了 3 个操作数：</p>
<ul>
<li>需要读写的内存位置(V)</li>
<li>进行比较的预期值(A)</li>
<li>拟写入的新值(B)<br>具体的操作逻辑为：若内存位置的值等于预期的 A 值，则将该位置更新为新值 B, 否则不进行任何操作。<br>直到重试次数消耗完毕。<h3 id="CSA-实现"><a href="#CSA-实现" class="headerlink" title="CSA 实现"></a>CSA 实现</h3><blockquote>
<p>乐观锁（Optimistic Lock）,适用于多读</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"><span class="keyword">from</span> 应用名.models <span class="keyword">import</span> GoodsSKU</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类视图 (并发，乐观锁)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>(<span class="params">View</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @transaction.atomic</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;订单创建&#x27;&#x27;&#x27;</span></span><br><span class="line">        count = <span class="number">3</span>  <span class="comment"># 订购3件商品</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置事务保存点</span></span><br><span class="line">        s1 = transaction.savepoint()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 乐观锁，最多尝试5次</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="comment"># 查询商品的信息(库存)</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                sku = GoodsSKU.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="comment"># 商品不存在</span></span><br><span class="line">                transaction.savepoint_rollback(s1)</span><br><span class="line">                <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;res&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;errmsg&#x27;</span>: <span class="string">&#x27;商品不存在&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断商品的库存</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; sku.stock:</span><br><span class="line">                transaction.savepoint_rollback(s1)</span><br><span class="line">                <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;res&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;errmsg&#x27;</span>: <span class="string">&#x27;商品库存不足&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新商品的库存和销量</span></span><br><span class="line">            orgin_stock = sku.stock  <span class="comment"># 原库存 (数据库隔离级别必须是Read Committed；如果是Repeatable Read,那么多次尝试读取的原库存都是一样的,读不到其他线程提交更新后的数据。)</span></span><br><span class="line">            new_stock = orgin_stock - count  <span class="comment"># 更新后的库存</span></span><br><span class="line">            new_sales = sku.sales + count  <span class="comment"># 更新后的销量</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># update 商品表 set stock=new_stock, sales=new_sales where id=1 and stock = orgin_stock</span></span><br><span class="line">            <span class="comment"># 通过where子句中的条件判断库存是否进行了修改。(并发，乐观锁)</span></span><br><span class="line">            <span class="comment"># 返回受影响的行数</span></span><br><span class="line">            res = GoodsSKU.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">1</span>, stock=orgin_stock).update(stock=new_stock, sales=new_sales)</span><br><span class="line">            <span class="keyword">if</span> res == <span class="number">0</span>:  <span class="comment"># 如果修改失败</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">                    <span class="comment"># 如果尝试5次都失败</span></span><br><span class="line">                    transaction.savepoint_rollback(s1)</span><br><span class="line">                    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;res&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;errmsg&#x27;</span>: <span class="string">&#x27;下单失败&#x27;</span>&#125;)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># 再次尝试</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 否则更新成功</span></span><br><span class="line">            <span class="comment"># 跳出尝试循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提交事务</span></span><br><span class="line">        transaction.savepoint_commit(s1)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回应答</span></span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;res&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;创建成功&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="什么是悲观锁"><a href="#什么是悲观锁" class="headerlink" title="什么是悲观锁 ?"></a>什么是悲观锁 ?</h2><p>悲观锁在操作数据的时候，比较悲观，认为别人会同时修改数据。<br>因此操作数据时会直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据</p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>例如，有用户 A 和用户 B，在同一家店铺去购买同一个商品，但是商品的可购买数量只有一个<br><img src="/images/img.png" alt="direct"></p>
<p>若，用户 A 和用户 B 同时下单，就会报错。<br>悲观锁的实现，往往依靠数据库提供的锁机制，在数据库中，我们如何用悲观锁去结局这个事情呢？</p>
<ol>
<li>用户 A 在执行购买商品的时候，先尝试对该商品加上悲观锁。</li>
<li>若加锁失败，说明商品正在被其他事务进行修改，当前查询需要等待或者抛出异常，具体返回的方式需要开发者根据具体情况去定义</li>
<li>加锁成功：对商品进行修改</li>
<li>在此期间如果有其他用户对数据做修改或加锁的操作，都会等待我们解锁后或直接抛出异常<br><img src="/images/img_1.png" alt="direct"></li>
</ol>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>那么如何加上悲观锁呢，1. 首先关闭 MySQL 数据库的自动提交属性。因为 MySQL 默认使用 autocommit 模式（默认提交）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set autocommit = 0;</span><br></pre></td></tr></table></figure>
<p>悲观锁加锁 sql 语句： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select num form t_goods where id = 2 for update</span><br></pre></td></tr></table></figure>
<p>此时，其他事务都不能获取到此行的数据去进行操作。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式-Python 实现</title>
    <url>/posts/26a37a49/</url>
    <content><![CDATA[<h1 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式 ?"></a>什么是单例模式 ?</h1><blockquote>
<p>单例模式（Singleton Pattern）是软件设计中的一种常用设计模式，其目的是在一个进程中，确保某一个类(class)只有一个实例(instance)存在。<br>例如，当我们在操作数据库时，多个服务都要调用数据库的 connection ，其配置信息都是相同的，这种情况就可以使用单例模式。在该系统中，只使用一个用于连接数据库的 connection 实例</p>
</blockquote>
<h2 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a>单例模式的实现方式</h2><h3 id="1-模块构建"><a href="#1-模块构建" class="headerlink" title="1. 模块构建"></a>1. 模块构建</h3><blockquote>
<p><strong>Python 的模块就是天然的单例模式</strong>，模块在第一次导入的时候，会生成 <code>.pyc</code> 文件，就会直接加载<code>.pyc</code>文件，而不会再次执行模块<br>因此，我们只需要把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。</p>
</blockquote>
<p><strong>Singleton.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">singleton = Singleton()</span><br></pre></td></tr></table></figure>
<p>当我们需要使用这个 instance 的时候，直接使用即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Singleton <span class="keyword">import</span> singleton</span><br></pre></td></tr></table></figure>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><blockquote>
<p>使用 dict 类型，以 key-value 方式存储类的实例和运行的函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span>(<span class="params">cls</span>):</span></span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_singleton</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> _instance:</span><br><span class="line">            _instance[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> _instance[cls]</span><br><span class="line">    <span class="keyword">return</span> _singleton</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">a1 = A(<span class="number">1</span>)</span><br><span class="line">a2 = A(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a1 <span class="keyword">is</span> a2)</span><br></pre></td></tr></table></figure>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><blockquote>
<p>使用方法 <code>hasattr</code> 方法判断类中是否已实现了对应的实例方法，实现了就直接返回，未返回就添加单例属性</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line">obj = Singleton.instance()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是在<code>多线程</code>的使用中，由于每个线程有自己的数据资源，所以会<code>存在问题</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">arg</span>):</span></span><br><span class="line">    obj = Singleton.instance()</span><br><span class="line">    <span class="built_in">print</span>(obj) <span class="comment"># 显示 instance 的详情信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=task,args=[i,])</span><br><span class="line">    t.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上的实例显示出的详情可以看到 obj 的 id 并不一致，解决办法就是加 <code>锁</code>(mutex)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">with</span> Singleton.lock:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> Singleton._instance</span><br></pre></td></tr></table></figure>
<p>以上实现方式对整个实例的创建过程都进行了加锁，可以进行优化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                <span class="keyword">with</span> Singleton.lock:</span><br><span class="line">                    Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> Singleton._instance</span><br></pre></td></tr></table></figure>
<p>但是这样的实现方式，需要借助 <code>instance 方法</code></p>
<h3 id="new-方法实现"><a href="#new-方法实现" class="headerlink" title="__new__ 方法实现"></a><code>__new__</code> 方法实现</h3><blockquote>
<p>一个类在被实例化的过程中，先是执行默认的<code>__new__</code> 方法，然后再执行<code>__init__</code>方法初始化对象</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            <span class="keyword">with</span> cls._instance_lock:</span><br><span class="line">                cls._instance = <span class="built_in">super</span>.__new__(cls)</span><br><span class="line">            <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure>

<h3 id="metaclass-方式实现"><a href="#metaclass-方式实现" class="headerlink" title="metaclass 方式实现"></a><code>metaclass</code> 方式实现</h3><blockquote>
<ol>
<li>类由 <code>type</code>创建，创建类时，type 的 <code>__init__</code> 方法自动执行，类() 的方式执行<code>type</code> 的<code>__call__</code>方法（类的 <strong>new__、__init</strong> 方法）</li>
<li>对象由类创建，创建对象时，类的 <code>__init__</code> 方法自动执行，对象()执行类的<code>__call__</code> 方法</li>
</ol>
</blockquote>
<p>其实，我们就是要保证在创建类的时候，保证这个类只有一个实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonType</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    _instance_lock = threading.Lock</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            <span class="keyword">with</span> SingletonType._instance_lock:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                    cls._instance = <span class="built_in">super</span>.__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">                </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">metaclass=SingletonType</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊传输层协议- TCP 协议</title>
    <url>/posts/ac41cac4/</url>
    <content><![CDATA[<h1 id="什么是-TCP-协议？"><a href="#什么是-TCP-协议？" class="headerlink" title="什么是 TCP 协议？"></a>什么是 TCP 协议？</h1><blockquote>
<p>首先，TCP 协议是位于 <code>传输层</code>的协议，是<code>面向连接的</code>、<code>可靠的</code>流协议<br>TCP 为了提高可靠性传输，实行<code>顺序控制</code>或<code>重发控制</code>。此外还有<code>流量控制</code>、<code>拥塞控制</code>、<code>提高网络利用路</code>等众多功能</p>
</blockquote>
<p>下面，就从 TCP 协议的这些特点说开去：</p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><blockquote>
<p>TCP 协议是如何实现传输过程中的可靠性，又是怎么实现的？<br>一句话概括：TCP 通过 校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。<br>接下来，将引入包的传递过程，来带入这些概念：</p>
</blockquote>
<p>ack - 校验和</p>
<blockquote>
<p>客户端和服务端之间通过校验随机数+1，来确认连接</p>
</blockquote>
<p>ACK - 确认应答</p>
<blockquote>
<p>客户端和服务端使用确认应答 ACK 来知道二者的连接请求。</p>
</blockquote>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><blockquote>
<p>TCP 是提供面向连接的通信传输。面向连接指的就是在数据通信开始之前先建立连接，确保传输通道的连通性。<br>而所谓三次握手就是建立一个 TCP 连接时需要 客户端和服务端总共发送三个包以确认连接的建立</p>
</blockquote>
<p>这里引入三次握手来解释相关概念：校验和（ack）&amp;&amp; 确认应答（ACK）</p>
<p>流程图：<br><img src="/images/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="direct"></p>
<p>第一次握手：客户端将标志位 <code>SYN = 1</code>，随机生成一个值 <code>seq = j</code>，并将该数据包发送给服务端，客户端进入 <code>SUN_SENT</code> 状态，等待客户端的确认。<br>第二次握手：服务端接收到 <code>SYN = 1</code>的数据包后，明确客户端请求建立连接，服务端将标志位<code>SYN = 1、ACK=1</code>，随机生成一个随机数 <code>seq=k</code>，<strong>校验和 ack=j+1</strong>，并将该数据包发送给客户端以确认连接请求，服务器进入<code>SYN_RCVD</code>状态。<br>第三次握手：客户端收到确认后，检查<code>检验和 ack = j+1</code>,ACK=1。如果正确将标志位 ACK = 1 。<strong>校验和 ack = k+1</strong>,并将该数据包发送给服务器端，服务器端检查 <strong>检验和 ack = k+1,ACK=1</strong>,如果正确则连接建立成功，客户端和服务器端进入<code>ESTABLISHED</code>状态，完成三次握手，随后便可以开始通信了。</p>
<h3 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h3><blockquote>
<p>在数据的传输中，可能存在<code>数据包丢失</code>或者<code>未收到确认应答</code>的情况，此时为了实现<code>可靠传输</code>,就会触发<strong>重发机制</strong>。<br>但是，也会有部分原因导致确认应答延迟到达，数据包实际上已经到达来服务端，那么服务端就会反复的接收到相同的数据包，为了避免这种情况，就会有<strong>重复控制</strong>功能。</p>
</blockquote>
<p>上述<strong>确认应答机制</strong>、<strong>重发控制</strong>以及<strong>重复控制</strong>等功能都可以借助序列号来实现。</p>
<blockquote>
<p>序列号是按顺序给发送数据的每一个字节（8位字节）都标上号码的编号。将自己下一步应该接收的序列号作为确认应答返送回去。<br><img src="/images/%E5%BA%8F%E5%88%97%E5%8F%B7.png" alt="direct"></p>
</blockquote>
<p>通过序列号和确认应答号，TCP 就可以实现顺序传输和可靠传输</p>
<h2 id="重发超时如何确定"><a href="#重发超时如何确定" class="headerlink" title="重发超时如何确定"></a>重发超时如何确定</h2><blockquote>
<p>当发送端发送数据后，会有一个等待确认应答到来的特定时间间隔。若超过了这个时间仍未收到确认应答，发送端将数据进行数据重发。</p>
</blockquote>
<p>然而这个重发超时时间的确定是根据当前的网络环境确认的，随着网络环境的不同而有所变化。</p>
<p>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。<br>它在每次发包时都会计算<code>往返时间</code>及其<code>偏差</code>。</p>
<p>重发超时的值就是比<code>往返时间</code>和<code>偏差</code>相加大一点的值，由于数据包的分段是经过不同路线到达的，所以网络环境的往返时间可能会产生大幅度的摇摆。</p>
<p>TCP/IP 的目的就是即使在这种环境下也要进行控制，避免流量的浪费。</p>
<p><img src="/images/%E9%87%8D%E5%8F%91%E8%B6%85%E6%97%B6.png" alt="direct"></p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><blockquote>
<p>TCP 提供面向有连接的通信传输。面向有连接的是指在数据通信开始之前先做好通信两端之间的准备工作。<br>这里通常是指<code>三次握手和四次挥手</code><br><img src="/images/%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86.png" alt="direct"></p>
</blockquote>
<h2 id="TCP-发送数据的单位：段"><a href="#TCP-发送数据的单位：段" class="headerlink" title="TCP 发送数据的单位：段"></a>TCP 发送数据的单位：段</h2><blockquote>
<p>在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们称为<strong>最大消息长度</strong>（MSS: Maximum Segment Size）。<br>最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。</p>
</blockquote>
<h4 id="MSS-的计算方式"><a href="#MSS-的计算方式" class="headerlink" title="MSS 的计算方式"></a>MSS 的计算方式</h4><p>MSS 是在三次握手的时候，在两端主机之间被计算出。两端主机在建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 大小。<br>MSS 的大小就会在两者之间选择一个较小的值。</p>
<p><img src="/images/MSS%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F.png" alt="direct"></p>
<h2 id="窗口控制提高速度"><a href="#窗口控制提高速度" class="headerlink" title="窗口控制提高速度"></a>窗口控制提高速度</h2><blockquote>
<p>TCP 以 1 个段为单位，每发送一个段就进行一次确认应答的处理。但是这样传输的话，包的往返时间越长性能也就越低。<br>为了解决这个问题，TCP 就引入了窗口这个概念。即使在往返时间较长的情况下，它也能控制网络性能的下降。</p>
</blockquote>
<p><strong>确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅度的缩短</strong><br><img src="/images/%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6.png" alt="direct"></p>
<h3 id="重发控制"><a href="#重发控制" class="headerlink" title="重发控制"></a>重发控制</h3><blockquote>
<p>窗口控制中的重发控制，是以序列号进行管理的，当数据包丢失后，发送端会根据接收端序列号来进行重发<br><img src="/images/%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%9A%84%E9%87%8D%E5%8F%91.png" alt="direct"></p>
</blockquote>
<h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><blockquote>
<p>为了防止网络流量的无端浪费（接收端数据的处理）,TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。</p>
</blockquote>
<p>接收端告诉发送端自己接收的数据大小，实际上就是该窗口大小。<br><img src="/images/%E6%B5%81%E6%8E%A7%E5%88%B6.png" alt="direct"></p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><blockquote>
<p>一般来说，计算机网络都处在一个共享的环境，因此也有坑因为其他主机之间的通信使得网络拥堵。<br>所以，如果一开始发送端就发送一个特大的数据包，可能会导致整个网络的瘫痪。<br>为了防止这个问题，TCP 在通信一开始时，就会通过一个叫做慢启动的算法得出的数值，对发送数据量进行控制。</p>
</blockquote>
<p>首先，为了在发送端调节所要发送的数据的量，定义了一个叫做<code>拥塞窗口</code>的概念。在慢启动的时候，将这个拥塞窗口的大小设置为一个数据段（1 MSS）发送数据，<br>之后每收到一次确认应答（ACK）,拥塞窗口的值就加一。<br>不过，随着包的每次往返，拥塞窗口也会以 1、2、4 等指数函数的增长，拥堵状况激增甚至导致网络拥塞的发生。为了防止这些，又引入了慢启动阈值的概念。<br>只允许按照特定比例放大拥塞窗口：</p>
<p>1 个数据段的字节数/拥塞窗口（字节）* 1 个数据段字节数</p>
<p><img src="/images/%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3.png" alt="direct"></p>
<p>于是，当 TCP 通信开始以后，网络的吞吐量会 逐步上升，但是随着网络拥堵的发生吞吐量也会极速下降。<br>接着，会再次进入吞吐量慢慢上升的过程。因此所谓 TCP 的吞吐量的特点就像是在逐步占领网络带宽的感觉。</p>
<p>参考：1.「 图解 TCP/IP 」2. 「 TCP/IP 卷一 」</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
</search>

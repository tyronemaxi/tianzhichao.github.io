<hr>
<p>title: MySQL 索引总结 -<br>tags:</p>
<ul>
<li>MySQL<br>categories:</li>
<li>MySQL<br>description: MySQL 索引总结<br>abbrlink: 6e16c56e<br>date: 2022-04-16 10:47:22</li>
</ul>
<hr>
<h1 id="什么是-索引？"><a href="#什么是-索引？" class="headerlink" title="什么是 索引？"></a>什么是 <strong>索引</strong>？</h1><p><strong>索引（ MySQL 中也叫做<code>键(key)</code>）</strong> 是<strong>存储引擎</strong>用于<strong>快速找到记录</strong>的一种<strong>数据结构</strong>。本文主要学习的是基于 InnoDB 存储引擎。<br>索引对于良好的性能非常关键，对于较大的数据量来说，索引的创建愈发重要。</p>
<h1 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h1><blockquote>
<p>索引有很多种类型，可以为不同的场景提供更好的性能。</p>
</blockquote>
<h2 id="从存储结构上分"><a href="#从存储结构上分" class="headerlink" title="从存储结构上分"></a>从存储结构上分</h2><ul>
<li>Btree 索引 （B+tree、B-tree）</li>
<li>哈希索引</li>
<li>full-index 全文索引</li>
<li>RTree</li>
</ul>
<h2 id="从应用层次上划分"><a href="#从应用层次上划分" class="headerlink" title="从应用层次上划分"></a>从应用层次上划分</h2><ul>
<li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值</li>
<li>复合索引：一个索引包含多个列</li>
</ul>
<h2 id="从表记录的存储形式上来划分"><a href="#从表记录的存储形式上来划分" class="headerlink" title="从表记录的存储形式上来划分"></a>从表记录的存储形式上来划分</h2><ul>
<li>聚簇索引：表记录的排列顺序和索引的排列顺序一致</li>
<li>非聚簇索引：表记录的排列顺序和索引的排列顺序不一致</li>
</ul>
<h1 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h1><blockquote>
<p>在 InnoDB 中，表数据文件本身就是按照 B+Tree 组织的一个索引结构。<br>聚簇索引就是按照每张表的主键构造一颗 B+ 树，同时叶子节点中存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据页。<br>一般建表会用一个自增主键做聚簇索引，没有的话 MySQL 会默认创建<br>在日常的开发任务中，根据实际情况自行添加的索引都是辅助索引，辅助索引就是一个为了需要找主键索引的二级索引，先找到主键索引再通过主键索引找到数据。</p>
</blockquote>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><blockquote>
<p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。</p>
</blockquote>
<p>聚簇索引就是按照每张表的主键构建一颗 B+ 树，同时叶子节点存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据页。这个特性决定了索引组织表中的数据也是索引的一部分，每张表只能拥有一个聚簇索引。<br><img src="../../images/mysql/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="direct"></p>
<h2 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h2><ul>
<li>数据访问更快，因为**聚簇索引是将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快。</li>
<li>聚簇索引对于主键的排序查找和范围查找速度更快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</li>
</ul>
<h2 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h2><ul>
<li></li>
<li>插入速度严重依赖插入顺序，按照主键的顺序插入是最快的方式。一般定义一个自增的 ID 列作为主键，但是如果不是按照主键顺序加载数据，那么在jia</li>
<li>更新主键的代价很高，因为将会导致被更新的行移动，一般对于 InnoDB 表，定义主键不可更新</li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li>
</ul>
<h1 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h1><p>在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存放的不再是行的物理位置，而是主键值。<br>通过辅助索引找到主键值，再通过主键值找到数据行的数据页，再通过数据页中的 Page Directory 找到数据行。</p>
<p>InnoDB 辅助索引的叶子节点并不包含行记录的全部数据，叶子节点包含键值外，还包含了相应行数据的聚簇索引键。</p>
<h2 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B-Tree 索引"></a>B-Tree 索引</h2><blockquote>
<p>特点：<strong>每一个叶子节点都包含指向下一个叶子节点的指针</strong>，从而方便叶子节点的范围遍历</p>
</blockquote>
<p>B-Tree 通常意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。<br><img src="../../images/mysql/B+Tree%E7%B4%A2%E5%BC%95.png" alt="img.png"></p>
<h2 id="B-Tree-索引检索数据的原理"><a href="#B-Tree-索引检索数据的原理" class="headerlink" title="B-Tree 索引检索数据的原理"></a>B-Tree 索引检索数据的原理</h2><p>存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是<strong>从索引的根节点开始进行搜索</strong>。<br>根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。这些指针<strong>实际上定义了子节点页中值的上限和下限</strong>，通过比较<strong>节点页中的值和要查找的值</strong>可以找到合适的指针进入下层子节点。<br>最终存储引擎的查找只会有两种情况：<strong>1. 找到对应的值。2. 记录不存在。</strong></p>
<p><strong>叶子节点指针指向的是被索引的数据，而不是其他节点页。</strong></p>
<p>树的深度和表的大小直接相关</p>
<p>B-Tree 对索引列是顺序组织存储的，所以很适合查找范围数据。</p>
<p>B-Tree 索引适用于<strong>全值键、键值范围或键前缀</strong>查找。键前缀查找只适用于最左前缀查找</p>
<pre><code class="mysql">CREATE TABLE People (
    last_name varchar(50) not null DEFAULT &#39;&#39; comment &#39;姓&#39;,
    first_name varchar(50) not null DEFAULT &#39;&#39; comment &#39;名&#39;,
    dob date not null DEFAULT &#39;&#39; comment &#39;出生日期&#39;,
    gender enum(0, 1) not null comment &#39;&#39;,
    key(last_name, first_name, dob)
);

INSERT INTO People values (&#39;Cuba&#39;, &#39;Allen&#39;, &#39;1960-01-01&#39;),
(&#39;Angelina&#39;, &#39;Astaire&#39;, &#39;1980-03-04&#39;),
(&#39;Julla&#39;, &#39;Barrymore&#39;, &#39;2000-05-16&#39;),
(&#39;Christian&#39;, &#39;Akroyd&#39;, &#39;1958-12-07&#39;),
(&#39;Akroyd&#39;, &#39;Klrsten&#39;, &#39;1978-11-02&#39;)
</code></pre>
<p><img src="../../images/mysql/BTree%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9.png" alt="direct"></p>
<h2 id="B-Tree-索引的查询类型"><a href="#B-Tree-索引的查询类型" class="headerlink" title="B-Tree 索引的查询类型"></a>B-Tree 索引的查询类型</h2><blockquote>
<p>explain 分析 SQL 的执行计划<br>需要重点关注 type、rows、filtered、extra。<br>type 由上至下，效率越来越高</p>
<ul>
<li>ALL 全表扫描</li>
<li>index 索引全扫描</li>
<li>range 索引范围扫描，常用语&lt;,&lt;=,&gt;,=&gt;,between, in like 等操作</li>
<li>ref 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中</li>
<li>eq_ref 类似 ref,区别在于使用的是唯一索引，使用主键的关联查询</li>
<li>const/system 单条记录，系统会把匹配行中的其它列作为常数处理，如主键或唯一索引查询</li>
<li>null MySQL 不访问任何表或索引，直接返回结果</li>
</ul>
</blockquote>
<blockquote>
<p>虽然上至下，效率越来越高，但是根据cost模型，假设有两个索引<code>idx1(a, b, c)</code>,<code>idx2(a, c)</code>，SQL为<code>select * from t where a = 1 and b in (1, 2) order by c;</code>如果走idx1，那么是type为range，如果走idx2，那么type是ref；当需要扫描的行数，使用idx2大约是idx1的5倍以上时，会用idx1，否则会用idx2</p>
</blockquote>
<blockquote>
<p><strong>Extra</strong></p>
</blockquote>
<blockquote>
<ul>
<li>Using filesort：MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行。</li>
<li><strong>Using temporary：使用了临时表保存中间结果，性能特别差，需要重点优化</strong></li>
<li>Using index：表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，意味着无法直接通过索引查找来查询到符合条件的数据。</li>
<li>Using index condition：MySQL5.6之后新增的ICP，using index condtion就是使用了ICP（索引下推），在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。</li>
</ul>
</blockquote>
<ul>
<li><strong>全值匹配</strong><pre><code>**全值匹配指的是和索引中所有列进行匹配**
</code></pre>
例如:<pre><code class="mysql">explain select * from People
where last_name=&#39;Cuba&#39; and first_name=&#39;Allen&#39; and dob=&#39;1960-01-01&#39;\G;
</code></pre>
output:<pre><code class="markdown">id            | 1
select_type   | SIMPLE
table         | People
partitions    | &lt;null&gt;
type          | ref
possible_keys | last_name
key           | last_name
key_len       | 107
ref           | const,const,const
rows          | 1
filtered      | 100.0
Extra         | &lt;null&gt;
</code></pre>
</li>
</ul>
<p>这里的 type 为 ref, <strong>ref 表示使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录</strong>，常出现在关联查询中</p>
<ul>
<li><p><strong>匹配索引最左前缀</strong><br>  查找所有姓为 <code>Allen</code> 的人，例如 <code>explain select * from People where last_name=&#39;Cuba&#39;\G;</code><br>output:</p>
<pre><code class="markdown">id            | 1
select_type   | SIMPLE
table         | People
partitions    | &lt;null&gt;
type          | ref
possible_keys | last_name
key           | last_name
key_len       | 52
ref           | const
rows          | 2
filtered      | 100.0
Extra         | &lt;null&gt;
</code></pre>
</li>
<li><p><strong>匹配列前缀</strong><br>  查找只<strong>匹配某一列的值的开头部分</strong>，只使用到了索引的第一列。<br>例如 <code>explain select * from People where last_name like &#39;C%&#39;\G;</code></p>
</li>
</ul>
<p>output:</p>
<pre><code class="markdown">id            | 1
select_type   | SIMPLE
table         | People
partitions    | &lt;null&gt;
type          | range
possible_keys | last_name
key           | last_name
key_len       | 52
ref           | &lt;null&gt;
rows          | 2
filtered      | 100.0
Extra         | Using index condition
</code></pre>
<p>这里的 type 为 range, key 为 last_name, <strong>range 表示索引范围扫描，常用语&lt;,&lt;=,&gt;,=&gt;,between, in like 等操作</strong></p>
<ul>
<li><p>匹配范围值<br>  可用于查找姓在 <code>Angelina</code> 和 <code>Julla</code> 之间的人<br>例如：</p>
<pre><code class="mysql">select last_name from People
where last_name between &#39;Angelina&#39; and &#39;Julla&#39;;
</code></pre>
<p>output:</p>
<pre><code class="markdown">id            | 1
select_type   | SIMPLE
table         | People
partitions    | &lt;null&gt;
type          | range
possible_keys | last_name
key           | last_name
key_len       | 52
ref           | &lt;null&gt;
rows          | 3
filtered      | 100.0
Extra         | Using where; Using index
</code></pre>
<p>这里 key 使用为 last_name, type 为 range 范围查询。</p>
</li>
<li><p><strong>精确匹配某一列并范围匹配另一列, 即第一列全匹配，第二列 first_name 范围匹配</strong><br>例如：</p>
<pre><code class="mysql">explain select * from People
where last_name=&#39;Cuba&#39; and first_name between &#39;Allen&#39; and &#39;zxxx&#39;;
</code></pre>
<pre><code class="markdown">id            | 1
select_type   | SIMPLE
table         | People
partitions    | &lt;null&gt;
type          | range
possible_keys | last_name
key           | last_name
key_len       | 104
ref           | &lt;null&gt;
rows          | 2
filtered      | 100.0
Extra         | Using index condition
</code></pre>
<p>这里索引用到了 last_name, type 为 range 范围查询。</p>
</li>
<li><p><strong>只访问索引的查询</strong><br>B-Tree 通常可以支持 “只访问索引的查询”，即查询只需要访问索引，无需访问数据行。<br>例如：</p>
<pre><code class="mysql">select last_name from People
where last_name=&#39;Allen&#39;;
</code></pre>
</li>
<li><p>索引也可以用到 order by 排序操作，order by 子句满足前面列出的几种查询类型。</p>
</li>
</ul>
<h2 id="B-Tree-索引的限制"><a href="#B-Tree-索引的限制" class="headerlink" title="B-Tree 索引的限制"></a>B-Tree 索引的限制</h2><ul>
<li><strong>需要满足最左原则</strong>，即若不是按照索引的最左列开始查找的话，无法使用索引；<br>例如：<br>```mysql<br>explain select * from People<br>where first_name=’Allen’\G;</li>
</ul>
<p>explain select * from People<br>where dob=’1960-01-01’\G;</p>
<pre><code>output:
```markdown
id            | 1
select_type   | SIMPLE
table         | People
partitions    | &lt;null&gt;
type          | ALL
possible_keys | &lt;null&gt;
key           | &lt;null&gt;
key_len       | &lt;null&gt;
ref           | &lt;null&gt;
rows          | 7
filtered      | 14.29
Extra         | Using where
</code></pre>
<ul>
<li>不能跳过索引中的列。例如：<pre><code class="mysql">explain select * from People
where last_name=&#39;Cuba&#39; and dob=&#39;1960-01-01&#39;\G;
</code></pre>
output:<pre><code class="markdown">id            | 1
select_type   | SIMPLE
table         | People
partitions    | &lt;null&gt;
type          | ref
possible_keys | last_name
key           | last_name
key_len       | 52
ref           | const
rows          | 2
filtered      | 14.29
Extra         | Using index condition
</code></pre>
这样只是使用到了索引 <code>last_name</code>，<pre><code class="mysql">explain select * from People
where last_name=&#39;Cuba&#39; and first_name=&#39;Allen&#39; and dob=&#39;1960-01-01&#39;\G;
</code></pre>
</li>
</ul>
<pre><code class="markdown">id            | 1
select_type   | SIMPLE
table         | People
partitions    | &lt;null&gt;
type          | ref
possible_keys | last_name
key           | last_name
key_len       | 107
ref           | const,const,const
rows          | 1
filtered      | 100.0
Extra         | &lt;null&gt;
</code></pre>
<p>通过 ref 的 <code>const, const, const</code> 可以知道，前者只用到了 <code>last_name</code> index，而后者都用到了<br>这里可以看到 type 类型为 ALL 表示全表扫描；</p>
<ul>
<li>若查询中有<strong>某个列的范围查询，则右边所有列都无法使用索引优化查找</strong>。<br>例如：<pre><code class="mysql">explain select * from People
where last_name=&#39;Cuba&#39; and first_name like &#39;A%&#39; and dob=&#39;1960-01-01&#39;\G;
</code></pre>
output:<pre><code class="markdown">id            | 1
select_type   | SIMPLE
table         | People
partitions    | &lt;null&gt;
type          | range
possible_keys | last_name
key           | last_name
key_len       | 107
ref           | &lt;null&gt;
rows          | 1
filtered      | 14.29
Extra         | Using index condition
</code></pre>
<h1 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h1></li>
<li><strong>索引大大减少了服务器需要扫描的数据量</strong></li>
<li><strong>索引可以帮助服务器避免排序和临时表</strong></li>
<li>索引可以将随机 I/O 变为顺序 I/O</li>
<li>索引对于 InnoDB (对索引支持行级锁) 非常重要，因为它可以让查询锁更少的元祖。<br>在 MySQL 5.1 和更新的版本中，InnoDB 可以在服务器端过滤掉行后就释放锁，但在早期的 MySQL 版本中，InnoDB 直到事务提交时才会解锁。对不需要的元组的加锁，会增加锁的开销，降低并发性。<br>InnoDB 仅对需要访问的元组加锁，而<strong>索引能够减少 InnoDB 访问的元组数</strong>。但是只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。</li>
<li>关于 InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但是访问主键索引需要排他锁（写锁）</li>
</ul>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul>
<li><strong>由于索引的存在，在进行`INSERT、UPDATE、DELETE 时，需要进行数据的更新修改，会降低更新表的速度</strong>。MySQL 不仅要保存数据，还要保存索引文件。</li>
<li><strong>建立索引会占用磁盘空间的索引文件。当数据量比较大的表及组合索引较多时，索引文件会膨胀的很快</strong></li>
<li>如果某个数据列包含许多重复的内容，建立索引就没有实际效果。</li>
<li>对于数据量非常小的表，全表扫描更高效。</li>
</ul>
<p>综上：建立一个<code>好</code>的索引是非常考究的，需要根据业务和实际场景不断的优化。</p>
<h1 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h1><h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><p>这类索引是最基本的索引，普通索引的唯一任务就是加快对数据的访问速度。<br>这类索引应该只为最经常出现在查询条件（where column = ）或 排序条件（order by column）中的数据列创建索引。</p>
<ul>
<li>创建<pre><code class="mysql">ALTER TABLE table_name ADD INDEX index_name (column)
</code></pre>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2>普通索引允许被索引的数据列包含重复的值，而唯一索引列的值必须唯一，但允许有空值如果是组合索引，则列值的组合必须唯一</li>
</ul>
<pre><code class="mysql">CREATE UNIQUE INDEX idx_xxx ON my_table (column)
</code></pre>
<h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p>它是一种特殊的唯一索引，不允许有空值。一个表只能有一个主键。</p>
<p>一般在创建主键的时候，会同时创建。</p>
<h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>组合索引也可称为联合索引，为表的多个列创建索引；<br>为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。</p>
<p>例如：</p>
<pre><code class="mysql">ALTER TABLE my_table ADD INDEX idx_name_city_age (name, city, age)
</code></pre>
<p>建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：<br><code>username, city, age</code><br><code>username, city</code><br><code>username</code></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>「 高性能的索引 」</p>
